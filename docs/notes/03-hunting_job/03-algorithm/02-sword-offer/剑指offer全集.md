---
layout:  post
category:  algorithm
title:  No1ã€äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾
tagline:  by é˜¿ç§€
tags:
    - åŸåˆ›
    - å‰‘æŒ‡offer
    - æ•°æ®ç»“æ„ä¸ç®—æ³•
    - ç®—æ³•
    - ç¤¾æ‹›
    - æ ¡æ‹›
    - é˜¿ç§€
excerpt: No1ã€äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾
comment: false
---

<h1 align="center">å¸¦ä½ å¿«é€Ÿåˆ·å®Œ67é“å‰‘æŒ‡offer</h1>

<div style="border-color: #24C6DC;
            background-color: #e9f9f3;         
            margin: 1rem 0;
        padding: .25rem 1rem;
        border-left-width: .3rem;
        border-left-style: solid;
        border-radius: .5rem;
        color: inherit;">
  <p>è¿™æ˜¯äº”åˆ™æˆ–è®¸å¯¹ä½ æœ‰äº›è®¸å¸®åŠ©çš„ä¿¡æ¯:</p>
<p>0ã€ç»å¸¸çœ‹åˆ°æœ‰äººé—®å“ªé‡Œæœ‰æ±‡æ€»å¥½çš„æ ¡æ‹›æŠ•é€’å…¬å¸ä¿¡æ¯æ±‡æ€»ï¼Ÿç”šè‡³è¿˜æœ‰çš„äººèŠ±é’±å»ä¹°è¿™ç±»ä¿¡æ¯ï¼Œæ›´æœ‰ç”šè€…<span style="font-weight:bold;color:red">è¿˜æœ‰è¢«éª—çš„</span>ã€‚ã€‚ã€‚å…¶å®è¿™ç±»ä¿¡æ¯çœŸçš„å¾ˆå¤šï¼Œç‰›å®¢ç½‘ã€å‰ç¨‹æ— å¿§è¿™äº›æ‹›è˜ç½‘ç«™éƒ½å¸®ä½ æ€»ç»“å¥½äº†ï¼Œè¿™é‡Œåˆ†äº«ä¸€ä¸‹ä¸€ä½å­¦å¼Ÿå‘ŠçŸ¥çš„å‰ç¨‹æ— å¿§æ¨å‡ºçš„æ ¡æ‹›ä¿¡æ¯æ±‡æ€»ï¼Œä»–ä»¬æ¯å¤©éƒ½ä¼šåœ¨ç¾¤é‡Œå‘æ‹›è˜å…¬å¸ã€è¡Œä¸šã€å²—ä½ç­‰ï¼Œ<a href="https://mp.weixin.qq.com/s/XVrkXg5P0Z7rWhDAWkJDWA" target="_blank">ç‚¹æ­¤å…è´¹è·å–å‰ç¨‹æ— å¿§æ€»ç»“å¥½çš„æ ¡æ‹›èµ„è®¯æ±‡æ€»</a></p>  <p>1ã€ğŸ‘‰23å¹´5æœˆä»½æˆ‘ä»<a style="text-decoration: underline" href="https://mp.weixin.qq.com/s/zKItpGwIkHKK4g2aOlL2rA" target="_blank">å­—èŠ‚è·³åŠ¨ç¦»èŒè·³æ§½åˆ°æŸå¤–ä¼</a>æœŸé—´ï¼Œä¸º<span style="font-weight:bold">æ–¹ä¾¿è‡ªå·±æ‰¾å·¥ä½œï¼Œå¢åŠ ä¸Šå²¸å‡ ç‡</span>ï¼Œæˆ‘è‡ªå·±ä»0å¼€å‘äº†ä¸€ä¸ª<span style="font-weight:bold">å¤§å‚é¢è¯•çœŸé¢˜è§£æç½‘ç«™</span>ï¼ŒåŒ…æ‹¬ä¸¤ä¸ªå‰ç«¯å’Œä¸€ä¸ªåç«¯ã€‚èƒ½å¤Ÿå®šå‘æŸ¥çœ‹æŸäº›å…¬å¸çš„æŸäº›å²—ä½é¢è¯•çœŸé¢˜ï¼Œæ¯”å¦‚æˆ‘æƒ³æŸ¥ä¸€ä¸‹è¡Œä¸šä¸ºäº’è”ç½‘ï¼Œå…¬å¸ä¸ºå­—èŠ‚è·³åŠ¨ï¼Œè€ƒå¯Ÿå²—ä½ä¸ºåç«¯ï¼Œè€ƒå¯Ÿæ—¶é—´ä¸ºæœ€è¿‘ä¸€å¹´ä¹‹ç±»çš„é¢è¯•é¢˜æœ‰å“ªäº›ï¼Ÿ
<div align="center">
  <a  style="text-decoration: underline" href="https://top.interviewguide.cn/" target="_blank">  <img src="http://oss.interviewguide.cn/img/202308091638172.png" style="zoom:100%;" /></a>
<p style="font-weight:bold">è¡·å¿ƒå¸Œæœ›è‡ªå·±å¼€å‘çš„è¿™ä¸ªç½‘ç«™èƒ½å¤Ÿå¸®åˆ°æ›´å¤šçš„äººï¼Œè‡ªå·±èƒ½å¤Ÿä»¥æŠ€æœ¯æœåŠ¡äºå¤§å®¶ï¼</p>
</div>ç½‘ç«™åœ°å€ï¼š<a style="text-decoration: underline" href="https://top.interviewguide.cn/" target="_blank">InterviewGuideå¤§å‚é¢è¯•çœŸé¢˜è§£æç½‘ç«™</a>ã€‚ç‚¹æ­¤å¯ä»¥æŸ¥çœ‹è¯¥ç½‘ç«™çš„è§†é¢‘ä»‹ç»ï¼š<a style="text-decoration: underline" href="https://www.bilibili.com/video/BV1f94y1C7BL" target="_blank">Bç«™è§†é¢‘è®²è§£</a>   å¦‚æœå¯ä»¥çš„è¯æ±‚ä¸ªBç«™ä¸‰è¿ï¼Œæ„Ÿè°¢ï¼
  </p> 
  <p>2ã€ğŸ˜
    å…è´¹åˆ†äº«é˜¿ç§€ä¸ªäººå­¦ä¹ è®¡ç®—æœºä»¥æ¥æ”¶é›†åˆ°çš„å…è´¹å­¦ä¹ èµ„æºï¼Œ<a style="text-decoration: underline" href="/notes/07-resources/01-free/01-introduce.html" target="_blank">ç‚¹æ­¤ç™½å«–</a>ï¼›ä¹Ÿè®°å½•ä¸€ä¸‹è‡ªå·±ä»¥å‰ä¹°è¿‡çš„<a style="text-decoration: underline" href="/notes/07-resources/02-precious.html" target="_blank">ä¸é”™çš„è®¡ç®—æœºä¹¦ç±ã€ç½‘ç»œä¸“æ å’Œåƒåœ¾ä»˜è´¹ä¸“æ </a>ã€‚
  </p>
  <p>3ã€ğŸš€å¦‚æœä½ æƒ³åœ¨æ ¡æ‹›ä¸­é¡ºåˆ©æ‹¿åˆ°æ›´å¥½çš„offerï¼Œé˜¿ç§€å»ºè®®ä½ å¤šçœ‹çœ‹å‰äºº<a style="text-decoration: underline" href="https://www.yuque.com/tuobaaxiu/httmmc/npg1k81zeq4wfpyz" target="_blank">è¸©è¿‡çš„å‘</a>å’Œ<a style="text-decoration: underline"  target="_blank" href="https://www.yuque.com/tuobaaxiu/httmmc/gge9ppd0mbu2d3dp">ç•™ä¸‹çš„ç»éªŒ</a>ï¼Œäº‹å®ä¸Šä½ ç°åœ¨é‡åˆ°çš„å¤§å¤šæ•°é—®é¢˜ä½ çš„å­¦é•¿å­¦å§å¸ˆå…„å¸ˆå§åŸºæœ¬éƒ½å·²ç»é‡åˆ°è¿‡äº†ã€‚
  </p>
  <p>4ã€ğŸ”¥ æ¬¢è¿å‡†å¤‡è®¡ç®—æœºæ ¡æ‹›çš„å°ä¼™ä¼´åŠ å…¥æˆ‘çš„<a  style="text-decoration: underline" href="https://www.yuque.com/tuobaaxiu/httmmc/xg0otqvc17wfx4u9" target="_blank">å­¦ä¹ åœˆå­</a>ï¼Œä¸€ä¸ªäººè¸½è¸½ç‹¬è¡Œä¸å¦‚ä¸€ç¾¤äººæŠ¥å›¢å–æš–ï¼Œåœˆå­é‡Œæ²‰æ·€äº†å¾ˆå¤šè¿‡å»21/22/23å±Šå­¦é•¿å­¦å§çš„<a  style="text-decoration: underline" href="https://www.yuque.com/tuobaaxiu/httmmc/gge9ppd0mbu2d3dp" target="_blank">ç»éªŒå’Œæ€»ç»“</a>ï¼Œå¥½å¥½è·Ÿç€èµ°ä¸‹å»çš„ï¼Œæœ€ååŸºæœ¬éƒ½å¯ä»¥æ‹¿åˆ°ä¸é”™çš„offerï¼æ­¤å¤–ï¼Œæ¯å‘¨éƒ½ä¼šè¿›è¡Œ<a  style="text-decoration: underline" href="https://www.yuque.com/tuobaaxiu/httmmc/npg1k81zeq4wfpyz" target="_blank">ç²¾åæ€»ç»“å’Œåˆ†äº«ï¼</a>å¦‚æœä½ éœ€è¦ã€Šé˜¿ç§€çš„å­¦ä¹ ç¬”è®°ã€‹ç½‘ç«™ä¸­ğŸ“šï¸æ ¡æ‹›å…«è‚¡æ–‡ç›¸å…³çŸ¥è¯†ç‚¹çš„PDFç‰ˆæœ¬çš„è¯ï¼Œå¯ä»¥<a style="text-decoration: underline" href="https://www.yuque.com/tuobaaxiu/httmmc/qs0yn66apvkzw0ps" target="_blank">ç‚¹æ­¤ä¸‹è½½</a> ã€‚</p>   </div>





<p id="å¸¦ä½ å¿«é€Ÿåˆ·å®Œ67é“å‰‘æŒ‡offer"></p>

<h1 align="center">ã€Šå¸¦ä½ å¿«é€Ÿåˆ·å®Œ67é“å‰‘æŒ‡offerã€‹</h1>

> é˜¿ç§€è‡ªå·±åˆ·è¿‡çš„ç®—æ³•éƒ¨åˆ†ç»è¿‡æ•´ç†åæ˜¯æŒ‰ç…§ä¸åŒåŸºç¡€ã€ä¸åŒäººç¾¤åˆ†ç±»çš„ï¼Œå¦‚æœä½ ä¸çŸ¥é“è‡ªå·±è¯¥çœ‹å“ªä¸ªéƒ¨åˆ†çš„ç®—æ³•é¢˜ï¼Œå¯ä»¥å…ˆçœ‹ä¸€ä¸‹è¿™é‡Œï¼Œ[æˆ³æˆ‘ç›´è¾¾](/notes/03-hunting_job/03-algorithm/01-basic-algorithm/01-introduce.md)ã€‚

ä»¥ä¸‹æ˜¯æœ¬éƒ¨åˆ†æ­£æ–‡ï¼š

### **å‰è¨€**



> ä»¥ä¸‹æ‰€æœ‰é¢˜ç›®å‡æ¥è‡ªäºã€Šä½•æµ·æ¶›. å‰‘æŒ‡ Offer[M]. ç”µå­å·¥ä¸šå‡ºç‰ˆç¤¾, 2012.ã€‹ä¸€ä¹¦ä¸­

åˆ·é¢˜ç½‘ç«™æ¨èï¼š[åŠ›æ‰£ç½‘](https://www.nowcoder.com/ta/coding-interviews?from=cyc_github)ã€[ç‰›å®¢ç½‘](https://leetcode-cn.com/problemset/lcof/)

å› æœ¬äººä¸»è¦åœ¨ç‰›å®¢ç½‘ä¸Šåˆ·çš„å‰‘æŒ‡offerï¼Œæ‰€ä»¥æœ¬ä¸“æ é¢˜ç›®é¡ºåºä¸ç‰›å®¢ç½‘é¡ºåºä¿æŒä¸€è‡´ï¼Œæ¯é“é¢˜ç›®ä¸‹ä¹Ÿç»™å‡ºäº†ç›¸åº”çš„ç‰›å®¢ç½‘é“¾æ¥ã€‚

**æœ¬ä¸“æ ä»‹ç»**

-  æœ¬èµ„æ–™é€‚åˆäºæ ¡æ‹›ã€ç¤¾æ‹›å·¥ä½œå…šä»¥åŠæ‰“ç®—è½¬è¡Œåšè®¡ç®—æœºçš„ C++ æŠ€æœ¯æ ˆäººå£«ã€‚
-  æœ¬èµ„æ–™æ˜¯é˜¿ç§€æœ¬äººåœ¨ç§‹æ‹›å‰çš„åˆ·é¢˜è®°å½•ï¼ŒåŸºæœ¬æ±‡é›†äº†ç‰›å®¢ç½‘ä¸åŠ›æ‰£ç½‘ä¸Šå‰‘æŒ‡offerä¸“é¢˜çš„å„ç§**ç²¾å¦™è§£æ³•**
-  æ–‡ä¸­æœ‰é€‚é‡ä»£ç æ³¨é‡Šï¼Œä¸å°‘é¢˜ç›®éƒ½æœ‰è‡ªå·±å››åˆ·äº”åˆ·çš„è®°å½•ï¼Œå¦‚æœä½ æƒ³è¦åœ¨æœ€çŸ­æ—¶é—´å†…åˆ·å®Œå‰‘æŒ‡offerï¼Œæœ¬ä¸“æ æ˜¯ä½ ç»å¯¹ä¸åº”è¯¥é”™è¿‡çš„ï¼

å…³äºæ›´å¤šæœ¬ä¸“æ çš„ä»‹ç»å¯ä»¥ç‚¹æ­¤äº†è§£é˜¿ç§€çš„<font style="font-weight:bold; color:#4169E1;text-decoration:underline;" target="_blank">[**ç§‹æ‹›æ‰¾å·¥ä½œç»å†ä¸ä¸ªäººä»‹ç»**](Doc/Other/ContactMe/ContactMe.md#å…³äºé˜¿ç§€)</font>ã€‚

è¯¥å‰‘æŒ‡offeråˆ·é¢˜ç¬”è®°æ˜¯ç”±<font style="font-weight:bold; color:#4169E1;text-decoration:underline;" target="_blank">**é˜¿ç§€åŸåˆ›**</font>ï¼ŒåæœŸæ•´ç†å¹¶å‘å¸ƒï¼Œæœªç»å…¶æœ¬äººè®¸å¯ä¸å¾—æ“…è‡ªå‘å¸ƒåœ¨äº’è”ç½‘ä¸Šï¼Œå¦‚éœ€å¼•ç”¨è¯·æ ‡æ³¨å‡ºå¤„å¹¶<font style="font-weight:bold; color:#4169E1;text-decoration:underline;" target="_blank">[**å‘ŠçŸ¥æœ¬äºº**](Doc/Other/ContactMe/ContactMe.md#è”ç³»é˜¿ç§€)</font>ã€‚

å¦ï¼Œå› ä¸ªäººæ°´å‡†ä¸åŒï¼Œä¸‹é¢é¢˜ç›®ä¸­çš„ä¸€äº›è§è§£ä¸å…æ¶‰åŠä¸€äº›ä¸ªäººä¸»è§‚åˆ¤æ–­ï¼Œä½†ä¹Ÿä»…ä»£è¡¨æœ¬äººä¸ªäººæ„è§ï¼Œä¸ä»–äººæ— å…³~

æœ€åç¥æ„¿å¤§å®¶éƒ½èƒ½æ‹¿åˆ°å¥½ **offer** ~åŠ æ²¹ï¼å¥¥åˆ©ç»™ï¼

<br>

<p id = "äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾"></p>

**No1ã€äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&&tqId=11154&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

åœ¨ä¸€ä¸ªäºŒç»´æ•°ç»„ä¸­ï¼ˆæ¯ä¸ªä¸€ç»´æ•°ç»„çš„é•¿åº¦ç›¸åŒï¼‰ï¼Œæ¯ä¸€è¡Œéƒ½æŒ‰ç…§ä»å·¦åˆ°å³é€’å¢çš„é¡ºåºæ’åºï¼Œæ¯ä¸€åˆ—éƒ½æŒ‰ç…§ä»ä¸Šåˆ°ä¸‹é€’å¢çš„é¡ºåºæ’åºã€‚è¯·å®Œæˆä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥è¿™æ ·çš„ä¸€ä¸ªäºŒç»´æ•°ç»„å’Œä¸€ä¸ªæ•´æ•°ï¼Œåˆ¤æ–­æ•°ç»„ä¸­æ˜¯å¦å«æœ‰è¯¥æ•´æ•°ã€‚

~~~
[

 [1,2,8,9],
 [2,4,9,12],
 [4,7,10,13],
 [6,8,11,15]

]
~~~

ç»™å®š target = 7ï¼Œè¿”å› trueã€‚

ç»™å®š target = 3ï¼Œè¿”å› falseã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

```
7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]
```

**è¿”å›å€¼**

```
true
```

è¯´æ˜

```
å­˜åœ¨7ï¼Œè¿”å›true
```

**ç¤ºä¾‹2**

**è¾“å…¥**

```
3,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]
```

**è¿”å›å€¼**

```
false
```

**è¯´æ˜**

```
ä¸å­˜åœ¨3ï¼Œè¿”å›false
```

**1ã€ç¬¬ä¸€ç§æ–¹æ³•**

å³ä¸Šè§’é€æ¸é€¼è¿‘å·¦ä¸‹è§’ å¾ˆå¥½

- å¦‚æœå½“å‰ä½ç½®å…ƒç´ æ¯”targetå°ï¼Œåˆ™row++
- å¦‚æœå½“å‰ä½ç½®å…ƒç´ æ¯”targetå¤§ï¼Œåˆ™col--
- å¦‚æœç›¸ç­‰ï¼Œè¿”å›true
- å¦‚æœè¶Šç•Œäº†è¿˜æ²¡æ‰¾åˆ°ï¼Œè¯´æ˜ä¸å­˜åœ¨ï¼Œè¿”å›false

~~~cpp
    bool Find(int target, vecianzhtor<vector<int> > array) {
        if(array.empty() || array[0].empty()) return false;
        int row = array[0].size(), col = array.size();
 
        int w=row-1,h=0;
        while(w>=0&&h<col){           
            if(array[h][w]>target) w--;
            else if(array[h][w]<target) h++;
            else 
                return true;
        }
        return false;        
    }
~~~



**2ã€ç¬¬äºŒç§æ–¹æ³•**

æ¯è½®ç”¨äºŒåˆ†æ³•æ›¿æ¢ æŒºä¸é”™

æ‰§è¡Œç”¨æ—¶ :60 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†32.07%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€— :13.2 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
bool hasFound(vector<int>& array, int target) {

	int start = 0, end = array.size() - 1;
	while (start + 1 < end) {
		int mid = start + (end - start) /2;
		//cout << array[mid] << " "<<start<<" "<<mid<<" "<<end<<" ";
		if (array[mid] == target) return true;
		else if (array[mid] > target) end = mid;
		else
			start = mid;
	}
	if (array[start] == target || array[end] == target) return true;
	return false;

}



bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
	if (matrix.empty() || matrix[0].empty()) return false;
	for (int i = 0; i < matrix.size(); ++i) {
		if (hasFound(matrix[i], target)) return true;
	}
	return false;

}
~~~



**äºŒåˆ·ï¼šä¾ç„¶ä¸ä¼šï¼Œæ²¡æœ‰å¤´ç»ª...**

**1ã€ä»å³ä¸Šåƒå·¦ä¸‹æŸ¥æ‰¾æ…¢æ…¢é€¼è¿‘**

å› ä¸ºè¿™æ ·å°±æ–­äº†å®ƒå˜å¤§æˆ–è€…å˜å°çš„ä¸¤æ¡è·¯å¾„äº†ï¼Œ
å˜å¤§åªèƒ½å‘ä¸‹èµ°ï¼Œå°±æ˜¯h++,å˜å°åªèƒ½w--äº†

~~~cpp
    bool Find(int target, vector<vector<int> > array) {
        if(array.size() == 0 || array[0].size() == 0) return false;//æ¡ä»¶åˆ¤æ–­
        int row = array.size(), col = array[0].size();
        int w = col-1, h = 0;//å› ä¸ºè¿™æ ·å°±æ–­äº†å®ƒå˜å¤§æˆ–è€…å˜å°çš„ä¸¤æ¡è·¯å¾„äº†ï¼Œ
        //å˜å¤§åªèƒ½å‘ä¸‹èµ°ï¼Œå°±æ˜¯h++,å˜å°åªèƒ½w--äº†
        while( w>=0 && h<row){
            if( array[h][w] > target ) w--;
            else if( array[h][w] < target) h++;
            else
                return true;
        }
        return false;
    }
~~~



**2ã€æ¯ä¸ªæ•°ç»„ç”¨äºŒåˆ†æ³•ä»£æ›¿**

~~~cpp
    bool hasFind(vector<int>&nums, int target){
        int low = 0,high = nums.size()-1;
        while(low + 1 < high){
            int mid = low + (high - low)/2;
            if(nums[mid] > target) high = mid;
            else if(nums[mid] < target) low = mid;
            else
                return true;
        }
        
        if(nums[low] == target || nums[high] == target) return true;
        
        return false;        
        
    }
    bool Find(int target, vector<vector<int> > array) {
        if(array.size() == 0 || array[0].size() == 0) return false;//æ¡ä»¶åˆ¤æ–­
        int row = array.size();
        for(int i = 0; i < row; ++i){
            if(hasFind(array[i], target)) return true;
        }
        return false;
    }
~~~

<p id = "æ›¿æ¢ç©ºæ ¼"></p>

**No2ã€æ›¿æ¢ç©ºæ ¼**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank"> [ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&&tqId=11155&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œå°†ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªç©ºæ ¼æ›¿æ¢æˆâ€œ%20â€ã€‚ä¾‹å¦‚ï¼Œå½“å­—ç¬¦ä¸²ä¸ºWe Are Happy.åˆ™ç»è¿‡æ›¿æ¢ä¹‹åçš„å­—ç¬¦ä¸²ä¸ºWe%20Are%20Happyã€‚ 

**1ã€é¦–å…ˆç»Ÿè®¡å‡ºé•¿åº¦ï¼Œç„¶åä»åå‘å‰æ›¿æ¢**

~~~cpp
void replaceSpace(char *str,int length) {//int lengthæ˜¯æŒ‡å½“å‰çš„é•¿åº¦
    int spaceCount = 0;
    int totalLen = length;
    for(int i = 0; i < length; ++i){
        if(str[i] == ' ') spaceCount++;
    }

    totalLen += spaceCount*2;
    for(int i = length-1; i>=0 &&totalLen != i; --i){//å½“ i = totalLençš„æ—¶å€™è¯´æ˜å‰é¢å·²ç»
        //éƒ½æ²¡æœ‰ç©ºæ ¼äº†ï¼Œå¯ä»¥èŠ‚çº¦ä¸€éƒ¨åˆ†æ—¶é—´ï¼Œè€Œä¸æ˜¯ä¸€ç›´èµ‹å€¼ä¸‹å»
        if(str[i] != ' ') str[--totalLen] = str[i];
        else{
            str[--totalLen] = '0';
            str[--totalLen] = '2';
            str[--totalLen] = '%';                
        }

    }
}
~~~

<p id ="ä»å¤´åˆ°å°¾æ‰“å°é“¾è¡¨"></p>

**No3ã€ä»å°¾åˆ°å¤´æ‰“å°é“¾è¡¨**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&&tqId=11156&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸€ä¸ªé“¾è¡¨ï¼ŒæŒ‰é“¾è¡¨ä»å°¾åˆ°å¤´çš„é¡ºåºè¿”å›ä¸€ä¸ªArrayListã€‚ 

**1ã€è¿™é¢˜ä¹Ÿå¤ªå‚»é€¼äº†ï¼Œä»å‰å‘åä¿å­˜ï¼Œç„¶åreverseä¸å°±å¯ä»¥äº†å—ã€‚ã€‚ã€‚**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š504k

~~~cpp
vector<int> printListFromTailToHead(ListNode* head) {
    if( head == nullptr) return vector<int>();

    vector<int> result;
    while(head != nullptr){
        result.push_back(head->val);
        head = head->next;
    }

    reverse(result.begin(),result.end());
    return result;

}
~~~



**2ã€ä¸ç”¨reverseï¼Œè¿”å›ä¸€ä¸ªé€†åºä¹Ÿè¡Œ**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š480k

~~~cpp
vector<int> printListFromTailToHead(ListNode* head) {
    if( head == nullptr) return vector<int>();

    vector<int> result;
    while(head != nullptr){
        result.push_back(head->val);
        head = head->next;
    }

    // reverse(result.begin(),result.end());
    return vector<int>(result.rbegin(),result.rend());

}
~~~

<p id = "é‡å»ºäºŒå‰æ ‘"></p>

**No4ã€é‡å»ºäºŒå‰æ ‘**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&&tqId=11157&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

å¥½é¢˜ ç»å¯¹çš„å¥½é¢˜

è¾“å…¥æŸäºŒå‰æ ‘çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœï¼Œè¯·é‡å»ºå‡ºè¯¥äºŒå‰æ ‘ã€‚å‡è®¾è¾“å…¥çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœä¸­éƒ½ä¸å«é‡å¤çš„æ•°å­—ã€‚ä¾‹å¦‚è¾“å…¥å‰åºéå†åºåˆ—{1,2,4,7,3,5,6,8}å’Œä¸­åºéå†åºåˆ—{4,7,2,1,5,3,8,6}ï¼Œåˆ™é‡å»ºäºŒå‰æ ‘å¹¶è¿”å›ã€‚



**1ã€åŠ›æ‰£ä¸Šçš„ä¸€ç§è§£æ³•**

éœ€è¦é¦–å…ˆç†Ÿæ‚‰äºŒå‰æ ‘å…ˆåºéå†ä¸ä¸­åºéå†çš„è§„åˆ™ã€‚
å…ˆæ‰¾åˆ°preorderä¸­çš„èµ·å§‹å…ƒç´ ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œåœ¨inorderä¸­æ‰¾åˆ°æ ¹èŠ‚ç‚¹çš„ç´¢å¼•midï¼›é‚£ä¹ˆï¼Œpreorder[1:mid + 1]ä¸ºå·¦å­æ ‘ï¼Œpreorder[mid + 1:]ä¸ºå³å­æ ‘ï¼›inorder[0:mid]ä¸ºå·¦å­æ ‘ï¼Œinorder[mid + 1:]ä¸ºå³å­æ ‘ã€‚é€’å½’å»ºç«‹äºŒå‰æ ‘ã€‚

~~~cpp
TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
         if (pre.size() == 0 || vin.size() == 0) {
            return NULL;
        }
        TreeNode* treeNode = new TreeNode(pre[0]);
        int mid = distance(begin(vin), find(vin.begin(), vin.end(), pre[0]));
        vector<int> left_pre(pre.begin() + 1, pre.begin() + mid + 1);
        vector<int> right_pre(pre.begin() + mid + 1, pre.end());
        vector<int> left_in(vin.begin(), vin.begin() + mid);
        vector<int> right_in(vin.begin() + mid + 1, vin.end());

        treeNode->left = reConstructBinaryTree(left_pre, left_in);
        treeNode->right = reConstructBinaryTree(right_pre, right_in);
        return treeNode;
    }
~~~



**2ã€å€ŸåŠ©å“ˆå¸Œæ¥è¿›è¡ŒåŠ é€Ÿçš„ä¸€ç§åšæ³•**

~~~cpp
TreeNode* reConstructBinaryTree(vector<int> pre, vector<int> vin) {

	unordered_map<int, int> unmp;
	for (int i = 0; i < pre.size(); ++i) {
		unmp.insert({ vin[i],i });
	}
	return reConstructBinaryTreeCore(pre, unmp, 0, 0, pre.size() - 1);
}
TreeNode* reConstructBinaryTreeCore(vector<int>& preorder, unordered_map<int, int>& unmp, int root, int start, int end) {//å‰åºçš„root  ä¸­åºçš„startå’Œend
	if (start > end) return NULL;
	TreeNode* tree = new TreeNode(preorder[root]);
	int in_root_index = unmp[preorder[root]];

	tree->left = reConstructBinaryTreeCore(preorder, unmp, root + 1, start, in_root_index - 1);
	tree->right = reConstructBinaryTreeCore(preorder, unmp, (root + 1) + (in_root_index - 1 - start) + 1, in_root_index + 1, end);//å·¦å­æ ‘çš„æ ¹çš„ä½ç½®ï¼ŒåŠ ä¸Šå·¦å­æ ‘çš„é•¿åº¦å°±ç­‰äºå‰åºä¸­å³å­æ ‘æ ¹çš„ç´¢å¼•
	return tree;
}
~~~





**äºŒåˆ·ï¼šå€ŸåŠ©hashæ¥è¿›è¡ŒåŠ é€Ÿ**

3 ms	496K

~~~cpp
TreeNode* reConstructBinaryTreeCore(unordered_map<int, int> &hashMap,vector<int>& pre, int low1, vector<int>& vin, int low2, int high2) {

    if (low1 > (int)pre.size() || low2 > high2) return nullptr;//æ³¨æ„è¿™é‡Œæ˜¯å¯ä»¥ç­‰äºçš„ï¼Œåƒä¸‡è®°å¾—æ˜¯å¯ä»¥ç­‰äºçš„
	TreeNode* root = new TreeNode(pre[low1]);
	int index = hashMap[pre[low1]];
	root->left = reConstructBinaryTreeCore(hashMap, pre, low1 + 1, vin, low2, index - 1);
	root->right = reConstructBinaryTreeCore(hashMap, pre, low1 + 1 + index - low2, vin, index + 1, high2);
	return root;
}

TreeNode* reConstructBinaryTree(vector<int> pre, vector<int> vin) {

	unordered_map<int,int> hashMap;
    int len = vin.size();
	for (int i = 0; i < len; ++i) {
		hashMap.insert(make_pair(vin[i],i));//è¿™é‡Œåœ¨insertæ—¶å€™æ˜¯è¦make_pairä¸€ä¸‹çš„
	}

	return reConstructBinaryTreeCore(hashMap, pre, 0, vin, 0, vin.size()-1);
}
~~~

<p id = "ç”¨ä¸¤ä¸ªæ ˆæ¥å®ç°ä¸€ä¸ªé˜Ÿåˆ—"></p>

**No5ã€ ç”¨ä¸¤ä¸ªæ ˆæ¥å®ç°ä¸€ä¸ªé˜Ÿåˆ—**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&&tqId=11158&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

å®Œæˆé˜Ÿåˆ—çš„Pushå’ŒPopæ“ä½œã€‚ é˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¸ºintç±»å‹ã€‚ 

**1ã€å¾ˆç®€å•çš„ä¸€é“é¢˜**

è¿è¡Œæ—¶é—´ï¼š3ms å ç”¨å†…å­˜ï¼š376k

~~~cpp
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        while(stack1.size() != 1){
            stack2.push(stack1.top());
            stack1.pop();
            
        }
        int value = stack1.top();
        stack1.pop();
        while(!stack2.empty()){
            stack1.push(stack2.top());
            stack2.pop();
        }
        
        return value;        
    }

private:
    stack<int> stack1;//ä¿å­˜å…ƒç´ 
    stack<int> stack2;//è¾…åŠ©æ ˆ
};
~~~

<p id = "æ—‹è½¬æ•°ç»„"></p>

**No6ã€æ—‹è½¬æ•°ç»„**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜è¿æ¥](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&&tqId=11159&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>



**é¢˜ç›®æè¿°**

æŠŠä¸€ä¸ªæ•°ç»„æœ€å¼€å§‹çš„è‹¥å¹²ä¸ªå…ƒç´ æ¬åˆ°æ•°ç»„çš„æœ«å°¾ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºæ•°ç»„çš„æ—‹è½¬ã€‚

è¾“å…¥ä¸€ä¸ªéé€’å‡æ’åºçš„æ•°ç»„çš„ä¸€ä¸ªæ—‹è½¬ï¼Œè¾“å‡ºæ—‹è½¬æ•°ç»„çš„æœ€å°å…ƒç´ ã€‚ä¾‹å¦‚æ•°ç»„{3,4,5,1,2}ä¸º{1,2,3,4,5}çš„ä¸€ä¸ªæ—‹è½¬ï¼Œè¯¥æ•°ç»„çš„æœ€å°å€¼ä¸º1ã€‚

NOTEï¼šç»™å‡ºçš„æ‰€æœ‰å…ƒç´ éƒ½å¤§äº0ï¼Œè‹¥æ•°ç»„å¤§å°ä¸º0ï¼Œè¯·è¿”å›0ã€‚ 



**1ã€å¸¸è§„åšæ³•**

~~~cpp
 int minNumberInRotateArray(vector<int> rotateArray) {
    if (rotateArray.size() == 0) return 0;
    int minNum = rotateArray[0], len = rotateArray.size();
    for (int i = 1; i < len; ++i) {
        if (rotateArray[i] < minNum) return rotateArray[i];
    }
    return minNum;
    }
~~~



~~~cpp
    int minNumberInRotateArray(vector<int> rotateArray) {
    if (rotateArray.size() == 0) return 0;
    int  len = rotateArray.size();
    for (int i = 0; i < len-1; ++i) {
        if (rotateArray[i] > rotateArray[i+1]) return rotateArray[i+1];
    }
    return rotateArray[0];
    }
~~~



**2ã€äºŒåˆ†æ³• å¾ˆä¸é”™**

~~~cpp
int minNumberInRotateArray(vector<int> rotateArray) {
	if (rotateArray.size() == 0) return 0;
	int low = 0, high = rotateArray.size() - 1;
	while (low + 1 < high) {
		int mid = low + (high - low) / 2;
		if (rotateArray[mid] < rotateArray[high]) high = mid;
		else if (rotateArray[mid] == rotateArray[high]) high = high-1;
		else {
			low = mid;
		}
	}
	return min(rotateArray[low], rotateArray[high]);
}
~~~



**äºŒåˆ·**

**2-1ã€å¸¸è§„åšæ³•**

è¿è¡Œæ—¶é—´ï¼š26ms   å ç”¨å†…å­˜ï¼š1124k

~~~cpp
    int minNumberInRotateArray(vector<int> rotateArray) {
        
        if( rotateArray.size() == 0) return 0;
        if( rotateArray.size() == 1) return rotateArray[0];
        for(int i = 0; i < rotateArray.size()-1; ++i){
            if( rotateArray[i] > rotateArray[i + 1] ) return rotateArray[i+1];
        }
        return rotateArray[0];//èµ°åˆ°è¿™ä¸€æ­¥äº†ï¼Œå°±è¯´æ˜æ•´ä¸ªæ•°ç»„éƒ½æ˜¯é€’å¢æˆ–è€…éƒ½æ˜¯éé€’å‡çš„
    }
~~~



**2-2ã€äºŒåˆ†æ³•å˜ç§**

~~~cpp
    int minNumberInRotateArray(vector<int> rotateArray) {       
        if( rotateArray.size() == 0) return 0;
        int low = 0, high = rotateArray.size()-1;
        while(low + 1 < high){
            int mid = low + (high - low)/2;
            if(rotateArray[mid] < rotateArray[high]) high = mid;//è¯´æ˜å³è¾¹æœ‰åºï¼Œé‚£å°±å‘å·¦è¾¹èµ°
            else if(rotateArray[mid] == rotateArray[high]) high = high-1;// è¿™ç§æƒ…å†µè·Ÿæ˜¯ç‰¹ä¾‹åªèƒ½ä¸€ä¸ªä¸€ä¸ªçš„åˆ¤æ–­
            else
                low = mid;
        }

        return min(rotateArray[low], rotateArray[high]);
    }
~~~

<p id = "æ–æ³¢é‚£å¥‘æ•°åˆ—"></p>

**No7ã€æ–æ³¢é‚£å¥‘æ•°åˆ—**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&&tqId=11160&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

å¤§å®¶éƒ½çŸ¥é“æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œç°åœ¨è¦æ±‚è¾“å…¥ä¸€ä¸ªæ•´æ•°nï¼Œè¯·ä½ è¾“å‡ºæ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬né¡¹ï¼ˆä»0å¼€å§‹ï¼Œç¬¬0é¡¹ä¸º0ï¼Œç¬¬1é¡¹æ˜¯1ï¼‰ã€‚

**nâ‰¤39**

**ç¤ºä¾‹1**

**è¾“å…¥**

```
4
```

**è¿”å›å€¼**

```
3
```



easyä¸éœ€å†åˆ·

**1ã€é‡‡ç”¨ä¸‰ä¸ªå…ƒç´ ä¿å­˜æ•°ç»„å³å¯**

~~~cpp
    int Fibonacci(int n) {

	if (n == 1 || n == 2) return 1;//1ã€1ã€2ã€3ã€5ã€8ã€13ã€21ã€34
		if (n == 3) return 2;
	vector<int> F(3);
	F[0] = 1;
	F[1] = 1;
	F[2] = 2;
	for (int i = 3; i < n; ++i) {
		F[i % 3] = F[(i - 1) % 3] + F[(i - 2) % 3];


	}
	return F[(n - 1) % 3];
        
    }
~~~



**2ã€é€’å½’ï¼Œæ…¢å¾—å¤š**

~~~cpp
int Fibonacci(int n) {

	if(n==0) return 0;
    if (n == 1 || n == 2) return 1;//1ã€1ã€2ã€3ã€5ã€8ã€13ã€21ã€34
	return Fibonacci(n-1)+Fibonacci(n-2);
}
~~~

**äºŒåˆ·ï¼šå¾ˆç®€å•**

ä¸‰ä¸ªå…ƒç´ æ¥ä¿å­˜å…ƒç´ ï¼Œæ¥å›æ›¿æ¢å³å¯

è¿è¡Œæ—¶é—´ï¼š3ms å ç”¨å†…å­˜ï¼š360k

~~~cpp
int Fibonacci(int n) {
    if( n == 0) return 0;
    if( n == 1) return 1;
    int first = 0,second = 1,third = 1;
    for(int i = 2; i <= n; ++i){
        third = first + second;
        first =  second;
        second = third;
    }
    return third;
}
~~~



<p id = "è·³å°é˜¶"></p>

**No8ã€ è·³å°é˜¶**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&&tqId=11161&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ä¸€åªé’è›™ä¸€æ¬¡å¯ä»¥è·³ä¸Š1çº§å°é˜¶ï¼Œä¹Ÿå¯ä»¥è·³ä¸Š2çº§ã€‚æ±‚è¯¥é’è›™è·³ä¸Šä¸€ä¸ªnçº§çš„å°é˜¶æ€»å…±æœ‰å¤šå°‘ç§è·³æ³•ï¼ˆå…ˆåæ¬¡åºä¸åŒç®—ä¸åŒçš„ç»“æœï¼‰ã€‚ 



**1ã€é€’å½’åšæ³•ï¼ŒçœŸçš„å¾ˆè€—æ—¶**

~~~cpp
    int jumpFloor(int number) {
        if(number==1) return 1;
        if(number==2) return 2;
        return jumpFloor(number-1) + jumpFloor(number-2);
        
    }
~~~



**2ã€ç›´æ¥å¾ªç¯ä¼šå¥½å¾ˆå¤š**

~~~cpp
    int jumpFloor(int number) {
        if (number == 1) {
            return 1;
        }
        int first = 1;
        int second = 2;
        for (int i = 3; i <= number; ++i) {
            int third = first + second;
            first = second;
            second = third;
        }
        return second;        
    }
~~~



**äºŒåˆ·ï¼šå…¶å®å°±æ˜¯æ–æ³¢é‚£å¥‘æ•°åˆ—**

è¿è¡Œæ—¶é—´ï¼š3ms å ç”¨å†…å­˜ï¼š376k

~~~cpp
    int jumpFloor(int number) {
        
        if( number <= 2) return number;//0 1 2 ç›´æ¥è¿”å›å³å¯
        int first = 1, second = 2,third = 0;
        for(int i = 3;i <= number; ++i){
            third = first + second;
            first = second;
            second = third;
        }
        return third;
    }
~~~

<p id = "å˜æ€è·³å°é˜¶"></p>

**No9ã€å˜æ€è·³å°é˜¶**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&&tqId=11162&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ä¸€åªé’è›™ä¸€æ¬¡å¯ä»¥è·³ä¸Š1çº§å°é˜¶ï¼Œä¹Ÿå¯ä»¥è·³ä¸Š2çº§â€¦â€¦å®ƒä¹Ÿå¯ä»¥è·³ä¸Šnçº§ã€‚æ±‚è¯¥é’è›™è·³ä¸Šä¸€ä¸ªnçº§çš„å°é˜¶æ€»å…±æœ‰å¤šå°‘ç§è·³æ³•ã€‚



**1ã€çœ‹äº†è®²è§£è±ç„¶å¼€æœ—**

å› ä¸ºnçº§å°é˜¶ï¼Œç¬¬ä¸€æ­¥æœ‰nç§è·³æ³•ï¼šè·³1çº§ã€è·³2çº§ã€åˆ°è·³nçº§
è·³1çº§ï¼Œå‰©ä¸‹n-1çº§ï¼Œåˆ™å‰©ä¸‹è·³æ³•æ˜¯f(n-1)
è·³2çº§ï¼Œå‰©ä¸‹n-2çº§ï¼Œåˆ™å‰©ä¸‹è·³æ³•æ˜¯f(n-2)
æ‰€ä»¥f(n)=f(n-1)+f(n-2)+...+f(1)
å› ä¸ºf(n-1)=f(n-2)+f(n-3)+...+f(1)
æ‰€ä»¥f(n)=2*f(n-1)

~~~cpp

int jumpFloorII(int number) {

    if(number==1) return 1;
    return 2*jumpFloorII(number-1);
}
~~~



**2ã€ç¬¬äºŒç§æ–¹æ³•**

~~~cpp
    int jumpFloorII(int number) {

        if(number==1) return 1;
        int count=0,a=1;
        for(int i=2;i<=number;++i){
            count=a*2;
            a=count;
        }
        return count;
    }
~~~



**äºŒåˆ·ï¼šè¿˜è¡Œï¼Œæ‰¾å¥½è§„å¾‹**

è¿è¡Œæ—¶é—´ï¼š4ms å ç”¨å†…å­˜ï¼š488k

~~~cpp
int jumpFloorII(int number) {

    if( number <= 1) return number;
    return pow(2, number-1);
}
~~~

<p id = "çŸ©é˜µè¦†ç›–"></p>

**No10ã€çŸ©é˜µè¦†ç›–**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&&tqId=11163&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

æˆ‘ä»¬å¯ä»¥ç”¨2\*1çš„å°çŸ©å½¢æ¨ªç€æˆ–è€…ç«–ç€å»è¦†ç›–æ›´å¤§çš„çŸ©å½¢ã€‚

è¯·é—®ç”¨nä¸ª2\*1çš„å°çŸ©å½¢æ— é‡å åœ°è¦†ç›–ä¸€ä¸ª2*nçš„å¤§çŸ©å½¢ï¼Œæ€»å…±æœ‰å¤šå°‘ç§æ–¹æ³•ï¼Ÿ

æ¯”å¦‚n=3æ—¶ï¼Œ2*3çš„çŸ©å½¢å—æœ‰3ç§è¦†ç›–æ–¹æ³•ï¼š

![](http://oss.interviewguide.cn/img/202205072310734.png)



**1ã€å…¶å®å¾ˆç®€å•ï¼Œç”»ç”»å›¾å°±çŸ¥é“äº†ã€‚ã€‚ã€‚**

~~~cpp
    int rectCover(int number) {

        if(number<=2) return number;       
        return rectCover(number-1)+rectCover(number-2);
    }
~~~



**2ã€å¾ªç¯å¾ˆå¿«**

~~~cpp
    int rectCover(int number) {
	if (number <= 2) {
		return number;
	}
	int first = 1, second = 2, third = 3;
	for (int i = 3; i <= number; ++i) {
		third = first + second;
		first = second;
		second = third;
	}
	return third;
    }
~~~



**äºŒåˆ·ï¼šæ„Ÿè§‰è¿˜æ˜¯æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å˜ç§**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š464k

~~~cpp
    int rectCover(int number) {
        if( number <= 2) return number;
        int first = 1, second = 2, third = 0;
        for(int i = 3;i <= number; ++i){
            third = first + second;
            first = second;
            second = third;
        }       
        return third;
    }
~~~

<p id = "äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°"></p>

**No11ã€äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°** 

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&&tqId=11164&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸€ä¸ªæ•´æ•°ï¼Œè¾“å‡ºè¯¥æ•°32ä½äºŒè¿›åˆ¶è¡¨ç¤ºä¸­1çš„ä¸ªæ•°ã€‚å…¶ä¸­è´Ÿæ•°ç”¨è¡¥ç è¡¨ç¤ºã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~c
10
~~~
**è¿”å›å€¼**

~~~c
2
~~~



**1ã€è‡ªå·±å†™çš„ï¼Œé”™è¯¯çš„æƒ³æ³•**

~~~cpp
int  NumberOf1(int n) {

	if (n == 0) return 0;
	if (n > 0) {//æ­£æ•°
		int count = 0;
		while (n!=0) {
			if (n == 1) {
				return ++count;
			}
			if (n % 2 == 1) { 
				count++; 
			    n = n / 2;
			}
			else
				n = n / 2;			
		}
		return count;
	}
	else {//è´Ÿæ•°
		n = n * (-1) -1;//è´Ÿæ•°çš„è¡¥ç ç­‰äºå®ƒçš„æ­£æ•°éƒ¨åˆ†å‡ä¸€ï¼Œå–åå³å¯
		int count = 0;
		while (n != 0) {
			if (n == 1) {
				++count;
				break;
			}
			if (n % 2 == 0) {
				count++;
				n = n / 2;
			}
			else
				n = n / 2;
		}
		return count;


	}
}
~~~

-9çš„è¡¥ç æ˜¯32ä½çš„ï¼Œè€Œä¸æ˜¯6ä½ ï¼ˆ1  0111ï¼‰ï¼Œæ‰€ä»¥æœ‰1çš„ä¸ªæ•°ä¹Ÿä¸æ˜¯å››ä½ï¼Œintæ˜¯32ä½çš„



**2ã€bitsetçš„è¿ç”¨**

~~~cpp
int  NumberOf1(int n) {
	return bitset<32>(n).count();
	}
~~~



**3ã€ç‰›å®¢å¤§ç¥çš„åšæ³•**

~~~cpp

 int NumberOf1(int n) {
        int count = 0;
        while(n!= 0){
            count++;
            n = n & (n - 1);
         }
        return count;
    }
~~~

å¦‚æœä¸€ä¸ªæ•´æ•°ä¸ä¸º0ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•´æ•°è‡³å°‘æœ‰ä¸€ä½æ˜¯1ã€‚å¦‚æœæˆ‘ä»¬æŠŠè¿™ä¸ªæ•´æ•°å‡1ï¼Œé‚£ä¹ˆåŸæ¥å¤„åœ¨æ•´æ•°æœ€å³è¾¹çš„1å°±ä¼šå˜ä¸º0ï¼ŒåŸæ¥åœ¨1åé¢çš„æ‰€æœ‰çš„0éƒ½ä¼šå˜æˆ1(å¦‚æœæœ€å³è¾¹çš„1åé¢è¿˜æœ‰0çš„è¯)ã€‚å…¶ä½™æ‰€æœ‰ä½å°†ä¸ä¼šå—åˆ°å½±å“ã€‚    

**ä¸¾ä¸ªä¾‹å­**ï¼šä¸€ä¸ªäºŒè¿›åˆ¶æ•°1100ï¼Œä»å³è¾¹æ•°èµ·ç¬¬ä¸‰ä½æ˜¯å¤„äºæœ€å³è¾¹çš„ä¸€ä¸ª1ã€‚å‡å»1åï¼Œç¬¬ä¸‰ä½å˜æˆ0ï¼Œå®ƒåé¢çš„ä¸¤ä½0å˜æˆäº†1ï¼Œè€Œå‰é¢çš„1ä¿æŒä¸å˜ï¼Œå› æ­¤å¾—åˆ°çš„ç»“æœæ˜¯1011.æˆ‘ä»¬å‘ç°å‡1çš„ç»“æœæ˜¯æŠŠæœ€å³è¾¹çš„ä¸€ä¸ª1å¼€å§‹çš„æ‰€æœ‰ä½éƒ½å–åäº†ã€‚

è¿™ä¸ªæ—¶å€™å¦‚æœæˆ‘ä»¬å†æŠŠåŸæ¥çš„æ•´æ•°å’Œå‡å»1ä¹‹åçš„ç»“æœåšä¸è¿ç®—ï¼Œä»åŸæ¥æ•´æ•°æœ€å³è¾¹ä¸€ä¸ª1é‚£ä¸€ä½å¼€å§‹æ‰€æœ‰ä½éƒ½ä¼šå˜æˆ0ã€‚å¦‚1100&1011=1000.ä¹Ÿå°±æ˜¯è¯´ï¼ŒæŠŠä¸€ä¸ªæ•´æ•°å‡å»1ï¼Œå†å’ŒåŸæ•´æ•°åšä¸è¿ç®—ï¼Œä¼šæŠŠè¯¥æ•´æ•°æœ€å³è¾¹ä¸€ä¸ª1å˜æˆ0.é‚£ä¹ˆä¸€ä¸ªæ•´æ•°çš„äºŒè¿›åˆ¶æœ‰å¤šå°‘ä¸ª1ï¼Œå°±å¯ä»¥è¿›è¡Œå¤šå°‘æ¬¡è¿™æ ·çš„æ“ä½œã€‚



**äºŒåˆ·ï¼š1ã€bitsetç”¨æ³•ï¼š**

ä¸»è¦æ˜¯å°† n è½¬åŒ–ä¸º 32ä½è¡¨ç¤ºï¼Œint æœ€å¤§ä¹Ÿå°±æ˜¯ 2^32æ¬¡æ–¹ï¼Œç„¶ååˆ©ç”¨bitsetã€‚countï¼ˆï¼‰å‡½æ•°ï¼Œè¿”å› å…¶ä¸­ 1 çš„æ•°é‡

bitset<4> bitset1;ã€€ã€€//æ— å‚æ„é€ ï¼Œé•¿åº¦ä¸ºï¼”ï¼Œé»˜è®¤æ¯ä¸€ä½ä¸ºï¼

```cpp
bitset<8> bitset2(12);ã€€ã€€//é•¿åº¦ä¸ºï¼˜ï¼ŒäºŒè¿›åˆ¶ä¿å­˜ï¼Œå‰é¢ç”¨ï¼è¡¥å……

string s = "100101";
bitset<10> bitset3(s);ã€€ã€€//é•¿åº¦ä¸º10ï¼Œå‰é¢ç”¨ï¼è¡¥å……

char s2[] = "10101";
bitset<13> bitset4(s2);ã€€ã€€//é•¿åº¦ä¸º13ï¼Œå‰é¢ç”¨ï¼è¡¥å……

cout << bitset1 << endl;ã€€ã€€//0000
cout << bitset2 << endl;ã€€ã€€//00001100
cout << bitset3 << endl;ã€€ã€€//0000100101
cout << bitset4 << endl;ã€€ã€€//0000000010101

bitset<8> foo ("10011011");
 
cout << foo.count() << endl;ã€€ã€€//5ã€€ã€€ï¼ˆcountå‡½æ•°ç”¨æ¥æ±‚bitsetä¸­1çš„ä½æ•°ï¼Œfooä¸­å…±æœ‰ï¼•ä¸ªï¼‘
cout << foo.size() << endl;ã€€ã€€ //8ã€€ã€€ï¼ˆsizeå‡½æ•°ç”¨æ¥æ±‚bitsetçš„å¤§å°ï¼Œä¸€å…±æœ‰ï¼˜ä½

cout << foo.test(0) << endl;ã€€ã€€//trueã€€ã€€ï¼ˆtestå‡½æ•°ç”¨æ¥æŸ¥ä¸‹æ ‡å¤„çš„å…ƒç´ æ˜¯ï¼è¿˜æ˜¯ï¼‘ï¼Œå¹¶è¿”å›falseæˆ–trueï¼Œæ­¤å¤„foo[0]ä¸ºï¼‘ï¼Œè¿”å›true
cout << foo.test(2) << endl;ã€€ã€€//falseã€€ã€€ï¼ˆåŒç†ï¼Œfoo[2]ä¸ºï¼ï¼Œè¿”å›false
  
cout << foo.any() << endl;ã€€ã€€//trueã€€ã€€ï¼ˆanyå‡½æ•°æ£€æŸ¥bitsetä¸­æ˜¯å¦æœ‰ï¼‘
cout << foo.none() << endl;ã€€ã€€//falseã€€ã€€ï¼ˆnoneå‡½æ•°æ£€æŸ¥bitsetä¸­æ˜¯å¦æ²¡æœ‰ï¼‘
cout << foo.all() << endl;ã€€ã€€//falseã€€ã€€ï¼ˆallå‡½æ•°æ£€æŸ¥bitsetä¸­æ˜¯å…¨éƒ¨ä¸ºï¼‘
```



è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š496k

~~~cpp
int  NumberOf1(int n) {

	bitset<32> bit(n);//å°†å…¶åˆå§‹åŒ–ä¸º 32 ä½ï¼Œä¸è¶³ 32 ä½çš„å‰é¢è¡¥é½å³å¯
	return bit.count();// è¿”å›å…¶ä¸­ä¸º 1 çš„ä¸ªæ•°
}
~~~



**2ã€æ¸©ä¹ ä¸€ä¸‹ç‰›å®¢å¤§ç¥çš„åšæ³•**

å¦‚æœä¸€ä¸ªæ•´æ•°ä¸ä¸º0ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•´æ•°è‡³å°‘æœ‰ä¸€ä½æ˜¯1ã€‚å¦‚æœæˆ‘ä»¬æŠŠè¿™ä¸ªæ•´æ•°å‡1ï¼Œé‚£ä¹ˆåŸæ¥å¤„åœ¨æ•´æ•°æœ€å³è¾¹çš„1å°±ä¼šå˜ä¸º0ï¼ŒåŸæ¥åœ¨1åé¢çš„æ‰€æœ‰çš„0éƒ½ä¼šå˜æˆ1(å¦‚æœæœ€å³è¾¹çš„1åé¢è¿˜æœ‰0çš„è¯)ã€‚å…¶ä½™æ‰€æœ‰ä½å°†ä¸ä¼šå—åˆ°å½±å“ã€‚    

**ä¸¾ä¸ªä¾‹å­**ï¼šä¸€ä¸ªäºŒè¿›åˆ¶æ•°1100ï¼Œä»å³è¾¹æ•°èµ·ç¬¬ä¸‰ä½æ˜¯å¤„äºæœ€å³è¾¹çš„ä¸€ä¸ª1ã€‚å‡å»1åï¼Œç¬¬ä¸‰ä½å˜æˆ0ï¼Œå®ƒåé¢çš„ä¸¤ä½0å˜æˆäº†1ï¼Œè€Œå‰é¢çš„1ä¿æŒä¸å˜ï¼Œå› æ­¤å¾—åˆ°çš„ç»“æœæ˜¯1011.æˆ‘ä»¬å‘ç°å‡1çš„ç»“æœæ˜¯æŠŠæœ€å³è¾¹çš„ä¸€ä¸ª1å¼€å§‹çš„æ‰€æœ‰ä½éƒ½å–åäº†ã€‚

è¿™ä¸ªæ—¶å€™å¦‚æœæˆ‘ä»¬å†æŠŠåŸæ¥çš„æ•´æ•°å’Œå‡å»1ä¹‹åçš„ç»“æœåšä¸è¿ç®—ï¼Œä»åŸæ¥æ•´æ•°æœ€å³è¾¹ä¸€ä¸ª1é‚£ä¸€ä½å¼€å§‹æ‰€æœ‰ä½éƒ½ä¼šå˜æˆ0ã€‚å¦‚1100&1011=1000.ä¹Ÿå°±æ˜¯è¯´ï¼ŒæŠŠä¸€ä¸ªæ•´æ•°å‡å»1ï¼Œå†å’ŒåŸæ•´æ•°åšä¸è¿ç®—ï¼Œä¼šæŠŠè¯¥æ•´æ•°æœ€å³è¾¹ä¸€ä¸ª1å˜æˆ0.é‚£ä¹ˆä¸€ä¸ªæ•´æ•°çš„äºŒè¿›åˆ¶æœ‰å¤šå°‘ä¸ª1ï¼Œå°±å¯ä»¥è¿›è¡Œå¤šå°‘æ¬¡è¿™æ ·çš„æ“ä½œã€‚

è¿è¡Œæ—¶é—´ï¼š3ms å ç”¨å†…å­˜ï¼š376k

~~~cpp
int  NumberOf1(int n) {

	int res = 0;
    while(n != 0){
        n = n&(n-1);
        res++;
    }
	return res;
}
~~~

<p id = "æ•°å€¼çš„æ•´æ•°æ¬¡æ–¹"></p>

**No12ã€æ•°å€¼çš„æ•´æ•°æ¬¡æ–¹**  

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&&tqId=11165&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ç»™å®šä¸€ä¸ªdoubleç±»å‹çš„æµ®ç‚¹æ•°baseå’Œintç±»å‹çš„æ•´æ•°exponentã€‚æ±‚baseçš„exponentæ¬¡æ–¹ã€‚

ä¿è¯baseå’Œexponentä¸åŒæ—¶ä¸º0ã€‚ä¸å¾—ä½¿ç”¨åº“å‡½æ•°ï¼ŒåŒæ—¶ä¸éœ€è¦è€ƒè™‘å¤§æ•°é—®é¢˜ï¼Œä¹Ÿä¸ç”¨è€ƒè™‘å°æ•°ç‚¹åé¢0çš„ä½æ•°ã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

```
2.00000,3
```

**è¿”å›å€¼**

```
8.00000
```

**ç¤ºä¾‹2**

**è¾“å…¥**

```
2.10000,3
```

**è¿”å›å€¼**

```
9.26100
```

**ç¤ºä¾‹3**

**è¾“å…¥**

```
2.00000,-2
```

**è¿”å›å€¼**

```
0.25000
```

**è¯´æ˜**

```
2çš„-2æ¬¡æ–¹ç­‰äº1/4=0.25
```

**1ã€ä¸»è¦è¦æ³¨æ„æ­£è´Ÿæ•°çš„æƒ…å†µï¼Œè¦æ³¨æ„åˆ†å¼€**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š520k

~~~cpp
    double Power(double base, int exponent) {
        if( exponent == 0) return 1.0;
        if( base == 0.0 ) return 0.0;//ä¿è¯ä¸åŒæ—¶ä¸º0ï¼Œå…ˆå¤„ç†å„è‡ªä¸º0çš„æƒ…å†µ
        
        bool flag = false;//åˆ¤æ–­æŒ‡æ•°æ˜¯å¦ä¸ºè´Ÿ
        if( exponent < 0) {
            flag = true;
            exponent *=-1;//å¦‚æœä¸ºè´Ÿæ•°ï¼Œåˆ™å°†æŒ‡æ•°è½¬æ­£
        }
        double res = base; 
        for(int i = 2;i <= exponent; ++i){
            res *=base;//é€æ¸é€’ä¹˜
        }
        
        if(flag) return 1.0/res;
        else
            return res;
    }
~~~



**2ã€å¿«é€Ÿå¹‚ç®—æ³•ï¼Œå€¼å¾—å¥½å¥½çœ‹çœ‹ï¼ŒåŠ›æ‰£ä¸Šçš„è¦æ±‚æ›´ä¸¥è°¨ä¸€äº›**

 https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/ 

æ‰§è¡Œç”¨æ—¶ï¼š0 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š5.9 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
    double myPow(double x, int n) {
        if( n == 0) return 1;
        if( x == 0.0) return 0;
        long  exp = n;//
        if(n < 0) {
            exp = n* (-1.0);//ï¼Œå½“n == INT_MINæ—¶æ­£æ•°æ—¶å¤§äºINT_MAXçš„ï¼Œæ‰€ä»¥è¦ç”¨ä¸€ä¸ªå¤§äº INT_MAXçš„ç±»å‹æ¥ä¿å­˜ï¼ŒåŒæ—¶åœ¨å°†ä»–è½¬æ­£çš„æ—¶å€™ï¼Œ n*(-1)çš„ç»“æœä¾ç„¶æ˜¯ä¸€ä¸ª intï¼Œæ­¤æ—¶çš„intæ˜¯ä¸ªéšè—ç±»å‹ï¼Œç„¶åæ‰å°†è¿™ä¸ªç»“æœèµ‹å€¼ç»™ expï¼Œæ‰€ä»¥ç”¨æ¥ä¿å­˜ç»“æœå€¼çš„ä¸åº”è¯¥æ˜¯ä¸ªintå‹ï¼Œæˆ‘ä»¬ç”¨doubleå‹çš„ -1 ,è¿™æ ·å°±å¯ä»¥å°†ç›¸ä¹˜çš„ç»“æœå€¼ä¿å­˜ä¸ºä¸€ä¸ª doubleç±»å‹äº†ï¼Œç„¶åå†è¿›è¡Œèµ‹å€¼
        } 
        
        double res = 1.0;
        while(exp != 0){
            if( (exp &1) == 1 ){
                res *=x;
            }
            x *=x;
            exp >>= 1;
        }

        return n<0 ? 1/res: res;

    }
~~~

<p id = "è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºå¶æ•°å‰é¢"></p>

**No13ã€è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºå¶æ•°å‰é¢**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&&tqId=11166&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œå®ç°ä¸€ä¸ªå‡½æ•°æ¥è°ƒæ•´è¯¥æ•°ç»„ä¸­æ•°å­—çš„é¡ºåºï¼Œä½¿å¾—æ‰€æœ‰çš„å¥‡æ•°ä½äºæ•°ç»„çš„å‰åŠéƒ¨åˆ†ï¼Œæ‰€æœ‰çš„å¶æ•°ä½äºæ•°ç»„çš„ååŠéƒ¨åˆ†ï¼Œå¹¶ä¿è¯å¥‡æ•°å’Œå¥‡æ•°ï¼Œå¶æ•°å’Œå¶æ•°ä¹‹é—´çš„ç›¸å¯¹ä½ç½®ä¸å˜ã€‚ 



**1ã€æš´åŠ›è§£æ³•ï¼Œæ–°å¼€è¾Ÿä¸€ä¸ªæ•°ç»„ä¿å­˜æ•°æ®**

~~~cpp
void reOrderArray(vector<int>& array) {
	
	
	vector<int> temp(array.size(), 0);
	int low = 0;
	for (int i = 0; i < array.size(); ++i) {
		if ((array[i] & 1) == 1) { temp[low++] = array[i]; }
	}

	for (int i = 0; i < array.size(); ++i) {
		if ((array[i] & 1) == 0) { temp[low++] = array[i]; }
	}
	array.assign(temp.begin(), temp.end());
}
~~~



**2ã€ä¸€ç§å¾ˆå·§å¦™çš„è§£æ³•ï¼Œç©ºé—´å¤æ‚åº¦o1çš„åšæ³•ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯on^2**

~~~cpp
void reOrderArray(vector<int>& array) {
	
	for (int i = 0; i < array.size(); i++)
	{
		//for (auto a : array) {
		//	cout << a << " ";
		//}
		cout << endl;
		for (int j = array.size() - 1; j > i; j--)
		{
			if (array[j] % 2 == 1 && array[j-1] % 2 == 0) //å‰å¶åå¥‡å°±è¿›è¡Œäº¤æ¢ï¼Œè¿™æ ·ä¸€è¶Ÿä¸‹æ¥å¯ä»¥å°†ç¬¬ä¸€ä¸ªå¥‡æ•°æ”¾åœ¨é¦–ä½ï¼ŒåŒæ—¶æœ€åä¸€ä¸ªå¶æ•°æ”¾åœ¨æœ«å°¾
			{
				swap(array[j], array[j - 1]);
			}
		}
	}
}
~~~



**3ã€æ—¶é—´å’Œç©ºé—´éƒ½æ˜¯onçš„åšæ³•ï¼Œåªä¿å­˜å¶æ•°éƒ¨åˆ†**

~~~cpp
    void reOrderArray(vector<int> &array) {
    vector<int> temp(array.size(), 0);
	int oddIndex = 0, evenIndex = 0;
	for (auto a : array) {
		if ((a & 1) == 1) array[oddIndex++] = a;
		else
			temp[evenIndex++] = a;
	}

	for (int i = 0; i < evenIndex; ++i)
		array[oddIndex + i] = temp[i];
    }
~~~



**äºŒåˆ·ï¼š**

**1ã€ç¬¨æ–¹æ³•å¦å¤–å¼€è¾Ÿä¸€ä¸ªæ•°ç»„ï¼Œå…ˆä¿å­˜å¥‡æ•°ï¼Œå†ä¿å­˜å¶æ•°**

~~~cpp
    void reOrderArray(vector<int> &array) {
        
        int len = array.size();
        if(len <= 1) return;
        int index = 0;
        vector<int> temp(len,0);
        for(int i=0;i<len;++i){
            if(array[i] %2 == 1) temp[index++] = array[i];
        }
        
       for(int i=0;i<len;++i){
            if(array[i] %2 == 0) temp[index++] = array[i];
        }
        
        array.assign(temp.begin(), temp.end());
    }
~~~



**2ã€ä¸€ç§åŸåœ°è§£æ³•ï¼Œå¾ˆå·§å¦™ï¼Œä»åå‘å‰è¿›è¡Œä¿®æ­£ï¼Œç±»ä¼¼äºå†’æ³¡æ³•ï¼ŒåŒæ—¶å¯¹ä¸€åˆ·çš„æ—¶å€™è¿›è¡Œæ”¹è¿›**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š480k

~~~cpp
    void reOrderArray(vector<int> &array) {
        
	int len = array.size();
	if (len <= 1) return;
	for (int i = 0; i <= len/2; ++i) {

		for (int j = len - 1; j > i; --j) {
			if ( (array[j]&1) == 1 && (array[j - 1]&1) == 0)  swap(array[j], array[j - 1]);//å‰å¶åå¥‡å°±è¿›è¡Œäº¤æ¢ï¼Œå¹¶ä¸”ä¸€æ¬¡å°±å¯ä»¥å›ºå®šæœ€å‰é¢çš„å¥‡æ•°ä½ç½®åæœ€åé¢çš„å¶æ•°ä½ç½®ï¼Œæ‰€ä»¥æœ€å¤šåªéœ€è¦éå†ä¸€èˆ¬æ•°ç»„çš„é•¿åº¦å³å¯ï¼Œæ‰€ä»¥i<=len/2å³å¯
		}
	}
    }
~~~



**3ã€ç¬¬ä¸‰ç§è§£æ³•ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯åŸåœ°è§£æ³•ï¼Œè‡³å°‘æ¯”ç¬¬ä¸€ç§è¦å¥½ä¸€ç‚¹ï¼Œåªä¿å­˜å¶æ•°æ•°æ®**

è¿è¡Œæ—¶é—´ï¼š3ms å ç”¨å†…å­˜ï¼š484k  oddå¥‡æ•°ï¼ševenå¶æ•°

~~~cpp
    void reOrderArray(vector<int> &array) {
        
	int len = array.size(),evenIndex = 0,oddIndex = 0;
	if (len <= 1) return;        
    vector<int> temp(len/2+1,0);
	for (int i = 0; i <len; ++i) {

		if ( (array[i]&1) == 1)  array[oddIndex++] = array[i];
        else{
            temp[evenIndex++] = array[i];//å°†å¶æ•°å¦å¤–ä¿å­˜èµ·æ¥
        }

	}
        
    for(int j = 0;j < evenIndex; ++j){
        array[j + oddIndex] = temp[j];
    }
    }
~~~

<p id = "é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªç»“ç‚¹"></p>

**No14ã€ é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªç»“ç‚¹**  

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&&tqId=11167&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸€ä¸ªé“¾è¡¨ï¼Œè¾“å‡ºè¯¥é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªç»“ç‚¹ã€‚ 

**ç¤ºä¾‹1**

**è¾“å…¥**

```
1,{1,2,3,4,5}
```

**è¿”å›å€¼**

```
{5}
```

**1ã€æ¯”è¾ƒç®€å•çš„ä¸€ç§æ–¹æ³•**

æ—¶é—´å¤æ‚åº¦è¾ƒé«˜ï¼Œæ²¡æœ‰äºŒåˆ·çš„é‚£ç§æ–¹æ³•å¥½

~~~cpp
ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
        int count=0;
        ListNode * node=pListHead;
        while(pListHead!=nullptr){
            count++;
            pListHead=pListHead->next;
        }
        count = count-k;
        if(count<0) return nullptr;
        while(count--)
            node=node->next;
        return node;
    }
~~~



**äºŒåˆ·ï¼š**

**1ã€å¿«æ…¢æŒ‡é’ˆï¼Œä¸åº”è¯¥è¯´æ˜¯å…ˆåæŒ‡é’ˆ**

3 ms  376K

~~~cpp
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
    ListNode * slowNode = pListHead;
        while(k != 0){//è¿™é‡Œåˆ¤æ–­ k ä¸€ç›´èµ°åˆ° 0 å³å¯
            k--;
            if(pListHead != nullptr) pListHead = pListHead->next;//åœ¨å…¶ä¸­åˆ¤æ–­æ˜¯å¦å‡ºç°k å¤§äºé“¾è¡¨æ€»é•¿åº¦çš„æƒ…å†µï¼Œ
            //æ¯”å¦‚ ã€1,2,3,4,5ã€‘ 6è¿™æ ·çš„æƒ…å†µï¼Œå¦‚æœå‡ºç°è¿™æ ·çš„æƒ…å†µï¼Œè¿”å›å³å¯
            else
                return nullptr;
        }
        
        while(pListHead != nullptr){//å…ˆèµ°çš„ä¸èƒ½ä¸ºç©º
            slowNode = slowNode->next;
            pListHead = pListHead->next;
        }
        return slowNode;
    }

~~~

<p id = "åè½¬é“¾è¡¨"></p>

**No15ã€åè½¬é“¾è¡¨**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&&tqId=11168&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

 è¾“å…¥ä¸€ä¸ªé“¾è¡¨ï¼Œåè½¬é“¾è¡¨åï¼Œè¾“å‡ºæ–°é“¾è¡¨çš„è¡¨å¤´ã€‚ 

**ç¤ºä¾‹1**

**è¾“å…¥**

```
{1,2,3}
```

**è¿”å›å€¼**

```
{3,2,1}
```

å¾ˆå¥½çš„è§£ç­”

https://blog.csdn.net/qq_42351880/article/details/88637387

**1ã€å¤´æ’æ³• å¾ˆç»å…¸çš„åšæ³•å•Š**

~~~cpp
struct ListNode {
	int val;
	struct ListNode* next;
	ListNode(int x) :
		val(x), next(NULL) {
	}
}; 

ListNode* ReverseList(ListNode* pHead) {

	struct ListNode* Head = NULL;
	struct ListNode* node = (ListNode*)malloc(sizeof(struct ListNode));

	while (pHead != nullptr) {
		node = pHead;
		pHead = pHead->next;

		node->next = Head;
		Head = node;
	}
	return Head;
}

void test02()
{
	ListNode* head = (ListNode*)malloc(sizeof(ListNode));
	head->val = 1;

	ListNode* node1 = (ListNode*)malloc(sizeof(ListNode));
	node1->val = 2;

	ListNode* node2 = (ListNode*)malloc(sizeof(ListNode));
	node2->val = 3;

	ListNode* node3 = (ListNode*)malloc(sizeof(ListNode));
	node3->val = 4;

	head->next = node1;
	node1->next = node2;
	node2->next = node3;
	node3->next = nullptr;

	auto node = ReverseList(head);
	while(node!=nullptr){
	
		cout << node->val << endl;
		node = node->next;
	}
	}
~~~



**2ã€ç¬¬äºŒç§æ–¹æ³•ï¼Œå€ŸåŠ©ä¸‰ä¸ªç»“ç‚¹è¿›è¡Œä¸æ–­æ›´æ›¿**

~~~cpp
ListNode* ReverseList(ListNode* pHead) {

	struct ListNode* node0 = NULL;
	struct ListNode* node1 = (ListNode*)malloc(sizeof(struct ListNode));
	struct ListNode* node2 = (ListNode*)malloc(sizeof(struct ListNode));
	node1 = pHead;
	node2 = pHead->next;
	while (node1 != nullptr) {
		node1->next = node0;

		node0 = node1;
		node1 = node2;
		if (node2!= nullptr) {
			node2 = node2 -> next;
		}
	}
	return node0;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€å¤´æ’æ³•æ¥åšï¼Œå°†å…ƒç´ å¼€è¾Ÿåœ¨æ ˆä¸Šï¼Œè¿™æ ·ä¼šé¿å…å†…å­˜æ³„éœ²**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š364k

~~~cpp
ListNode* ReverseList(ListNode* pHead) {

	// å¤´æ’æ³•
	if (pHead == nullptr || pHead->next == nullptr) return pHead;
	ListNode dummyNode = ListNode(0);
	ListNode* pre = &(dummyNode);
	pre->next = pHead;
	ListNode* cur = pHead->next;
	pHead->next = nullptr;
	//pre = cur;
	ListNode* temp = nullptr;
	while (cur != nullptr) {
		temp = cur;
		cur = cur->next;
		temp->next = pre->next;
		pre->next = temp;
	}
	return dummyNode.next;

}
~~~



**2ã€å€ŸåŠ©ä¸‰ä¸ªèŠ‚ç‚¹æ¥è¿›è¡Œè¿­ä»£å³å¯**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š504k

~~~cpp
    ListNode* ReverseList(ListNode* pHead) {


	    if (pHead == nullptr || pHead->next == nullptr) return pHead;
	    ListNode * pre = nullptr,*cur = pHead,*after = pHead->next;
        while(cur != nullptr){//å»ºè®®ç”»ä¸ªå›¾çœ‹çœ‹å°±çŸ¥é“äº†
            cur->next = pre;
            pre = cur;
            cur = after;
            if(after != nullptr)
                after = after->next;
        }
        
        return pre;
    }
~~~

<p id = "åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨"></p>

**No16ã€åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&&tqId=11169&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸¤ä¸ªå•è°ƒé€’å¢çš„é“¾è¡¨ï¼Œè¾“å‡ºä¸¤ä¸ªé“¾è¡¨åˆæˆåçš„é“¾è¡¨ï¼Œå½“ç„¶æˆ‘ä»¬éœ€è¦åˆæˆåçš„é“¾è¡¨æ»¡è¶³å•è°ƒä¸å‡è§„åˆ™ã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

```
{1,3,5},{2,4,6}
```

**è¿”å›å€¼**

```
{1,2,3,4,5,6}
```

**1ã€å¸¸è§„åšæ³•ï¼Œéé€’å½’èŠ±äº†å¥½ä¹…æ‰åšå‡ºæ¥**

~~~cpp
struct ListNode {
	int val;
	struct ListNode* next;
	ListNode(int x) :
		val(x), next(NULL) {
	}
}; 


ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
       if (pHead1 == nullptr) return pHead2;
	if (pHead2 == nullptr) return pHead1;

	ListNode* Head = (ListNode*)malloc(sizeof(struct ListNode));

	if (pHead1->val <= pHead2->val) {
		Head = pHead1;
		pHead1 = pHead1->next;
	}else {
		Head = pHead2;
		pHead2 = pHead2->next;
	}

	ListNode* node = (ListNode*)malloc(sizeof(struct ListNode));
	node = Head;

	while (pHead1 && pHead2) {
		if (pHead1->val <= pHead2->val) {
			node->next = pHead1;
			pHead1 = pHead1->next;
			node = node->next;
		}
		else {
			node->next = pHead2;
			pHead2 = pHead2->next;
			node = node->next;
		}

	}
	if (pHead1 != nullptr) {
		node->next = pHead1;
	}
	else {
		node->next = pHead2;
	}
	return Head;
    }
    
    
    void test02()
{
	ListNode* head = (ListNode*)malloc(sizeof(ListNode));
	head->val = 1;

	ListNode* node1 = (ListNode*)malloc(sizeof(ListNode));
	node1->val = 5;

	ListNode* node2 = (ListNode*)malloc(sizeof(ListNode));
	node2->val = 9;

	ListNode* node3 = (ListNode*)malloc(sizeof(ListNode));
	node3->val = 11;
	//node3->next = NULL;

	head->next = node1;
	node1->next = node2;
	node2->next = node3;
	node3->next = nullptr;


	ListNode* head2 = (ListNode*)malloc(sizeof(ListNode));
	head2->val = 3;

	ListNode* node12 = (ListNode*)malloc(sizeof(ListNode));
	node12->val = 3;

	ListNode* node22 = (ListNode*)malloc(sizeof(ListNode));
	node22->val = 4;

	ListNode* node32 = (ListNode*)malloc(sizeof(ListNode));
	node32->val = 9;
	//node3->next = NULL;

	head2->next = node12;
	node12->next = node22;
	node22->next = node32;
	node32->next = nullptr;


	auto node = Merge(head,head2);
	while(node!=nullptr){
	
		cout << node->val << endl;
		node = node->next;
	}
}
~~~



**2ã€é€’å½’ç‰ˆæœ¬**

~~~cpp
 ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
	if (pHead1 == nullptr) return pHead2;
	if (pHead2 == nullptr) return pHead1;


  
	if (pHead1->val <= pHead2->val) {
		pHead1->next = Merge(pHead1->next, pHead2);
		return pHead1;
	}
	else {
		pHead2->next = Merge(pHead1, pHead2->next);
		return pHead2;
	}
    }
~~~



**äºŒåˆ·ï¼šå¾ˆå®¹æ˜“äº†**

**1ã€è¿­ä»£ç‰ˆæœ¬ï¼Œä¾ç„¶è¿˜æ˜¯è¿­ä»£ç‰ˆæœ¬è¦å¿«ä¸€ç‚¹**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š480k

~~~cpp
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        if(pHead1 == nullptr) return pHead2;
        if(pHead2 == nullptr) return pHead1;
        ListNode *newHead = new ListNode(-1),*node = newHead;
        //newHead->next=node;
        while(pHead1 != nullptr && pHead2 != nullptr){
            
            if(pHead1->val > pHead2->val)  swap(pHead1,pHead2);
            node->next = pHead1;
            pHead1 = pHead1->next;
            node = node->next;
        }
        
        node->next = (pHead1 ? pHead1:pHead2);
        return newHead->next;
    }
~~~



**2ã€é€’å½’ç‰ˆæœ¬**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š504k

~~~cpp
    void MergeCore(ListNode*newHead, ListNode*node1, ListNode*node2){
        if(node1 == nullptr || node2 == nullptr) {
            newHead->next = (node1?node1:node2);
            return ;
        }

        if(node1->val < node2->val){
            newHead->next = node1;
            node1 = node1->next;            
        }
        else{
            newHead->next = node2;
            node2 = node2->next;
            
        }
        newHead = newHead->next;
        MergeCore(newHead,node1,node2);
    }
    
    
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        if(pHead1 == nullptr) return pHead2;
        if(pHead2 == nullptr) return pHead1;
        ListNode *newHead = new ListNode(-1),*node = newHead;
        MergeCore(node, pHead1, pHead2);
        return newHead->next;
    }
~~~

<p id = "æ ‘çš„å­ç»“æ„"></p>

**No17ã€æ ‘çš„å­ç»“æ„**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&&tqId=11170&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸¤æ£µäºŒå‰æ ‘Aï¼ŒBï¼Œåˆ¤æ–­Bæ˜¯ä¸æ˜¯Açš„å­ç»“æ„ã€‚ï¼ˆpsï¼šæˆ‘ä»¬çº¦å®šç©ºæ ‘ä¸æ˜¯ä»»æ„ä¸€ä¸ªæ ‘çš„å­ç»“æ„ï¼‰

**ç¤ºä¾‹1**

**è¾“å…¥**

```
{8,8,#,9,#,2,#,5},{8,9,#,2}
```

**è¿”å›å€¼**

```
true
```

**1ã€è§£æè§[åŠ›æ‰£-14 æ ‘ - medium - é¢è¯•é¢˜26](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)ï¼Œè®²å¾—å¾ˆå¥½**

~~~cpp
    bool HasSubtreeCore(TreeNode* pRoot1, TreeNode* pRoot2){
        if(pRoot2==nullptr)  return true;
        if(pRoot1==nullptr) return false;
        if(pRoot1->val == pRoot2->val)
            return HasSubtreeCore(pRoot1->left,pRoot2->left) && HasSubtreeCore(pRoot1->right,pRoot2->right);
        else
            return false;
    }
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        if(pRoot1==nullptr || pRoot2==nullptr) return false;
        return HasSubtree(pRoot1->left,pRoot2) ||
               HasSubtree(pRoot1->right,pRoot2) || 
                HasSubtreeCore(pRoot1,pRoot2);
            
     }
~~~



**äºŒåˆ·ï¼š**

**1ã€æ ‘çš„é¢˜ç›®ï¼Œå¤§å¤šéƒ½æ˜¯é€’å½’æ¥åš**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š484k

~~~cpp
bool HasSubtreeCore(TreeNode* pRoot1, TreeNode* pRoot2){
        
        if(pRoot2 == nullptr) return true;//p2ä¸ºç©º ï¼Œé‚£ä¹ˆP1ä¸ºä»€ä¹ˆéƒ½æ˜¯ç›¸ç­‰çš„äº†
        if(pRoot1 == nullptr ) return false;//å¦‚æœp2ä¸ä¸ºç©ºï¼Œä½†æ˜¯p1ä¸ºç©ºï¼Œé‚£è‚¯å®šæ˜¯ä¸å¯¹çš„
        if(pRoot1->val == pRoot2->val)//å½“å‰ä¸€æ ·ï¼Œå†åˆ¤æ–­å·¦å³å­æ ‘ï¼Œè¿™é‡Œå¿…é¡»æ˜¯ ä¸ çš„å¹¶åˆ—å…³ç³»æ‰è¡Œ
            return HasSubtreeCore(pRoot1->left,pRoot2->left) && HasSubtreeCore(pRoot1->right,pRoot2->right);
        else{
            return false;
        }
        
    }
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {

        if(pRoot1 == nullptr || pRoot2 == nullptr) return false;
        
        return HasSubtree(pRoot1->left, pRoot2) ||//æœ‰å¯èƒ½æ˜¯æˆ‘çš„å·¦å­æ ‘
               HasSubtree(pRoot1->right, pRoot2) || //æˆ–åˆ™æ˜¯å³å­æ ‘
                HasSubtreeCore(pRoot1, pRoot2);//æˆ–è€…æ˜¯å½“å‰èŠ‚ç‚¹å°±å¼€å§‹æ¯”è¾ƒï¼Œæ³¨æ„è¿™é‡Œæ˜¯ æˆ– çš„å…³ç³»

    }
~~~

<p id = "äºŒå‰æ ‘çš„é•œåƒ"></p>

**No18ã€äºŒå‰æ ‘çš„é•œåƒ**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&&tqId=11171&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

æ“ä½œç»™å®šçš„äºŒå‰æ ‘ï¼Œå°†å…¶å˜æ¢ä¸ºæºäºŒå‰æ ‘çš„é•œåƒã€‚ 

**è¾“å…¥æè¿°:**
äºŒå‰æ ‘çš„é•œåƒå®šä¹‰ï¼šæºäºŒå‰æ ‘ 

~~~
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	é•œåƒäºŒå‰æ ‘
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11  9 7  5                
~~~

**1ã€å€ŸåŠ©é˜Ÿåˆ—æ¥åšï¼Œè·Ÿä¸Šé¢ä¸€é¢˜ä¸­çš„è¿­ä»£ç‰ˆæœ¬å¾ˆåƒ**

~~~cpp
void Mirror(TreeNode* pRoot) {
	if (pRoot == nullptr) return;
	queue<TreeNode*> q;
	q.push(pRoot);
	while (!q.empty()) {
		TreeNode* node = q.front();
		q.pop();
		if (node)
		{
			q.push(node->left);
			q.push(node->right);
			swap(node->left, node->right);
		}
	}
}
~~~

**2ã€ä¸ä½¿ç”¨swapå‡½æ•°çš„è¿­ä»£ç‰ˆæœ¬**

~~~cpp
void Mirror(TreeNode* pRoot) {
	if (pRoot == nullptr) return;
	queue<TreeNode*> q;
	q.push(pRoot);
	while (!q.empty()) {
		TreeNode* node = q.front();
		q.pop();
		if (node)
		{
			q.push(node->left);
			q.push(node->right);
			//swap(node->left, node->right);
			TreeNode* temp = node->left;
			node->left = node->right;
			node->right = temp;
		}
	}
}
~~~

**3ã€é€’å½’ç‰ˆæœ¬**

~~~cpp
    void Mirror(TreeNode *pRoot) {
	if (pRoot == nullptr) return;
	TreeNode* temp = pRoot->left;
	pRoot->left = pRoot->right;
	pRoot->right = temp;
	Mirror(pRoot->right);
	Mirror(pRoot->left);
    }
~~~

**4ã€æ ˆçš„è¿­ä»£ç‰ˆæœ¬**

~~~cpp
void Mirror(TreeNode* pRoot) {
	if (pRoot == nullptr) return;
	stack<TreeNode*> s;
	s.push(pRoot);
	while (!s.empty()) {
		TreeNode* node = s.top();
		s.pop();
		if (node) {
			s.push(node->left);
			s.push(node->right);
			swap(node->left, node->right);
		}
	}
}
~~~



**äºŒåˆ·ï¼š**

**1ã€è¿­ä»£ç‰ˆæœ¬ï¼Œæƒ³å¤šäº†**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š376k

é˜Ÿåˆ—æ¥åšï¼Œæœ‰ç‚¹ç±»ä¼¼äºå±‚æ¬¡éå†çš„æ„æ€

~~~cpp
    void Mirror(TreeNode *pRoot) {//æœ‰ç‚¹ç±»ä¼¼äºäºŒå‰æ ‘çš„å±‚æ¬¡éå†
        if(pRoot == nullptr) return;
        queue<TreeNode*> q;
        TreeNode *node = nullptr;
        q.push(pRoot);
        while(!q.empty()){
                node = q.front();
                q.pop();
            if(node != nullptr)
            {   q.push(node->left);
                q.push(node->right);                
                swap(node->left,node->right);
            }
        }
    }
~~~



**2ã€é€’å½’ç‰ˆæœ¬ï¼Œè€Œæ›´å®¹æ˜“ç†è§£ä¸€äº›ï¼Œä¹Ÿæ›´å¥½å†™**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š504k

~~~cpp
    void Mirror(TreeNode *pRoot) {//æœ‰ç‚¹ç±»ä¼¼äºäºŒå‰æ ‘çš„å±‚æ¬¡éå†
        if(pRoot == nullptr) return;             
        swap(pRoot->left,pRoot->right);
        Mirror(pRoot->left);
        Mirror(pRoot->right);
    }
~~~

<p id = "é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ"></p>

**No19ã€é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ**



<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&&tqId=11172&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸€ä¸ªçŸ©é˜µï¼ŒæŒ‰ç…§ä»å¤–å‘é‡Œä»¥é¡ºæ—¶é’ˆçš„é¡ºåºä¾æ¬¡æ‰“å°å‡ºæ¯ä¸€ä¸ªæ•°å­—ï¼Œä¾‹å¦‚ï¼Œå¦‚æœè¾“å…¥å¦‚ä¸‹4 X 4çŸ©é˜µï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 åˆ™ä¾æ¬¡æ‰“å°å‡ºæ•°å­—1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 

**ç¤ºä¾‹1**

**è¾“å…¥**

```
[[1,2],[3,4]]
```

**è¿”å›å€¼**

```
[1,2,4,3]
```

**1ã€æœ‰ç‚¹éš¾ï¼Œåœ¨åŠ›æ‰£ä¸Šå†™äº†å¥½ä¹…**

ä¸»è¦å°±æ˜¯åˆ†ææ¸…æ¥šä¸Šä¸‹å·¦å³çš„æƒ…å†µ

æ‰§è¡Œç”¨æ—¶ï¼š0 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š6.7 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
vector<int> spiralOrder(vector<vector<int>>& matrix) {
	if (matrix.size()==0) return vector<int>();
	if (matrix.size() == 1) return matrix[0];
	int row = matrix.size(), col = matrix[0].size();
	int left = 0, right = 0, top = 0, bottom = 0;
	vector<int> result;
	while (left + right < col && top + bottom < row) {
		
		for (int i = left; i < col - left - right + left; ++i) {
			//cout << matrix[top][i];
			result.push_back(matrix[top][i]);
		}

		top++;
		//cout << " top " <<top<<bottom<< endl;
		if (top + bottom == row) break;


		for (int i = top; i < row - top - bottom + top; ++i) {
			//cout << matrix[i][col - right - 1];
			result.push_back(matrix[i][col - right - 1]);
		}		
		right++;
		//cout << "right"<<left<<right<<endl;
		if (left + right == col) break;


		for (int i = col-right-1; i >= left ; --i) {
			//cout << matrix[row - bottom - 1][i];
			result.push_back(matrix[row - bottom - 1][i]);
		}
		bottom++;
		//cout << " bottom " << top << bottom << endl;
		if (top + bottom == row) break;
		

		for (int i = row-bottom-1; i >= top; --i) {
			//cout << matrix[i][left];
			result.push_back(matrix[i][left]);
		}
		left++;
		//cout << "left" << left << right << endl;
	}
	return result;
}
~~~



**2ã€æ–°çš„å†™æ³•ï¼Œè¿™ç§å…¶å®æ›´å¥½ç†è§£**

æ‰§è¡Œç”¨æ—¶ï¼š24 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†56.85%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š10 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector <int> res;
        if(matrix.empty()) return res;
        int rl = 0, rh = matrix.size()-1; //è®°å½•å¾…æ‰“å°çš„çŸ©é˜µä¸Šä¸‹è¾¹ç¼˜
        int cl = 0, ch = matrix[0].size()-1; //è®°å½•å¾…æ‰“å°çš„çŸ©é˜µå·¦å³è¾¹ç¼˜
        while(1){
            for(int i=cl; i<=ch; i++) res.push_back(matrix[rl][i]);//ä»å·¦å¾€å³
            if(++rl > rh) break; //è‹¥è¶…å‡ºè¾¹ç•Œï¼Œé€€å‡º
            for(int i=rl; i<=rh; i++) res.push_back(matrix[i][ch]);//ä»ä¸Šå¾€ä¸‹
            if(--ch < cl) break;
            for(int i=ch; i>=cl; i--) res.push_back(matrix[rh][i]);//ä»å³å¾€å·¦
            if(--rh < rl) break;
            for(int i=rh; i>=rl; i--) res.push_back(matrix[i][cl]);//ä»ä¸‹å¾€ä¸Š
            if(++cl > ch) break;
        }
        return res;
    }
~~~



**3ã€æ”¹è¿›ä¸€ä¸‹ç¬¬äºŒç§å†™æ³•ï¼Œå¿«ä¸Šä¸å°‘**

æ‰§è¡Œç”¨æ—¶ï¼š12 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†98.41%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š10.3 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
vector<int> spiralOrder(vector<vector<int>>& matrix) {
	vector <int> res;
	if (matrix.empty()) return res;
	int top = 0, bottom = matrix.size() - 1; //è®°å½•å¾…æ‰“å°çš„çŸ©é˜µä¸Šä¸‹è¾¹ç¼˜
	int left = 0, right = matrix[0].size() - 1; //è®°å½•å¾…æ‰“å°çš„çŸ©é˜µå·¦å³è¾¹ç¼˜
	while (1) {
		for (int i = left; i <= right; ++i) res.push_back(matrix[top][i]);//ä»å·¦å¾€å³
		if (++top > bottom) break; //è‹¥è¶…å‡ºè¾¹ç•Œï¼Œé€€å‡º

		for (int i = top; i <= bottom; ++i) res.push_back(matrix[i][right]);//ä»ä¸Šå¾€ä¸‹
		if (--right < left) break;

		for (int i = right; i >= left; --i) res.push_back(matrix[bottom][i]);//ä»å³å¾€å·¦
		if (--bottom < top) break;

		for (int i = bottom; i >= top; --i) res.push_back(matrix[i][left]);//ä»ä¸‹å¾€ä¸Š
		if (++left > right) break;
	}
	return res;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€æœ€å¿«çš„åšæ³•ï¼Œæ³¨æ„ä¸­é—´çš„åˆ¤æ–­æ¡ä»¶ä¸å¯å°‘**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š496k

~~~cpp
 vector<int> printMatrix(vector<vector<int> > matrix) {

if (matrix.size() == 0 || matrix[0].size() == 0) return vector<int>();
	int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size() - 1;
	vector<int> result;
	while (left <= right && top <= bottom) {
		for (int i = left; i <= right; ++i)
		{
			//cout << matrix[top][i] << " ";
			result.push_back(matrix[top][i]);

		}
		if (++top > bottom) break;
		for (int i = top; i <= bottom; ++i)
		{
			//cout << matrix[i][right] << " ";
			result.push_back(matrix[i][right]);

		}
		if (--right < left) break;
		for (int i = right ; i >= left; --i) {
			//cout << matrix[bottom][i] << " ";
			result.push_back(matrix[bottom][i]);
		}
		if (--bottom < top) break;
		for (int i = bottom; i >= top; --i) {
			//cout << matrix[i][left] << " ";
			result.push_back(matrix[i][left]);
		}
		if (++left > right) break;
	}

	return result;
    }
~~~

<p id = "åŒ…å«minå‡½æ•°çš„æ ˆ"></p>

**No20ã€åŒ…å«minå‡½æ•°çš„æ ˆ**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&&tqId=11173&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

å®šä¹‰æ ˆçš„æ•°æ®ç»“æ„ï¼Œè¯·åœ¨è¯¥ç±»å‹ä¸­å®ç°ä¸€ä¸ªèƒ½å¤Ÿå¾—åˆ°æ ˆä¸­æ‰€å«æœ€å°å…ƒç´ çš„minå‡½æ•°ï¼ˆæ—¶é—´å¤æ‚åº¦åº”ä¸ºOï¼ˆ1ï¼‰ï¼‰ã€‚

**1ã€ä¸€æ¬¡è§£å†³ ä»¥å‰åšè¿‡**

~~~cpp
class Solution {
public:
    void push(int value) {
        if(st.size()==0&&minSt.size()==0) {
            st.push(value);
            minSt.push(value);
        }else{
            st.push(value);
            if(value<=minSt.top()){
                minSt.push(value);
            }
            else{
                minSt.push(minSt.top());
            }
            
        }
        //st.push(value); #è¿™é‡Œåº”è¯¥åˆ é™¤
    }
    void pop() {
        st.pop();
        minSt.pop();
    }
    int top() {
        return st.top();
    }
    int min() {
        return minSt.top();
    }
    stack<int> minSt;
    stack<int> st;
};
~~~

>æ„Ÿè°¢å¾®ä¿¡å¥½å‹â€œPikachutsâ€æŒ‡å‡ºç¬”è¯¯ï¼Œç°åœ¨æ”¹æ­£ï¼Œå¤šè°¢ã€‚-2021.06.11

**äºŒåˆ·ï¼š**

**1ã€åªä¸€ä¸ªæ ˆæ¥åšï¼Œç»´æŒä¸€ä¸ªæœ€å°å€¼ï¼Œè¿™ç§æ–¹æ³•æ¯«æ— ç–‘é—®æ˜¯æ›´å¥½ä¸€ç‚¹çš„**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š504k

æ³¨æ„å‡½æ•°é‡åé—®é¢˜

~~~cpp
class Solution {
    int minNum = INT_MAX;
    stack<int> st;
public:
    void push(int value) {
        minNum = std::min(value, minNum);//æ³¨æ„å½“å‰ç±»ä¸­ä¹Ÿæœ‰ä¸€ä¸ªminå‡½æ•°ï¼Œ
        //æ‰€ä»¥æˆ‘ä»¬éœ€è¦æ˜ç¡®æ­¤æ—¶çš„minå‡½æ•°æ˜¯å“ªä¸ªå‡½æ•°
        st.push(minNum);
        st.push(value);
        
    }
    void pop() {
        st.pop();//popæ‰å½“å‰å€¼
        st.pop();//popæ‰å½“å‰æœ€å°å€¼
        int temp = st.top();
        st.pop();
        if(minNum == st.top()){
            st.push(temp);
        }else{
            minNum = st.top();
            st.pop();
            st.push(minNum);
            st.push(temp);
        }

       
    }
    int top() {
        return st.top();
    }
    int min() {
        return minNum;
    }
};
~~~

<p id = "æ ˆçš„å‹å…¥å¼¹å‡ºåºåˆ—"></p>

**No21ã€æ ˆçš„å‹å…¥å¼¹å‡ºåºåˆ—**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&&tqId=11174&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**
è¾“å…¥ä¸¤ä¸ªæ•´æ•°åºåˆ—ï¼Œç¬¬ä¸€ä¸ªåºåˆ—è¡¨ç¤ºæ ˆçš„å‹å…¥é¡ºåºï¼Œè¯·åˆ¤æ–­ç¬¬äºŒä¸ªåºåˆ—æ˜¯å¦å¯èƒ½ä¸ºè¯¥æ ˆçš„å¼¹å‡ºé¡ºåºã€‚å‡è®¾å‹å…¥æ ˆçš„æ‰€æœ‰æ•°å­—å‡ä¸ç›¸ç­‰ã€‚ä¾‹å¦‚åºåˆ—1,2,3,4,5æ˜¯æŸæ ˆçš„å‹å…¥é¡ºåºï¼Œåºåˆ—4,5,3,2,1æ˜¯è¯¥å‹æ ˆåºåˆ—å¯¹åº”çš„ä¸€ä¸ªå¼¹å‡ºåºåˆ—ï¼Œä½†4,3,5,1,2å°±ä¸å¯èƒ½æ˜¯è¯¥å‹æ ˆåºåˆ—çš„å¼¹å‡ºåºåˆ—ã€‚ï¼ˆæ³¨æ„ï¼šè¿™ä¸¤ä¸ªåºåˆ—çš„é•¿åº¦æ˜¯ç›¸ç­‰çš„ï¼‰

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
[1,2,3,4,5],[4,3,5,1,2]
~~~
**è¿”å›å€¼**

~~~
false
~~~



**1ã€æƒ³å²”äº†ï¼Œç”¨vector**

~~~cpp
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {

       if(pushV.size() == 0) return false;
        vector<int> v;
        for(int i = 0,j = 0 ;i < pushV.size();){
            v.push_back(pushV[i++]);
            while(j < popV.size() && v.back() == popV[j]){
                v.pop_back();
                j++;
            }      
            }
            return v.empty();
    }
~~~



**2ã€å€ŸåŠ©æ ˆ**

~~~cpp
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {

if (pushV.empty() || popV.empty() || pushV.size() != popV.size())
	return false;
	stack<int> s;
	int j = 0;
	for (int i = 0; i < pushV.size(); ++i) {
		s.push(pushV[i]);
		while (!s.empty() && s.top() == popV[j]) {
			s.pop();
			++j;
		}
	}
	if (s.empty())
		return true;
	return false;
    }
~~~



**äºŒåˆ·ï¼š**

**1ã€æŒºå®¹æ˜“çš„ï¼Œå¯ä»¥å†çœ‹ä¸€ä¸‹**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š508k

~~~cpp
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
	int len = pushV.size();
	int pushIndex = 0, popIndex = 0;
	stack<int>st;
	while (pushIndex < len && popIndex < len) {
		if (pushV[pushIndex] != popV[popIndex]) {
			st.push(pushV[pushIndex++]);
		}
		else {
			popIndex++;
			pushIndex++;
			while (!st.empty() && popIndex<len && st.top() == popV[popIndex]) {
				st.pop();
				popIndex++;
			}
		}
	}

	while (popIndex < len && st.top() == popV[popIndex]) {
		st.pop();
		popIndex++;
	}
	return popIndex == len && st.empty();
    }
~~~



**2ã€ç²¾ç»ƒä¸€ä¸‹ä»£ç **

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š380k

~~~cpp
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
	if(pushV.size() == 0 || popV.size() == 0 || pushV.size() != popV.size()) return false;
    int len = pushV.size();
	int popIndex = 0;
	stack<int>st;
    for(int i = 0; i < len; ++i){
        st.push(pushV[i]);
        while (popIndex < len && !st.empty() &&st.top() == popV[popIndex]) {
			st.pop();
			popIndex++;
		}        
    }
	return st.empty();
    }
~~~

<p id = "ä»ä¸Šå¾€ä¸‹æ‰“å°äºŒå‰æ ‘"></p>

**No22ã€ä»ä¸Šå¾€ä¸‹æ‰“å°äºŒå‰æ ‘**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank"> [ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&&tqId=11175&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ä»ä¸Šå¾€ä¸‹æ‰“å°å‡ºäºŒå‰æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ï¼ŒåŒå±‚èŠ‚ç‚¹ä»å·¦è‡³å³æ‰“å°ã€‚ 

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
{5,4,#,3,#,2,#,1}
~~~
**è¿”å›å€¼**

~~~
[5,4,3,2,1]
~~~



**1ã€è¿­ä»£åšæ³•ï¼Œå€ŸåŠ©é˜Ÿåˆ—ï¼Œæ¯”è¾ƒç®€å•**

~~~cpp
    vector<int> PrintFromTopToBottom(TreeNode* root) {

    vector<int> result;
	if (root == nullptr) return result;
	queue<TreeNode*>  q;
	q.push(root);
	TreeNode* node;
	while (!q.empty()) {
		node = .front();
		result.push_back(node->val);
		if (node->left) q.push(node->left);
		if (node->right) q.push(node->right);
		q.pop();
	}
    return result;
    }
~~~



**äºŒåˆ·ï¼š**

**1ã€å€ŸåŠ©é˜Ÿåˆ—æ¥åšï¼Œç®€å•**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š528k

~~~cpp
    vector<int> PrintFromTopToBottom(TreeNode* root) {
        if(root == nullptr) return vector<int>();
        queue<TreeNode*>q;
        q.push(root);
        TreeNode *node = nullptr;
        vector<int> result;
        while(!q.empty()){
             
            node = q.front();
            q.pop();
            result.push_back(node->val);
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
        
        return result;
    }
~~~

<p id = "äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—"></p>

**No23ã€äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&&tqId=11176&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ä»ä¸Šå¾€ä¸‹æ‰“å°å‡ºäºŒå‰æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ï¼ŒåŒå±‚èŠ‚ç‚¹ä»å·¦è‡³å³æ‰“å°ã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
{5,4,#,3,#,2,#,1}
~~~
**è¿”å›å€¼**

~~~
[5,4,3,2,1]
~~~



**1ã€é€’å½’å†™æ³•ï¼Œæ ‘ä¸»è¦çš„åšæ³•å°±æ˜¯é€’å½’**

~~~cpp
bool VerifySquenceOfBST(vector<int> sequence) {
	if (sequence.empty())  return false;
	if (sequence.size() == 1) return true;
	return VerifySquenceOfBSTCore(sequence, 0, sequence.size()-1);
}

bool VerifySquenceOfBSTCore(vector<int>& sequence, int start, int end) {
	if (start >= end) return true;
	int low = start;
	while (low < end && sequence[low] < sequence[end])  ++low;

	for (int i = low; i < end; ++i) {
		if (sequence[i] <= sequence[end]) return false;
	}

	return  VerifySquenceOfBSTCore(sequence, start,low-1) &&
		VerifySquenceOfBSTCore(sequence, low,end-1);
}

~~~



**äºŒåˆ·ï¼šä¾ç„¶æ²¡æœ‰æ€è·¯ï¼Œå€¼å¾—å†çœ‹ä¸€é**

1ã€å¹¶æ²¡æœ‰æƒ³è±¡ä¸­çš„éš¾ï¼Œä¸‹æ¬¡åº”è¯¥ä»”ç»†æƒ³ä¸€æƒ³çš„

~~~cpp
    bool VerifySquenceOfBSTCore(vector<int>&sequence,int low,int high){
        if(low >= high) return true;
        int start = low;
        while(start < high && sequence[start] < sequence[high]) ++start;//äºŒå‰æœç´¢æ ‘ï¼Œå·¦å³æ ¹ï¼Œå·¦å­æ ‘å…¨éƒ¨å°äºæ ¹
        //å³å­æ ‘å…¨éƒ¨æ‰“å¤§äºæ ¹ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºæ ¹çš„å…ƒç´ ï¼Œé‚£ä¹ˆåœ¨ä»–ä¹‹å‰éƒ½æ˜¯å·¦å­æ ‘ï¼Œä¹‹åéƒ½æ˜¯å³å­æ ‘
        for(int i = start;i < high; ++i)
            if(sequence[i] <= sequence[high]) return false; //å³å­æ ‘å¿…é¡»å…¨éƒ¨å¤§äºæ ¹ï¼Œå¦åˆ™å°±æ˜¯å‡
        return VerifySquenceOfBSTCore(sequence, low, start-1) //åˆ¤æ–­å½“å‰èŠ‚ç‚¹çš„å…¶å·¦å­æ ‘
            && VerifySquenceOfBSTCore(sequence, start, high-1);//åˆ¤æ–­å½“å‰èŠ‚ç‚¹çš„å…¶å³å­æ ‘

    }
    bool VerifySquenceOfBST(vector<int> sequence) {

        if(sequence.empty()) return false;//ä¸ºç©ºï¼Œåˆ™ä¸ºå‡
        if(sequence.size() == 1) return true;//åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œä¸ºçœŸ
        
        return VerifySquenceOfBSTCore(sequence,0,sequence.size()-1);
    }
~~~

<p id = "äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„"></p>

**No24ã€äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank"> [ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&&tqId=11177&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸€é¢—äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹å’Œä¸€ä¸ªæ•´æ•°ï¼ŒæŒ‰å­—å…¸åºæ‰“å°å‡ºäºŒå‰æ ‘ä¸­ç»“ç‚¹å€¼çš„å’Œä¸ºè¾“å…¥æ•´æ•°çš„æ‰€æœ‰è·¯å¾„ã€‚è·¯å¾„å®šä¹‰ä¸ºä»æ ‘çš„æ ¹ç»“ç‚¹å¼€å§‹å¾€ä¸‹ä¸€ç›´åˆ°å¶ç»“ç‚¹æ‰€ç»è¿‡çš„ç»“ç‚¹å½¢æˆä¸€æ¡è·¯å¾„ã€‚ 

**ç¤ºä¾‹1**

**è¾“å…¥**

```
{10,5,12,4,7},22
```

**è¿”å›å€¼**

```
[[10,5,7],[10,12]]
```

**ç¤ºä¾‹2**

**è¾“å…¥**

```
{10,5,12,4,7},15
```

**è¿”å›å€¼**

```
[]
```

**1ã€å¸¦æœ‰å›æº¯æ€§è´¨çš„è§£æ³•**

~~~cpp
void FindPathCore(vector<vector<int>>&result, vector<int>  &temp, TreeNode* root, int sum) {
	if (root == nullptr) return;
	temp.push_back(root->val);
	if (root->left == nullptr && root->left == nullptr && sum == root->val) {
		result.push_back(temp);
	}
	else { 
		if (root->left) {
			FindPathCore(result, temp, root->left, sum-root->val);
		}
		if (root->right) {
			FindPathCore(result, temp, root->right, sum - root->val);
		}
	}
	temp.pop_back();//èµ°åˆ°è¿™é‡Œäº†ï¼Œè¯´æ˜å½“å‰èŠ‚ç‚¹ä¸æ»¡è¶³è¦æ±‚ï¼Œpopæ‰ï¼Œè¿”å›å…¶çˆ¶äº²èŠ‚ç‚¹

}
vector<vector<int> > FindPath(TreeNode* root, int expectNumber) {
	vector<vector<int>>  result;
	vector<int>  temp;
	FindPathCore(result, temp, root, expectNumber);
	return result;
}
~~~



ä½†è¿™é¢˜æ˜¯è¦æ±‚æŒ‰ç…§å­—å…¸åºè¿”å›ç»“æœçš„ï¼Œæ‰€ä»¥æœ€ååº”è¯¥æ˜¯å°†resultè¿›è¡Œæ’åºï¼Œä¼˜å…ˆè¿”å›é‚£äº›é•¿åº¦è¾ƒé•¿çš„è·¯å¾„ã€‚æ‰€ä»¥æœ€ååº”è¯¥å†åˆ¤æ–­ä¸€ä¸‹ï¼Œå¯ä»¥ç”¨lambdaè¡¨è¾¾å¼æˆ–è€…é‡è½½ä¸€ä¸ª ï¼ˆï¼‰ ä¹Ÿå¯ä»¥

~~~cpp
void FindPathCore(vector<vector<int>>&result, vector<int>  temp, TreeNode* root, int sum) {
	if (root == nullptr) return;
	temp.push_back(root->val);
	if (root->left == nullptr && root->left == nullptr && sum == root->val) {
		result.push_back(temp);
	}
	else { 
		if (root->left) {
			FindPathCore(result, temp, root->left, sum-root->val);
		}
		if (root->right) {
			FindPathCore(result, temp, root->right, sum - root->val);
		}
	}
	temp.pop_back();//èµ°åˆ°è¿™é‡Œäº†ï¼Œè¯´æ˜å½“å‰èŠ‚ç‚¹ä¸æ»¡è¶³è¦æ±‚ï¼Œpopæ‰ï¼Œè¿”å›å…¶çˆ¶äº²èŠ‚ç‚¹

}
vector<vector<int> > FindPath(TreeNode* root, int expectNumber) {
	vector<vector<int>>  result;
	vector<int>  temp;
	FindPathCore(result, temp, root, expectNumber);
    sort(result.begin(),result.end(),[&](vector<int> v1,vector<int>v2){ return v1.size()>v2.size();});
	return result;
}
~~~

æˆ–è€…é‡è½½ ï¼ˆï¼‰ 

~~~cpp
struct compare {

	bool operator()(vector<int>& left, vector<int>& right) {
		return left.size() > right.size();
	}

};

void FindPathCore(vector<vector<int>>&result, vector<int>  temp, TreeNode* root, int sum) {
	if (root == nullptr) return;
	temp.push_back(root->val);
	if (root->left == nullptr && root->left == nullptr && sum == root->val) {
		result.push_back(temp);
	}
	else { 
		if (root->left) {
			FindPathCore(result, temp, root->left, sum-root->val);
		}
		if (root->right) {
			FindPathCore(result, temp, root->right, sum - root->val);
		}
	}
	temp.pop_back();//èµ°åˆ°è¿™é‡Œäº†ï¼Œè¯´æ˜å½“å‰èŠ‚ç‚¹ä¸æ»¡è¶³è¦æ±‚ï¼Œpopæ‰ï¼Œè¿”å›å…¶çˆ¶äº²èŠ‚ç‚¹

}
vector<vector<int> > FindPath(TreeNode* root, int expectNumber) {
	vector<vector<int>>  result;
	vector<int>  temp;
	FindPathCore(result, temp, root, expectNumber);
    sort(result.begin(),result.end(),compare());
	return result;
}
~~~



**äºŒåˆ·ï¼š**

**äºŒåˆ·ä¹Ÿä¸å¤ªä¼šï¼Œå“­äº†ï¼Œä»”ç»†æƒ³æƒ³å…¶å®ä¹Ÿä¸å¤ªéš¾ï¼Œå“è¿˜æ˜¯å¤ªèœäº†**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š484k

~~~cpp
void FindPathCore(TreeNode*root,vector<vector<int>>&result,vector<int>temp,int sumNum){//è¿™ä¸€è¿™é‡Œ tempæ˜¯å¼•ç”¨æ–¹å¼ä¼ å€¼ï¼Œæ‰€ä»¥å½“å‰èŠ‚ç‚¹ä¸ç¬¦åˆï¼Œè¿˜è¦åˆ é™¤æ‰
        if(root == nullptr) return;
        temp.push_back(root->val);
        if(root->left == nullptr && root->right == nullptr &&  sumNum == root->val)
        {
            result.push_back(temp);
        }
        else{
            if(root->left)  
                FindPathCore(root->left,result,temp,sumNum-root->val);
            if(root->right)  
                FindPathCore(root->right,result,temp,sumNum-root->val);
            
        }
        temp.pop_back();//å¦‚æœä¸æ˜¯å¼•ç”¨æ–¹å¼ï¼Œè€Œæ˜¯å€¼ä¼ é€’ï¼Œè¿™ä¸€æ­¥æ˜¯å¯ä»¥åˆ æ‰çš„ï¼Œæ˜¯å¼•ç”¨æ–¹å¼å°±å¿…é¡»è¦popæ‰

    }
    vector<vector<int> > FindPath(TreeNode* root,int expectNumber) {
        if(root == nullptr) return vector<vector<int>>();
        
        vector<vector<int>> result;
        vector<int>temp;
        FindPathCore(root,result,temp,expectNumber);
        
        sort(result.begin(),result.end(),[](const vector<int>&a,const vector<int>&b){ return a.size()>b.size();});
        return result;

    }
~~~

<p id = "å¤æ‚é“¾è¡¨çš„å¤åˆ¶"></p>

**No25ã€å¤æ‚é“¾è¡¨çš„å¤åˆ¶**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&&tqId=11178&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**
è¾“å…¥ä¸€ä¸ªå¤æ‚é“¾è¡¨ï¼ˆæ¯ä¸ªèŠ‚ç‚¹ä¸­æœ‰èŠ‚ç‚¹å€¼ï¼Œä»¥åŠä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦ä¸€ä¸ªç‰¹æ®ŠæŒ‡é’ˆrandomæŒ‡å‘ä¸€ä¸ªéšæœºèŠ‚ç‚¹ï¼‰ï¼Œè¯·å¯¹æ­¤é“¾è¡¨è¿›è¡Œæ·±æ‹·è´ï¼Œå¹¶è¿”å›æ‹·è´åçš„å¤´ç»“ç‚¹ã€‚ï¼ˆæ³¨æ„ï¼Œè¾“å‡ºç»“æœä¸­è¯·ä¸è¦è¿”å›å‚æ•°ä¸­çš„èŠ‚ç‚¹å¼•ç”¨ï¼Œå¦åˆ™åˆ¤é¢˜ç¨‹åºä¼šç›´æ¥è¿”å›ç©ºï¼‰ 

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
{10,5,12,4,7},22
~~~
**è¿”å›å€¼**

~~~
[[10,5,7],[10,12]]
~~~
**ç¤ºä¾‹2**
**è¾“å…¥**

~~~
{10,5,12,4,7},15
~~~
**è¿”å›å€¼**

~~~
[]
~~~



**1ã€ç¬¬ä¸€ç§æ–¹æ³•ï¼Œåœ¨èŠ‚ç‚¹åå¤åˆ¶ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç„¶åå†åˆ†ç¦»å¼€è¿™æ–¹æ³•è¶…çº§æ£’ï¼Œå¤ªéº»çƒ¦äº†ï¼Œä¸å»ºè®®ç”¨è¿™ç§æ–¹æ³•**

~~~cpp
/*
struct RandomListNode {
    int label;
    struct RandomListNode *next, *random;
    RandomListNode(int x) :
            label(x), next(NULL), random(NULL) {
    }
};
*/
class Solution {
public:

//å¤åˆ¶åŸå§‹é“¾è¡¨çš„ä»»ä¸€èŠ‚ç‚¹Nå¹¶åˆ›å»ºæ–°èŠ‚ç‚¹N'ï¼Œå†æŠŠN'é“¾æ¥åˆ°Nçš„åè¾¹
void CloneNodes(RandomListNode* pHead)
{
	RandomListNode* pNode = pHead;
	while (pNode != nullptr)
	{
		RandomListNode* pCloned = new RandomListNode(pNode->label);
		pCloned->next = pNode->next;
		pNode->next = pCloned;
		pNode = pCloned->next;
	}
}
//å¦‚æœåŸå§‹é“¾è¡¨ä¸Šçš„èŠ‚ç‚¹Nçš„randomæŒ‡å‘Sï¼Œåˆ™å¯¹åº”çš„å¤åˆ¶èŠ‚ç‚¹N'çš„randomæŒ‡å‘Sçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹S'
void ConnectRandomNodes(RandomListNode* pHead)
{
	RandomListNode* pNode = pHead;
	while (pNode != nullptr)
	{
		RandomListNode* pCloned = pNode->next;
		if (pNode->random != nullptr)
			pCloned->random = pNode->random->next;
		pNode = pCloned->next;
	}
}
//æŠŠå¾—åˆ°çš„é“¾è¡¨æ‹†æˆä¸¤ä¸ªé“¾è¡¨ï¼Œå¥‡æ•°ä½ç½®ä¸Šçš„ç»“ç‚¹ç»„æˆåŸå§‹é“¾è¡¨ï¼Œå¶æ•°ä½ç½®ä¸Šçš„ç»“ç‚¹ç»„æˆå¤åˆ¶å‡ºæ¥çš„é“¾è¡¨
RandomListNode* ReConnectNodes(RandomListNode* pHead)
{
	RandomListNode* pNode = pHead;
	RandomListNode* pClonedHead = nullptr;
	RandomListNode* pClonedNode = nullptr;

	//åˆå§‹åŒ–
	if (pNode != nullptr)
	{
		pClonedHead = pNode->next;
		pClonedNode = pNode->next;
		pNode->next = pClonedNode->next;
		pNode = pNode->next;

	}
	//å¾ªç¯
	while (pNode != nullptr)
	{
		pClonedNode->next = pNode->next;
		pClonedNode = pClonedNode->next;
		pNode->next = pClonedNode->next;
		pNode = pNode->next;
	}

	return pClonedHead;
}
//ä¸‰æ­¥åˆä¸€
RandomListNode* Clone(RandomListNode* pHead)
{
	CloneNodes(pHead);
	ConnectRandomNodes(pHead);

	return ReConnectNodes(pHead);
}
};
~~~



**è‡ªå·±åœ¨åŠ›æ‰£ä¸Šå¤ç°ç¬¬ä¸€ç§åšæ³•ï¼Œæœ‰å¾ˆå¤šè¦æ³¨æ„çš„åœ°æ–¹**

https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/

æ‰§è¡Œç”¨æ—¶ï¼š24 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†21.10%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š11.1 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};

class Solution {
public:

	void copyList(Node* head) {
		Node* node = head;
		while (node != nullptr) {
			Node* temp = new Node(node->val);
			temp->next = node->next;
			node->next = temp;
			node = temp->next;
		}
	}
	void connectRandomNodeList(Node* head) {
		Node* node = head;
		Node* copyNode = head->next;
		while (node != nullptr) {
			if (node->random != nullptr) //æ¯å½“ä½ è¦è¿›è¡Œèµ‹å€¼çš„æ—¶å€™éƒ½è¦æ³¨æ„è¿›è¡Œéç©ºåˆ¤æ–­
				copyNode->random = node->random->next;
			node = copyNode->next;
			if (node != nullptr) //æ¯å½“ä½ è¦è¿›è¡Œèµ‹å€¼çš„æ—¶å€™éƒ½è¦æ³¨æ„è¿›è¡Œéç©ºåˆ¤æ–­
				copyNode = node->next;
		}
	}
	Node* reCopyList(Node* head) {
		Node* node = head;
		Node* copyNode = head->next;
		Node* copyNodeHead = head->next;
		while (node != nullptr) {
			node->next = copyNode->next;
			node = node->next;
			if (node != nullptr)//æ¯å½“ä½ è¦è¿›è¡Œèµ‹å€¼çš„æ—¶å€™éƒ½è¦æ³¨æ„è¿›è¡Œéç©ºåˆ¤æ–­
				copyNode->next = node->next;
			copyNode = copyNode->next;
		}

		return copyNodeHead;
	}
	Node* copyRandomList(Node* head) {

		if (head == nullptr) return nullptr;
		copyList(head);
		connectRandomNodeList(head);
		return reCopyList(head);
	}
};
~~~



**2ã€å“ˆå¸Œè¡¨çš„åšæ³•ï¼Œå…¶å®æ›´ç®€å•ä¸€ä¸‹å•Š**

~~~cpp
RandomListNode* Clone(RandomListNode* pHead)
{
	if (pHead == nullptr)
	{
		return nullptr;
	}

	std::unordered_map<RandomListNode*, RandomListNode*> hash_map;

	for (RandomListNode* p = pHead; p != nullptr; p = p->next)
	{
		hash_map[p] = new RandomListNode(p->label);
	}

	for (RandomListNode* p = pHead; p != nullptr; p = p->next)
	{
		hash_map[p]->next = hash_map[p->next];//è¿™é‡Œè¦æ³¨æ„æ˜¯ unmp[p->next] åƒä¸‡æ³¨æ„ï¼Œå¥½å¥½æƒ³æƒ³
		hash_map[p]->random = hash_map[p->random];//ä¸‹åŒ
	}

	return hash_map[pHead];
}

~~~



**åœ¨åŠ›æ‰£ä¸Šå¤ç°äº†ä¸€é**

æ‰§è¡Œç”¨æ—¶ï¼š20 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†49.48%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š11.4 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
	Node* copyRandomList(Node* head) {

		if (head == nullptr) return nullptr;
		unordered_map<Node*, Node*> unmp;
		for (Node* p = head; p != nullptr;p=p->next)
		{
			unmp[p] = new Node(p->val);
		}
		for (Node* p = head; p != nullptr; p = p->next)
		{
			unmp[p]->next = unmp[p->next];//è¿™é‡Œè¦æ³¨æ„æ˜¯ unmp[p->next] åƒä¸‡æ³¨æ„ï¼Œå¥½å¥½æƒ³æƒ³
			unmp[p]->random = unmp[p->random];//ä¸‹åŒ
		}

		return unmp[head];
	}
~~~



**3ã€å“ˆå¸Œè¡¨çš„é€’å½’å†™æ³•**

~~~cpp
struct RandomListNode {
	int label;
	struct RandomListNode* next, * random;
	RandomListNode(int x) :
		label(x), next(NULL), random(NULL) {
	}
};


class Solution {
public:
	unordered_map<RandomListNode*, RandomListNode*> unmp;
	RandomListNode* Clone(RandomListNode* pHead)
	{
		if (pHead == NULL) return NULL;
		RandomListNode* head = new RandomListNode(pHead->label);
		unmp[pHead] = head;
		head->next = Clone(pHead->next);  //åœ¨è¿™é‡Œé€’å½’æ˜¯å…³é”®ï¼Œä¿è¯æ‰€æœ‰èŠ‚ç‚¹éƒ½å·²ç”Ÿæˆï¼Œæ”¾å…¥map
		head->random = NULL;
		if (pHead->random!=nullptr) head->random = unmp[pHead->random];   //æŸ¥æ‰¾mapä¸­å¯¹åº”èŠ‚ç‚¹
		return head;
	}
};
~~~



**åŠ›æ‰£ä¸Šå¤ç°åšæ³•**

æ‰§è¡Œç”¨æ—¶ï¼š24 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†21.10%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š11.5 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};

class Solution {
public:

    unordered_map<Node*, Node*> unmp;
	Node* copyRandomList(Node* head) {

		if (head == NULL) return NULL;
		Node* newHead = new Node(head->val);
		unmp[head] = newHead;
		newHead->next = copyRandomList(head->next);  //åœ¨è¿™é‡Œé€’å½’æ˜¯å…³é”®ï¼Œä¿è¯æ‰€æœ‰èŠ‚ç‚¹éƒ½å·²ç”Ÿæˆï¼Œæ”¾å…¥map
		newHead->random = NULL;
		if (head->random != nullptr) newHead->random = unmp[head->random];   //æŸ¥æ‰¾mapä¸­å¯¹åº”èŠ‚ç‚¹
		return newHead;
	}
};
~~~



**äºŒåˆ·ï¼š**

**1ã€å“ˆå¸Œè¡¨é€’å½’å†™æ³•**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š520k

~~~cpp
class Solution {
public:

  //å…³é”®æ˜¯ä¿å­˜ä½æ˜ å°„å…³ç³»ï¼Œå¯ä»¥è¯´æ˜¯å“ˆå¸Œè¡¨å’Œé“¾è¡¨çš„ç»„åˆå§
    unordered_map<RandomListNode*,RandomListNode*> unmp;
	RandomListNode* Clone(RandomListNode* pHead)
	{
        if(pHead == nullptr) return nullptr;
        RandomListNode* newHead = new RandomListNode(pHead->label);
        unmp[pHead] = newHead;//è¿™é‡Œéœ€è¦ä¿å­˜çš„æ˜¯ pHead -ã€‹ newHead çš„æ˜ å°„å…³ç³»,å¿…é¡»åœ¨è¿™é‡Œä¿å­˜
        newHead->next = Clone(pHead->next);//åˆ°è¿™ä¸€æ­¥ï¼Œå…¶å®æ‰€æœ‰çš„ç‚¹å·²ç»å…¨éƒ¨ç”Ÿæˆäº†
        newHead->random = nullptr;//å…¶å®é»˜è®¤å·²ç»æ˜¯nullpträº†ï¼Œæœ‰æ²¡æœ‰è¿™ä¸€æ­¥å…¶å®æ²¡ä»€ä¹ˆå…³ç³»
        if(pHead->random != nullptr)  newHead->random = unmp[pHead->random];//è¿™ä¸€æ­¥ï¼ŒçœŸçš„æ˜¯çµé­‚æ‰€åœ¨äº†
        return newHead;
	}
};
~~~



**2ã€å“ˆå¸Œè¡¨è¿­ä»£å†™æ³•**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š492k

~~~cpp
/*
struct RandomListNode {
    int label;
    struct RandomListNode *next, *random;
    RandomListNode(int x) :
            label(x), next(NULL), random(NULL) {
    }
};
*/
class Solution {
public:

  //å…³é”®æ˜¯ä¿å­˜ä½æ˜ å°„å…³ç³»ï¼Œå¯ä»¥è¯´æ˜¯å“ˆå¸Œè¡¨å’Œé“¾è¡¨çš„ç»„åˆå§
	RandomListNode* Clone(RandomListNode* pHead)
	{
        if(pHead == nullptr) return nullptr;
        unordered_map<RandomListNode*,RandomListNode*> unmp;
        for( auto p = pHead; p != nullptr; p=p->next){
            unmp[p] = new RandomListNode(p->label);
        }
        for( auto p = pHead; p != nullptr; p=p->next){
            
            unmp[p]->next = unmp[p->next];
            unmp[p]->random = unmp[p->random];
        }
        
        return unmp[pHead];
	}
};
~~~

<p id = "äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨"></p>

**No26ã€äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank"> [ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&&tqId=11179&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œå°†è¯¥äºŒå‰æœç´¢æ ‘è½¬æ¢æˆä¸€ä¸ªæ’åºçš„åŒå‘é“¾è¡¨ã€‚è¦æ±‚ä¸èƒ½åˆ›å»ºä»»ä½•æ–°çš„ç»“ç‚¹ï¼Œåªèƒ½è°ƒæ•´æ ‘ä¸­ç»“ç‚¹æŒ‡é’ˆçš„æŒ‡å‘ã€‚ 



**0ã€æœ€ç¬¨çš„ä¸€ç§å†™æ³•ï¼Œè¿™ä¹Ÿæ˜¯æœ€å®¹æ˜“ç†è§£çš„ä¸€ç§æ–¹æ³•äº†**

ä¸­åºéå†äºŒå‰æ ‘ï¼Œç„¶åç”¨ä¸€ä¸ªæ•°ç»„ç±»ä¿å­˜éå†çš„ç»“æœï¼Œè¿™æ ·åœ¨æ•°ç»„ä¸­èŠ‚ç‚¹å°±æŒ‰é¡ºåºä¿å­˜äº†ï¼Œç„¶åå†æ¥ä¿®æ”¹æŒ‡é’ˆï¼Œè™½ç„¶æ²¡æœ‰ä¸€ç‚¹æŠ€æœ¯å«é‡ï¼Œä½†æ˜¯æœ€åç«Ÿç„¶è¿˜é€šè¿‡äº† å“ˆå“ˆå“ˆã€‚ã€‚ã€‚

~~~cpp
TreeNode* Convert(TreeNode* pRootOfTree)
{
	if (pRootOfTree == NULL) return pRootOfTree;
	vector<TreeNode*> result;
	Convert(pRootOfTree, result);
	return Convert(result);
}

void Convert(TreeNode* node,vector<TreeNode*>&result) {
	if (node->left != nullptr)
		Convert(node->left, result);
	result.push_back(node);
	if (node->right != nullptr)
		Convert(node->right, result);
}

TreeNode* Convert(vector<TreeNode*>& result) {
	for (int i = 0; i < result.size()-1; ++i) {
		result[i]->right = result[i + 1];
		result[i+1]->left = result[i];
}
	return result[0];
}
~~~



**0-1å€ŸåŠ©æ ˆå’Œæ•°ç»„ç±»è¿›è¡Œæ•°æ®ä¿å­˜ï¼Œæœ€åä¿®æ”¹æŒ‡é’ˆæŒ‡å‘**

å…³é”®åœ¨äºäºŒå‰æ ‘çš„å±‚æ¬¡éå†è¿™ä¸€å—

~~~cpp
public:
   TreeNode* Convert(TreeNode* pRootOfTree)
{
	if (pRootOfTree == nullptr) return nullptr;
	vector<TreeNode*> result;
	stack<TreeNode*> s;

	// å½¢æˆä¸€ä¸ªä¸­åºéå†çš„ç»“æœï¼Œå¹¶æ·»åŠ æŒ‡é’ˆã€‚
	while (!s.empty() || pRootOfTree != nullptr) {
		if (pRootOfTree != nullptr) {
			s.push(pRootOfTree);
			pRootOfTree = pRootOfTree->left;
		}
		else {
			pRootOfTree = s.top();
			s.pop();
			result.push_back(pRootOfTree);
			pRootOfTree = pRootOfTree->right;
		}
	}
	// ä¿®æ”¹é“¾è¡¨æŒ‡é’ˆæŒ‡å‘ã€‚
	for (int i = 0; i < result.size() - 1; ++i) {
		result[i + 1]->left = result[i];
		result[i]->right = result[i+1];
	}
	return result[0];
}
~~~



**1ã€å€ŸåŠ©æ ˆè¿›è¡ŒèŠ‚ç‚¹ä¿å­˜ï¼Œå¾ˆå‰å®³çš„ä¸€ç§å†™æ³•**

æˆ‘æœå•¦ï¼Œé‡‡ç”¨çš„æ˜¯è·Ÿå‰‘æŒ‡offerä¸Šä¸€æ ·çš„å†™æ³•

1. æ˜ç¡®Convertå‡½æ•°çš„åŠŸèƒ½ã€‚
   è¾“å…¥ï¼šè¾“å…¥ä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚
   è¿‡ç¨‹ï¼šå°†å…¶è½¬åŒ–ä¸ºä¸€ä¸ªæœ‰åºçš„åŒå‘é“¾è¡¨ã€‚
   è¾“å‡ºï¼šè¿”å›è¯¥é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚
2. æ˜ç¡®æˆå‘˜å˜é‡pLastçš„åŠŸèƒ½ã€‚
   pLastç”¨äºè®°å½•å½“å‰é“¾è¡¨çš„æœ«å°¾èŠ‚ç‚¹ã€‚
3. æ˜ç¡®é€’å½’è¿‡ç¨‹ã€‚
   é€’å½’çš„è¿‡ç¨‹å°±ç›¸å½“äºæŒ‰ç…§ä¸­åºéå†ï¼Œå°†æ•´ä¸ªæ ‘åˆ†è§£æˆäº†æ— æ•°çš„å°æ ‘ï¼Œç„¶åå°†ä»–ä»¬åˆ†åˆ«è½¬åŒ–æˆäº†ä¸€å°æ®µä¸€å°æ®µçš„åŒå‘é“¾è¡¨ã€‚å†åˆ©ç”¨pLastè®°å½•æ€»çš„é“¾è¡¨çš„æœ«å°¾ï¼Œç„¶åå°†è¿™äº›å°æ®µé“¾è¡¨ä¸€ä¸ªæ¥ä¸€ä¸ªåœ°åŠ åˆ°æœ«å°¾ã€‚

~~~cpp
TreeNode* Convert(TreeNode* pRootOfTree)
{
    TreeNode* head = NULL, * pre = NULL;//head è¾“å‡ºï¼Œpreè®°å½•ä¸Šä¸€æ¬¡å‡ºæ ˆå€¼
	stack<TreeNode*> s;
	while (pRootOfTree || !s.empty())
	{
		while (pRootOfTree!=nullptr)
		{
			s.push(pRootOfTree);
			pRootOfTree = pRootOfTree->left;
		}
		if (!s.empty())
		{
			pRootOfTree = s.top();
			s.pop();
			if (pre != NULL)
			{
				pre->right = pRootOfTree;
				pRootOfTree->left = pre;
			}
			else//preä¸ºç©ºï¼Œè¡¨ç¤ºsç¬¬ä¸€æ¬¡å‡ºæ ˆï¼Œç¬¬ä¸€æ¬¡å‡ºæ ˆå€¼ä¸ºæœ€å·¦å€¼ï¼Œå³è¾“å‡ºå€¼
			{
				head = pRootOfTree;
			}
			pre = pRootOfTree;
			pRootOfTree = pRootOfTree->right;
		}
	}
	return head;
}
~~~



**2ã€å¤æ‚ä¸€ç‚¹çš„é€’å½’åšæ³•**

å…ˆå°†å·¦å­æ ‘å˜ä¸ºæœ‰åºçš„æ’åºé“¾è¡¨ï¼Œå†å°†å³å­æ ‘å˜ä¸ºæœ‰åºçš„é“¾è¡¨ï¼Œç„¶åå°†å½“å‰ç»“ç‚¹æ’å…¥åœ¨ä¸¤ä¸ªé“¾è¡¨ä¸­é—´å°±å¯ä»¥äº†ï¼Œéœ€è¦æ³¨æ„å·¦å­æ ‘å’Œå³å­æ ‘ä¸ºç©ºçš„æƒ…å†µ

~~~cpp
TreeNode* Convert(TreeNode* pRootOfTree)
    {
        if(pRootOfTree == NULL)
            return NULL;
          
        TreeNode* leftTree = Convert(pRootOfTree->left);    // å°†å·¦å­æ ‘å˜ä¸ºæ’åºé“¾è¡¨
        TreeNode*   rightTree = Convert(pRootOfTree->right);   // å°†å³å­æ ‘å˜ä¸ºæ’åºé“¾è¡¨
        TreeNode* tmp = leftTree;
        if(tmp != NULL)
        {
            while(tmp->right)
            {
                tmp = tmp->right;
            }
            tmp->right     = pRootOfTree;
        }
         
        pRootOfTree->left  = tmp;
        pRootOfTree->right =  rightTree;
        if(rightTree != NULL)
            rightTree->left  = pRootOfTree;
          
        return(leftTree == NULL ? pRootOfTree:leftTree);
    }
~~~



**3ã€ç®€å•é€’å½’åšæ³•ï¼Œç²¾ç®€ç‰ˆ**

~~~cpp
TreeNode* Convert(TreeNode* pRootOfTree)
    {
        if(pRootOfTree == NULL) return pRootOfTree;
        pRootOfTree = ConvertNode(pRootOfTree);
        while(pRootOfTree->left) pRootOfTree = pRootOfTree->left;
        return pRootOfTree;
    }
 
    TreeNode* ConvertNode(TreeNode* root)
    {
        if(root == NULL) return root;
        if(root->left)
        {
            TreeNode *left = ConvertNode(root->left);
            while(left->right) left = left->right;
            left->right = root;
            root->left = left;
        }
         
        if(root->right)
        {
            TreeNode *right = ConvertNode(root->right);
            while(right->left) right = right->left;
            right->left = root;
            root->right = right;
        }
        return root;
    }
~~~



**äºŒåˆ·ï¼š**

**1ã€å€ŸåŠ©stackå’Œvector**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š408k

~~~cpp
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        if(pRootOfTree == nullptr) return nullptr;
        stack<TreeNode*> st;
        vector<TreeNode*> result;
        while( !st.empty() || pRootOfTree != nullptr){
            if(pRootOfTree != nullptr){
                st.push(pRootOfTree);
                pRootOfTree = pRootOfTree->left;
                
            }
            else{
               pRootOfTree = st.top();
               st.pop();
               result.push_back(pRootOfTree);
                pRootOfTree = pRootOfTree->right;
            }
        }
        
        
       for(int i = 0; i < result.size()-1; ++i){
           
           result[i+1]->left = result[i];
           result[i]->right = result[i+1];
       }
        
        return result[0];
    }
~~~



**2ã€ä¾ç„¶æ˜¯æ ˆï¼Œä¸è¿‡èŠ‚çº¦äº†ä¸å°‘ç©ºé—´ï¼Œè®°è¿™ç§åšæ³•ï¼Œå¾ˆæ£’**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š484k

~~~cpp
 TreeNode* Convert(TreeNode* pRootOfTree)
    {
        if(pRootOfTree == nullptr) return nullptr;
        stack<TreeNode*> st;
        vector<TreeNode*> result;
        TreeNode* head = nullptr,*pre = nullptr;
        while( !st.empty() || pRootOfTree != nullptr){
            while(pRootOfTree != nullptr){
                st.push(pRootOfTree);
                pRootOfTree = pRootOfTree->left;
            }
            if( !st.empty()){
                pRootOfTree = st.top();
                st.pop();
              if(pre == nullptr){//è¡¨ç¤ºç¬¬ä¸€æ¬¡å‡ºæ ˆï¼Œä¸ºæœ€å·¦å€¼ï¼Œè®°å½•ä¸‹æœ€å°çš„å…ƒç´ 
                  head = pRootOfTree;
              }
              else{
                  pre->right = pRootOfTree;
                  pRootOfTree->left = pre;
               }
                
                pre = pRootOfTree;
                pRootOfTree = pRootOfTree->right;
            }
        }
        return head;
    }
~~~

<p id = "å­—ç¬¦ä¸²çš„æ’åˆ—"></p>

**No27ã€å­—ç¬¦ä¸²çš„æ’åˆ—**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&&tqId=11180&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸€ä¸ªå­—ç¬¦ä¸²,æŒ‰å­—å…¸åºæ‰“å°å‡ºè¯¥å­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ‰€æœ‰æ’åˆ—ã€‚ä¾‹å¦‚è¾“å…¥å­—ç¬¦ä¸²abc,åˆ™æ‰“å°å‡ºç”±å­—ç¬¦a,b,cæ‰€èƒ½æ’åˆ—å‡ºæ¥çš„æ‰€æœ‰å­—ç¬¦ä¸²abc,acb,bac,bca,cabå’Œcbaã€‚

**è¾“å…¥æè¿°:**

```
è¾“å…¥ä¸€ä¸ªå­—ç¬¦ä¸²,é•¿åº¦ä¸è¶…è¿‡9(å¯èƒ½æœ‰å­—ç¬¦é‡å¤),å­—ç¬¦åªåŒ…æ‹¬å¤§å°å†™å­—æ¯ã€‚
```

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
"ab"
~~~
**è¿”å›å€¼**

~~~
["ab","ba"]
~~~



**1ã€ä¸€ä¸ªå¾ˆå¥‡ç‰¹çš„å‡½æ•°next_permutation** 

è¿”å›å…¨æ’åˆ—ï¼Œä½¿ç”¨æ–¹æ³•å¦‚ä¸‹æ‰€ç¤ºï¼Œå¿…é¡»è¦è¿›è¡Œæ’åºæ‰å¯ä»¥ï¼š

æ‰§è¡Œç”¨æ—¶ï¼š52 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†91.01%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š17.9 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
    vector<string> permutation(string s) {

    if(s.size()==0) return vector<string>();
        
	vector<string> result;
	sort(s.begin(), s.end());
	do {
		result.push_back(s);
	} while (next_permutation(s.begin(),s.end()));

	return  result;
    }
~~~



~~~cpp
#include <stdio.h>
#include <algorithm>
using namespace std;
int main(){
    int n;
    while(scanf("%d",&n)&&n){
        int a[1000];
        for(int i=0;i<n;i++){
            scanf("%d",&a[i]);
        }
        sort(a,a+n);
        do{
            for(int i=0;i<n;i++)
                printf("%d ",a[i]);
            printf("\n");
        }while(next_permutation(a,a+n));
    }
    return 0;
}
~~~

ä¾‹å¦‚è¾“å…¥

```
3
1 0 2
```

å¦‚æœæœ‰sort()

è¾“å‡ºä¸º

```
0 1 2
0 2 1
1 0 2
1 2 0
2 0 1
2 1 0
```

è‹¥æ— 

åˆ™è¾“å‡ºä¸º

```
1 0 2
1 2 0
2 0 1
2 1 0
```

å‘ç°å‡½æ•°next_permutation()æ˜¯æŒ‰ç…§å­—å…¸åºäº§ç”Ÿæ’åˆ—çš„ï¼Œå¹¶ä¸”æ˜¯ä»æ•°ç»„ä¸­å½“å‰çš„å­—å…¸åºå¼€å§‹ä¾æ¬¡å¢å¤§ç›´è‡³åˆ°æœ€å¤§å­—å…¸åº



**2ã€DFS+å›æº¯ç®—æ³• è¿˜æ²¡æœ‰å®Œå…¨ç†è§£**

~~~cpp
class Solution {
public:
    vector<string>  result;
    void PermutationCore(string &s,int begin,int end){
        if(begin == end){
            result.push_back(s);
            return ;
        }
        unordered_map<int,int> visited;
        for(int i = begin; i<= end; ++i){
            if(visited[s[i]] == 1) continue;
            swap(s[i],s[begin]);
            PermutationCore(s,begin+1,end);
            swap(s[i],s[begin]);
            visited[s[i]] =1;

        }

    }
    
    vector<string> Permutation(string str) {
    if(str.size()==0) return vector<string>();
    
    PermutationCore(str,0,str.size()-1);
    sort(result.begin(),result.end());
	return  result;
    }
};
~~~



**äºŒåˆ·ï¼š**

**1ã€å¥½é¢˜ï¼Œä¸å¼€ç©ç¬‘ï¼Œæœ€åè¿˜è¦æ’åºï¼Œè¦æ±‚æ˜¯æŒ‰ç…§å­—å…¸åºè¾“å‡ºçš„**

~~~cpp
class Solution {
public:
    vector<string>  result;
    void PermutationCore(string &s,int begin,int end){
        if(begin == end){
            result.push_back(s);
            return ;
        }
        unordered_map<int,int> visited;
        for(int i = begin; i<= end; ++i){
            if(visited[s[i]] == 1) continue;
            swap(s[i],s[begin]);
            PermutationCore(s,begin+1,end);
            swap(s[i],s[begin]);
            visited[s[i]] =1;
 
        }
 
    }
     
    vector<string> Permutation(string str) {
    if(str.size()==0) return vector<string>();
     
    PermutationCore(str,0,str.size()-1);
    sort(result.begin(),result.end());
    return  result;
    }
};
~~~

<p id = "æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å­—"></p>

**No28ã€æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å­—**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&&tqId=11181&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

æ•°ç»„ä¸­æœ‰ä¸€ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°è¶…è¿‡æ•°ç»„é•¿åº¦çš„ä¸€åŠï¼Œè¯·æ‰¾å‡ºè¿™ä¸ªæ•°å­—ã€‚ä¾‹å¦‚è¾“å…¥ä¸€ä¸ªé•¿åº¦ä¸º9çš„æ•°ç»„{1,2,3,2,2,2,2,5,4}ã€‚ç”±äºæ•°å­—2åœ¨æ•°ç»„ä¸­å‡ºç°äº†5æ¬¡ï¼Œè¶…è¿‡æ•°ç»„é•¿åº¦çš„ä¸€åŠï¼Œå› æ­¤è¾“å‡º2ã€‚å¦‚æœä¸å­˜åœ¨åˆ™è¾“å‡º0ã€‚

**ç¤ºä¾‹1**



**è¾“å…¥**

~~~
[1,2,3,2,2,2,5,4,2]
~~~
**è¿”å›å€¼**

~~~
2
~~~



**1ã€å¸¸è§„åšæ³•ï¼Œå“ˆå¸Œè¡¨**

~~~cpp
int MoreThanHalfNum_Solution(vector<int> numbers) {
     
    unordered_map<int, int>unmp;
    int len = numbers.size();
    for (int i = 0; i < len; ++i) {
        unmp[numbers[i]]++;
        if (unmp[numbers[i]] > len / 2) return numbers[i];
    }
    return 0;
    }
~~~



**äºŒåˆ·ï¼š**

**1ã€æ‘©å°”æŠ•ç¥¨æ³•çš„å˜ç§ï¼Œä¸åŠ›æ‰£ä¸Š[å¤šæ•°å…ƒç´ ](https://leetcode-cn.com/problems/majority-element/)æ˜¯å·®ä¸å¤šçš„åšæ³•ï¼Œå¾ˆé«˜æ•ˆçš„ä¸€ç§åšæ³•**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š464k

~~~cpp
    int MoreThanHalfNum_Solution(vector<int> numbers) {
	//æ‘©å°”æŠ•ç¥¨æ³•ï¼Œæˆç«‹å‰æå°±æ˜¯æœ‰å‡ºç°è¶…è¿‡ä¸€åŠçš„å…ƒç´ ï¼Œæ‰€ä»¥æœ€åæˆ‘ä»¬éœ€è¦åˆ¤æ–­æ‰¾åˆ°çš„å…ƒç´ æ˜¯å¦å‡ºç°è¶…è¿‡ä¸€åŠäº†
	int cnt = 0, num = 0;
	for (int i = 0; i < numbers.size(); ++i) {
		if (cnt == 0) {
			num = numbers[i];
			cnt = 1;
		}
		else {
			num == numbers[i] ? cnt++ : cnt--;
		}

	}
	cnt = count(numbers.begin(), numbers.end(), num);
	return cnt > numbers.size() / 2 ? num : 0;
    }
~~~

<p id = "æœ€å°çš„Kä¸ªæ•°"></p>
**29ã€æœ€å°çš„Kä¸ªæ•°**

 <font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&&tqId=11182&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥nä¸ªæ•´æ•°ï¼Œæ‰¾å‡ºå…¶ä¸­æœ€å°çš„Kä¸ªæ•°ã€‚ä¾‹å¦‚è¾“å…¥4,5,1,6,2,7,3,8è¿™8ä¸ªæ•°å­—ï¼Œåˆ™æœ€å°çš„4ä¸ªæ•°å­—æ˜¯1,2,3,4,ã€‚ 

**ç¤ºä¾‹1**
**è¾“å…¥**

~~~
[4,5,1,6,2,7,3,8],4
~~~
**è¿”å›å€¼**

~~~
[1,2,3,4]

~~~



**1ã€ä¼˜å…ˆé˜Ÿåˆ—æ¥åšï¼Œæœ€å°ï¼Œç”¨å¤§é¡¶å †æ¥åš**

priority_queue<int,vector\<int>,less\<int>>

~~~cpp
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
    if(k > input.size()) return vector<int>();
    priority_queue<int, vector<int>, greater<int>> pq;
	for (auto a : input)
		pq.push(a);
	vector<int> result;
	while (k--) {
		result.push_back(pq.top());
		pq.pop();
	}
	return result;
    }
~~~

<p id = "è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œ"></p>

**No30ã€è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œ**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&&tqId=11183&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

 HZå¶å°”ä¼šæ‹¿äº›ä¸“ä¸šé—®é¢˜æ¥å¿½æ‚ é‚£äº›éè®¡ç®—æœºä¸“ä¸šçš„åŒå­¦ã€‚ä»Šå¤©æµ‹è¯•ç»„å¼€å®Œä¼šå,ä»–åˆå‘è¯äº†:åœ¨å¤è€çš„ä¸€ç»´æ¨¡å¼è¯†åˆ«ä¸­,å¸¸å¸¸éœ€è¦è®¡ç®—è¿ç»­å­å‘é‡çš„æœ€å¤§å’Œ,å½“å‘é‡å…¨ä¸ºæ­£æ•°çš„æ—¶å€™,é—®é¢˜å¾ˆå¥½è§£å†³ã€‚ä½†æ˜¯,å¦‚æœå‘é‡ä¸­åŒ…å«è´Ÿæ•°,æ˜¯å¦åº”è¯¥åŒ…å«æŸä¸ªè´Ÿæ•°,å¹¶æœŸæœ›æ—è¾¹çš„æ­£æ•°ä¼šå¼¥è¡¥å®ƒå‘¢ï¼Ÿä¾‹å¦‚:{6,-3,-2,7,-15,1,2,2},è¿ç»­å­å‘é‡çš„æœ€å¤§å’Œä¸º8(ä»ç¬¬0ä¸ªå¼€å§‹,åˆ°ç¬¬3ä¸ªä¸ºæ­¢)ã€‚ç»™ä¸€ä¸ªæ•°ç»„ï¼Œè¿”å›å®ƒçš„æœ€å¤§è¿ç»­å­åºåˆ—çš„å’Œï¼Œä½ ä¼šä¸ä¼šè¢«ä»–å¿½æ‚ ä½ï¼Ÿ(å­å‘é‡çš„é•¿åº¦è‡³å°‘æ˜¯1) 

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
[1,-2,3,10,-4,7,2,-5]
~~~
**è¿”å›å€¼**

~~~
18
~~~
**è¯´æ˜**
è¾“å…¥çš„æ•°ç»„ä¸º{1,-2,3,10,â€”4,7,2,ä¸€5}ï¼Œå’Œæœ€å¤§çš„å­æ•°ç»„ä¸º{3,10,ä¸€4,7,2}ï¼Œå› æ­¤è¾“å‡ºä¸ºè¯¥å­æ•°ç»„çš„å’Œ 18ã€‚ 



**1ã€ç›´æ¥åœ¨åŸæ•°ç»„ä¸Šæ”¹ï¼Œä¸å€Ÿç”¨ä»»ä½•å†…å­˜**

~~~cpp
int FindGreatestSumOfSubArray(vector<int> array) {
	for (int i = 1; i < array.size(); ++i) {
	    array[i] = max(0,array[i-1]) + array[i];
	}
	return *max_element(array.begin(),array.end());
}
~~~



**2ã€ä¸¤ä¸ªæ•°å­—ä¿å­˜ä¸­é—´ç»“æœ æˆ–è€…ä¸€ä¸ªæ•°å­—**

~~~cpp
int FindGreatestSumOfSubArray(vector<int> array) {
 
 
    int len = array.size();
    int maxNum = array[0],result=maxNum;
    for (int i = 1; i < len; ++i) {
        if (maxNum + array[i] > array[i])
            maxNum += array[i];
        else
            maxNum = array[i];
        result = max(maxNum, result);
    }
    return result;
}
~~~



~~~cpp
int FindGreatestSumOfSubArray(vector<int> array) {


	int maxNum = array[0];
	for (int i = 1; i <  array.size(); ++i) {
	    array[i] = max(0,array[i-1]) + array[i];
		maxNum = max(maxNum, array[i]);
	}
	return maxNum;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€å¸¸è§„DPåšæ³•ï¼Œå…¶å®è¿™é¢˜æ˜¯è¿ç»­ä¸Šå‡å­åºåˆ—çš„**

~~~cpp
    int FindGreatestSumOfSubArray(vector<int> array) {
    
	if (array.size() == 0) return 0;
	int maxNum = array[0];
	vector<int> dp(array.size(), 0);
	dp[0] = array[0];
	for (int i = 1; i < array.size(); ++i) {
		dp[i] = max(array[i], array[i] + dp[i - 1]);
		maxNum = max(maxNum, dp[i]);
	}
	return maxNum;
    }
~~~



**2ã€ç›´æ¥åœ¨åŸæ•°ç»„ä¸Šè¿›è¡Œä¿®æ”¹ï¼Œå¯ä»¥èŠ‚çº¦ä¸€ç‚¹ç©ºé—´**

è¿è¡Œæ—¶é—´ï¼š3ms   å ç”¨å†…å­˜ï¼š376k

~~~cpp
    int FindGreatestSumOfSubArray(vector<int> array) {
    
	    if (array.size() == 0) return 0;
        int maxNum = array[0];
        for (int i = 1; i < array.size(); ++i) {
            array[i] = max(array[i], array[i] + array[i - 1]);
            maxNum = max(maxNum, array[i]);
        }
        return maxNum;
    }
~~~

<p id = "æ•´æ•°ä¸­1å‡ºç°çš„æ¬¡æ•°"></p>


**No31ã€æ•´æ•°ä¸­1å‡ºç°çš„æ¬¡æ•°ï¼ˆ ä»1 åˆ° n ä¸­1å‡ºç°çš„æ¬¡æ•° ï¼‰**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&&tqId=11184&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

æ±‚å‡º1-13çš„æ•´æ•°ä¸­1å‡ºç°çš„æ¬¡æ•°,å¹¶ç®—å‡º100-1300çš„æ•´æ•°ä¸­1å‡ºç°çš„æ¬¡æ•°ï¼Ÿ

ä¸ºæ­¤ä»–ç‰¹åˆ«æ•°äº†ä¸€ä¸‹1~13ä¸­åŒ…å«1çš„æ•°å­—æœ‰1ã€10ã€11ã€12ã€13å› æ­¤å…±å‡ºç°6æ¬¡,ä½†æ˜¯å¯¹äºåé¢é—®é¢˜ä»–å°±æ²¡è¾™äº†ã€‚

ACMerå¸Œæœ›ä½ ä»¬å¸®å¸®ä»–,å¹¶æŠŠé—®é¢˜æ›´åŠ æ™®éåŒ–,å¯ä»¥å¾ˆå¿«çš„æ±‚å‡ºä»»æ„éè´Ÿæ•´æ•°åŒºé—´ä¸­1å‡ºç°çš„æ¬¡æ•°ï¼ˆä»1 åˆ° n ä¸­1å‡ºç°çš„æ¬¡æ•°ï¼‰ã€‚ 

**è¾“å…¥**

```
13
```
**è¿”å›å€¼**

```
6
```



**1ã€ç»å…¸æ–¹æ³•å—ï¼ŒçœŸçš„æƒ³ä¸åˆ°è¿™ç§æ–¹æ³•ï¼Œæˆ‘æœäº†**

æ‰§è¡Œç”¨æ—¶ï¼š0 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š5.8 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

åˆ†ä¸¤ç§æƒ…å†µï¼Œä¾‹å¦‚ï¼š1234å’Œ2234ï¼Œhighä¸ºæœ€é«˜ä½ï¼Œpowä¸ºæœ€é«˜ä½æƒé‡
åœ¨æ¯ç§æƒ…å†µä¸‹éƒ½å°†æ•°åˆ†æ®µå¤„ç†ï¼Œå³0-999ï¼Œ1000-1999ï¼Œ...ï¼Œå‰©ä½™éƒ¨åˆ†

 case1ï¼šæœ€é«˜ä½æ˜¯1ï¼Œåˆ™æœ€é«˜ä½çš„1çš„æ¬¡æ•°ä¸ºlast+1ï¼ˆ1000-1234ï¼‰
               æ¯é˜¶æ®µå³0-999çš„1çš„ä¸ªæ•°1*countDigitOne(pow-1)
               å‰©ä½™éƒ¨åˆ†1çš„ä¸ªæ•°ä¸ºcountDigitOne(last)--æœ€é«˜ä½å·²å•ç‹¬è®¡ç®—äº†

 case2ï¼šæœ€é«˜ä½ä¸æ˜¯1ï¼Œåˆ™æœ€é«˜ä½çš„1çš„æ¬¡æ•°ä¸ºpowï¼ˆ1000-1999ï¼‰
               æ¯é˜¶æ®µé™¤å»æœ€é«˜ä½å³0-999ï¼Œ1000-1999ä¸­1çš„æ¬¡æ•°ä¸ºhigh*countDigitOne(pow-1)
               å‰©ä½™éƒ¨åˆ†1çš„ä¸ªæ•°ä¸ºcountDigitOne(last)
              å‘ç°ä¸¤ç§æƒ…å†µä»…å·®åˆ«åœ¨æœ€é«˜ä½çš„1çš„ä¸ªæ•°ï¼Œå› æ­¤å•ç‹¬è®¡ç®—æœ€é«˜ä½çš„1ï¼ˆcntï¼‰ï¼Œåˆå¹¶å¤„ç†ä¸¤ç§æƒ…å†µ

~~~cpp
 int NumberOf1Between1AndN_Solution(int n)
    {
    if (n <= 0) return 0;
	if (n < 10) return 1;
	int high = n, pow = 1;// // å–å‡ºæœ€é«˜ä½ ä»¥åŠ æœ€é«˜ä½çš„æƒé‡
	while (high >= 10) {
		high /= 10;
		pow *= 10;
	}
	int last = n - high * pow;// é™¤æœ€é«˜ä½çš„æ•°å­—
	int cnt = high == 1 ? last + 1 : pow;// highæ˜¯å¦ä¸º1ï¼Œæœ€é«˜ä½çš„1ä¸ªæ•°ä¸åŒ
	return cnt + high * NumberOf1Between1AndN_Solution(pow - 1) + NumberOf1Between1AndN_Solution(last);

    }
~~~



**äºŒåˆ·ï¼š**

**è¶…çº§å¥½çš„æ–¹æ³•**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š376k

~~~cpp
    int NumberOf1Between1AndN_Solution(int n)
    {
        if(n <= 0) return 0;
        if(n < 10) return 1;
        int high = n,pow = 1;//é¦–é€‰æ±‚çš„æœ€é«˜ä½highå’Œæƒé‡pow 10 è¿˜æ˜¯100 è¿˜æ˜¯ 100 å‘¢
        while(high>=10){
            high = high /10;
            pow = pow * 10;
        }
        int last = n - high*pow;
        int cut = (high == 1? last + 1:pow );
        return cut + high*NumberOf1Between1AndN_Solution(pow - 1) + NumberOf1Between1AndN_Solution(last);
    }
~~~



**ä¸‰åˆ·ï¼š**

~~~cpp
    int NumberOf1Between1AndN_Solution(int n)
    {
        if(n <= 0) return 0;
        if(n< 10 ) return 1;
        if(n == 10) return 2;
        int pow = 1, high = n,last = 0;
        while(high >= 10){
            high = high/10;
            pow *=10;
        }
        last = n - high*pow;// é™¤å»æœ€é«˜ä½çš„æ•°å­—ï¼Œè¿˜å‰©ä¸‹å¤šå°‘ 0-999 1000- 1999 2000-2999 3000 3345
        int cut = high == 1 ? last+1: pow;
        
        return cut + high*NumberOf1Between1AndN_Solution(pow-1) + NumberOf1Between1AndN_Solution(last);

    }
~~~

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[åŠ›æ‰£](https://leetcode-cn.com/problems/number-of-digit-one/submissions/)</font>ä¸Šæœ‰ç±»ä¼¼çš„é¢˜ç›®

<p id = "æŠŠæ•°ç»„æ’æˆæœ€å°çš„æ•°"></p>

**No32ã€æŠŠæ•°ç»„æ’æˆæœ€å°çš„æ•°**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&&tqId=11185&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸€ä¸ªæ­£æ•´æ•°æ•°ç»„ï¼ŒæŠŠæ•°ç»„é‡Œæ‰€æœ‰æ•°å­—æ‹¼æ¥èµ·æ¥æ’æˆä¸€ä¸ªæ•°ï¼Œæ‰“å°èƒ½æ‹¼æ¥å‡ºçš„æ‰€æœ‰æ•°å­—ä¸­æœ€å°çš„ä¸€ä¸ªã€‚ä¾‹å¦‚è¾“å…¥æ•°ç»„{3ï¼Œ32ï¼Œ321}ï¼Œåˆ™æ‰“å°å‡ºè¿™ä¸‰ä¸ªæ•°å­—èƒ½æ’æˆçš„æœ€å°æ•°å­—ä¸º321323ã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

```
[3,32,321]
```

**è¿”å›å€¼**

```
"321323"
```

**1ã€å¾ˆç²¾å¦™ç»ä¼¦çš„ä¸€ç§æ’åºæ–¹æ³•**

æ‰§è¡Œç”¨æ—¶ï¼š12 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†92.42%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š11.5 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
string minNumber(vector<int>& nums) {

    vector<string> temp;
    for (auto num : nums) {
        temp.push_back(to_string(num));
    }

    sort(temp.begin(), temp.end(), [](const string& a, const string& b) { return a + b < b + a; });
    string result;
    for (auto& t : temp) {
        result += t;
    }
    return result;
}
~~~



**2ã€ç¬¬äºŒç§åšæ³•ï¼Œä¸ç¬¬ä¸€ç§åˆæœ‰ç‚¹ä¸ä¸€æ ·ï¼Œä½†æ˜¯é€Ÿåº¦æ¯”ç¬¬ä¸€ç§è¦æ…¢ä¸å°‘**

sortå‡½æ•°è¦å®šä¹‰ä¸ºé™æ€æˆ–è€…å…¨å±€å‡½æ•°

sortä¸­çš„æ¯”è¾ƒå‡½æ•°compareè¦å£°æ˜ä¸ºé™æ€æˆå‘˜å‡½æ•°æˆ–å…¨å±€å‡½æ•°ï¼Œä¸èƒ½ä½œä¸ºæ™®é€šæˆå‘˜å‡½æ•°ï¼Œå¦åˆ™ä¼šæŠ¥é”™ã€‚ å› ä¸ºï¼šéé™æ€æˆå‘˜å‡½æ•°æ˜¯ä¾èµ–äºå…·ä½“å¯¹è±¡çš„ï¼Œè€Œstd::sortè¿™ç±»å‡½æ•°æ˜¯å…¨å±€çš„ï¼Œå› æ­¤æ— æ³•å†sortä¸­è°ƒç”¨éé™æ€æˆå‘˜å‡½æ•°ã€‚é™æ€æˆå‘˜å‡½æ•°æˆ–è€…å…¨å±€å‡½æ•°æ˜¯ä¸ä¾èµ–äºå…·ä½“å¯¹è±¡çš„, å¯ä»¥ç‹¬ç«‹è®¿é—®ï¼Œæ— é¡»åˆ›å»ºä»»ä½•å¯¹è±¡å®ä¾‹å°±å¯ä»¥è®¿é—®ã€‚åŒæ—¶é™æ€æˆå‘˜å‡½æ•°ä¸å¯ä»¥è°ƒç”¨ç±»çš„éé™æ€æˆå‘˜ã€‚

æ‰§è¡Œç”¨æ—¶ï¼š28 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†22.65%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š11.5 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp

/*å¯¹vectorå®¹å™¨å†…çš„æ•°æ®è¿›è¡Œæ’åºï¼ŒæŒ‰ç…§ å°†aå’Œbè½¬ä¸ºstringå
 è‹¥ aï¼‹b<b+a  aæ’åœ¨åœ¨å‰ çš„è§„åˆ™æ’åº,
 å¦‚ 2 21 å› ä¸º 212 < 221 æ‰€ä»¥ æ’åºåä¸º 21 2 
  to_string() å¯ä»¥å°†int è½¬åŒ–ä¸ºstring
*/ class Solution {
 public:
     static bool cmp(int a,int b){
         string A=""ï¼ŒB="";
         A+=to_string(a);
         A+=to_string(b);
         B+=to_string(b);
         B+=to_string(a);      
         return A<B;
     }
     string PrintMinNumber(vector<int> numbers) {
         string  answer="";
         sort(numbers.begin(),numbers.end(),cmp);
         for(int i=0;i<numbers.size();i++){
             answer+=to_string(numbers[i]);
         }
         return answer;
     }
 };
~~~



**äºŒåˆ·ï¼š**

**1ã€è¶…å¼ºæ¯”è¾ƒæ–¹æ³•**

è¿è¡Œæ—¶é—´ï¼š2ms å ç”¨å†…å­˜ï¼š492k

~~~cpp
    string PrintMinNumber(vector<int> numbers) {
    
	vector<string> temp;
	for (auto a : numbers) {
		temp.push_back(std::move(to_string(a)));
	}

	sort(temp.begin(), temp.end(), [](const string& a, const string& b) {return a + b < b + a; });
	string result;
	for (auto& s : temp) {
		result += std::move(s);
	}

	return result;
    }
~~~

<p id="ä¸‘æ•°"></p>


**No33ã€ç¬¬Nä¸ªä¸‘æ•°**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&&tqId=11186&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸€ä¸ªæ­£æ•´æ•°æ•°ç»„ï¼ŒæŠŠæ•°ç»„é‡Œæ‰€æœ‰æ•°å­—æ‹¼æ¥èµ·æ¥æ’æˆä¸€ä¸ªæ•°ï¼Œæ‰“å°èƒ½æ‹¼æ¥å‡ºçš„æ‰€æœ‰æ•°å­—ä¸­æœ€å°çš„ä¸€ä¸ªã€‚ä¾‹å¦‚è¾“å…¥æ•°ç»„{3ï¼Œ32ï¼Œ321}ï¼Œåˆ™æ‰“å°å‡ºè¿™ä¸‰ä¸ªæ•°å­—èƒ½æ’æˆçš„æœ€å°æ•°å­—ä¸º321323ã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

```
[3,32,321]
```
**è¿”å›å€¼**

```
"321323"
```



**1ã€ä¸‰æŒ‡é’ˆæ³•  å¾ˆç»å…¸**

1-6ä¹‹é—´éƒ½æ˜¯ä¸‘æ•° 1 2 3 4 5 6 ç›´æ¥è¿”å›å³å¯

ç»´æŠ¤ä¸‰ä¸ªindexï¼Œé‡‡ç”¨ä¸‰indexé½å¤´å¹¶è¿›çš„åšæ³•ã€‚

~~~cpp
int GetUglyNumber_Solution(int index) {
	if(index < 7) return index;
	vector<int> result(index, 0);
	result[0] = 1;
	int indexTwo = 0, indexThree = 0,indexFive = 0;
	for (int i = 1; i < index; ++i) {
		int minNum = min(min(result[indexTwo] * 2, result[indexThree] * 3), result[indexFive] * 5);
		if (minNum == result[indexTwo] * 2) indexTwo++;
		if (minNum == result[indexThree] * 3) indexThree++;
		if (minNum == result[indexFive] * 5) indexFive++;
		result[i] = minNum;
	}
	return result[index - 1];

}
~~~

<p id = "ç¬¬ä¸€ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦"></p>

**No34ã€ç¬¬ä¸€ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank"> [ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&&tqId=11187&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

åœ¨ä¸€ä¸ªå­—ç¬¦ä¸²(0<=å­—ç¬¦ä¸²é•¿åº¦<=10000ï¼Œå…¨éƒ¨ç”±å­—æ¯ç»„æˆ)ä¸­æ‰¾åˆ°ç¬¬ä¸€ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦,å¹¶è¿”å›å®ƒçš„ä½ç½®, å¦‚æœæ²¡æœ‰åˆ™è¿”å› -1ï¼ˆéœ€è¦åŒºåˆ†å¤§å°å†™ï¼‰.ï¼ˆä»0å¼€å§‹è®¡æ•°ï¼‰ 

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
"google"
~~~
**è¿”å›å€¼**

~~~
4
~~~



**1ã€æŒºç®€å•çš„ï¼Œæƒ³å¤šäº†**

~~~cpp
    int FirstNotRepeatingChar(string str) {	
vector < int > result(58,0);
	for (int i = 0; i < str.size();++i) {
		result[str[i] - 'A'] += 1;
	}

	for (int i = 0; i < str.size(); ++i) {
		if(result[str[i] - 'A']==1)return i;
	}
	return -1;
    }
~~~



**2ã€ç”¨unordered_mapä¹Ÿè¡Œ**

~~~cpp
    int FirstNotRepeatingChar(string str) {
	unordered_map<char, int> mp;
	for (int i = 0; i < str.size();++i) {
		mp[str[i]] += 1;

	}

	for (int i = 0; i < str.size(); ++i) {
		if(mp[str[i]]==1)return i;
	}
	return -1;
    }
~~~



**äºŒåˆ·ï¼š**

**1ã€unordered_mapæ¥åšï¼Œå…¶å®ç”¨vectorä¹Ÿå¯ä»¥**

~~~cpp
    int FirstNotRepeatingChar(string str) {
        
        unordered_map<char,int> unmp;// char index
        
        for( int i = 0;i < str.size(); ++i)
            unmp[str[i]]++;
        
        for(int i = 0;i < str.size(); ++i)
            if(unmp[str[i]] == 1) return i;
        
        return -1;
        
    }
~~~

<p id = "æ•°ç»„ä¸­çš„é€†æ’åº"></p>

**No35ã€æ•°ç»„ä¸­çš„é€†æ’åº**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&&tqId=11188&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

åœ¨æ•°ç»„ä¸­çš„ä¸¤ä¸ªæ•°å­—ï¼Œå¦‚æœå‰é¢ä¸€ä¸ªæ•°å­—å¤§äºåé¢çš„æ•°å­—ï¼Œåˆ™è¿™ä¸¤ä¸ªæ•°å­—ç»„æˆä¸€ä¸ªé€†åºå¯¹ã€‚è¾“å…¥ä¸€ä¸ªæ•°ç»„,æ±‚å‡ºè¿™ä¸ªæ•°ç»„ä¸­çš„é€†åºå¯¹çš„æ€»æ•°Pã€‚å¹¶å°†På¯¹1000000007å–æ¨¡çš„ç»“æœè¾“å‡ºã€‚ å³è¾“å‡ºP%1000000007

**è¾“å…¥æè¿°**

é¢˜ç›®ä¿è¯è¾“å…¥çš„æ•°ç»„ä¸­æ²¡æœ‰çš„ç›¸åŒçš„æ•°å­—æ•°æ®èŒƒå›´ï¼š	å¯¹äº%50çš„æ•°æ®,size<=10^4	å¯¹äº%75çš„æ•°æ®,size<=10^5	å¯¹äº%100çš„æ•°æ®,size<=2*10^5

**ç¤ºä¾‹1**

**è¾“å…¥**

```
1,2,3,4,5,6,7,0
```

**è¾“å‡º**

```
7
```



**1ã€åªé€šè¿‡50%çš„ç¬¨æ–¹æ³•**

~~~cpp
    int InversePairs(vector<int> data) {
	if (data.size() <= 1) return 0;
	int len = data.size();
	vector<int> dp(len, 0);
	for (int i = len - 2; i >= 0; --i) {

		for (int j = i + 1; j < len; ++j) {
			if (data[i] > data[j]) { 
				//dp[i] = max(dp[i], dp[j] + 1); 
				dp[i]++;
			}

		}
	}

	return  accumulate(dp.begin(), dp.end(), 0) % 1000000007;
        
    }
~~~



**2ã€ç‰›å®¢ä¸Šçš„ä¸€ç§åšæ³•ï¼Œå¾ˆå‰å®³**

https://www.nowcoder.com/profile/872855282/codeBookDetail?submissionId=78340272

~~~cpp
int InversePairs(vector<int> data) {
	if (data.size() == 0)
		return 0;
	vector<int> copy(data);    // è¾…åŠ©æ•°ç»„ï¼Œæ¯æ¬¡é€’å½’åæœ‰åº
	return InversePairsCore(data, copy, 0, data.size() - 1);
}

int InversePairsCore(vector<int>& data, vector<int>& copy, int begin, int end) {
	if (begin == end)
		return 0;
	int mid = begin + (end - begin) /2;
	int left = InversePairsCore(copy, data, begin, mid);//è¿™é‡Œçš„ä¸€æ­¥å¾ˆç»å•Šï¼Œå‡å°‘äº†äº¤æ¢çš„è¿™ä¸€æ­¥
	int right = InversePairsCore(copy, data, mid + 1, end);

	int end1 = mid;     // æ¯”è¾ƒä»å°¾ç«¯å¼€å§‹
	int end2 = end;    // æ¯”è¾ƒä»å°¾ç«¯å¼€å§‹
	int index_copy = end;       // æ¯”è¾ƒç»“æœå­˜å…¥è¾…åŠ©æ•°ç»„å°¾ç«¯
	long res = 0;

	// å½’å¹¶æ’åºï¼šç›¸å½“äºä¸¤ä¸ªæœ‰åºæ•°ç»„åˆæˆä¸€ä¸ªæœ‰åºè¡¨ï¼ˆä»å°¾ç«¯å¼€å§‹æ˜¯ä¸ºäº†è®¡æ•°ï¼‰
	while (begin<= end1 && mid + 1<= end2) {
		if (data[end1] > data[end2]) {
			copy[index_copy--] = data[end1--];
			res += end2 - mid;
			res %= 1000000007;
		}
		else
			copy[index_copy--] = data[end2--];
	}

	while (begin<= end1)
		copy[index_copy--] = data[end1--];
	while (mid + 1<= end2)
		copy[index_copy--] = data[end2--];

	return (left + right + res) % 1000000007;
}


~~~

InversePairsCore(copy, data, begin, mid)ä¸­ copyå’Œdataäº’æ¢ä½ç½®å¥½è¯„ã€‚ã€‚ã€‚è¿™æ ·å°±å‡å°‘äº†èµ‹å€¼çš„é‚£ä¸€æ­¥äº†ã€‚ã€‚ã€‚ã€‚ã€‚



**äºŒåˆ·ï¼š**

**1ã€å¾ˆæ£’çš„ä¸€é“é¢˜ç›®ï¼Œå»ºè®®å¤šåˆ·**

~~~cpp
int InversePairsCore(vector<int>& data, vector<int>& copy, int begin, int end) {
	if (begin == end)
		return 0;
	int mid = begin + (end - begin) / 2;
	int low1 = begin, high1 = mid, low2 = mid + 1, high2 = end;
	int left = InversePairsCore(copy, data, low1, high1);//è¿™é‡Œçš„ä¸€æ­¥å¾ˆç»å•Šï¼Œå‡å°‘äº†äº¤æ¢çš„è¿™ä¸€æ­¥
	int right = InversePairsCore(copy, data, low2, high2);

	long res = 0;
	int copyIndex = low1;
	// å½’å¹¶æ’åºï¼šç›¸å½“äºä¸¤ä¸ªæœ‰åºæ•°ç»„åˆæˆä¸€ä¸ªæœ‰åºè¡¨
	while (low1 <= high1 && low2 <= high2) {
		if (data[low1] > data[low2]) {
			copy[copyIndex++] = data[low1++];
			res += high2 - low2 + 1;// data[low1] > data[low2]ï¼Œé‚£ä¹ˆè¿™ä¸€æ¬¡ï¼Œä»a[i]å¼€å§‹åˆ°a[mid]å¿…å®šéƒ½æ˜¯å¤§äºè¿™ä¸ªa[j]çš„ï¼Œå› ä¸ºæ­¤æ—¶åˆ†æ²»çš„ä¸¤è¾¹å·²ç»æ˜¯å„è‡ªæœ‰åºäº†
			res %= 1000000007;
		}
		else
			copy[copyIndex++] = data[low2++];
	}

	while (low1 <= high1)
		copy[copyIndex++] = data[low1++];
	while (low2 <= high2)
		copy[copyIndex++] = data[low2++];

	return (left + right + res) % 1000000007;
}


int InversePairs(vector<int> data) {
	if (data.size() == 0)
		return 0;
	vector<int> copy(data);    // è¾…åŠ©æ•°ç»„ï¼Œæ¯æ¬¡é€’å½’åæœ‰åº
	return InversePairsCore(data, copy, 0, data.size() - 1);
}
~~~



**2ã€å½’å¹¶æ’åºï¼Œå½’å¹¶æˆä»å°åˆ°å¤§çš„åºåˆ—ï¼Œè¿™ç§æ–¹æ³•æ›´å¥½ç†è§£ä¸€äº›**

è¿è¡Œæ—¶é—´ï¼š78ms  å ç”¨å†…å­˜ï¼š5788k

~~~cpp
int InversePairsCore(vector<int>& data, vector<int>& copy, int begin, int end) {
	if (begin == end)
		return 0;
	int mid = begin + (end - begin) / 2;
	int low1 = begin, high1 = mid, low2 = mid + 1, high2 = end;
	int left = InversePairsCore(copy, data, low1, high1);//è¿™é‡Œçš„ä¸€æ­¥å¾ˆç»å•Šï¼Œå‡å°‘äº†æ•°æ®äº¤æ¢çš„è¿™ä¸€æ­¥
	int right = InversePairsCore(copy, data, low2, high2);

	long res = 0;
	int copyIndex = low1;
	// å½’å¹¶æ’åºï¼šç›¸å½“äºä¸¤ä¸ªæœ‰åºæ•°ç»„åˆæˆä¸€ä¸ªæœ‰åºè¡¨
	//ä¸‹é¢å°±å¼€å§‹ä¸¤ä¸¤è¿›è¡Œæ¯”è¾ƒï¼Œè‹¥å‰é¢çš„æ•°å¤§äºåé¢çš„æ•°ï¼Œå°±æ„æˆé€†åºå¯¹
	while (low1 <= high1 && low2 <= high2) {
		if (data[low1] < data[low2]) {
			
			copy[copyIndex++] = data[low1++];
		}
		else//data[low1] >= data[low2]
		{
			copy[copyIndex++] = data[low2++];
			res += high1 - low1 + 1;
			res %= 1000000007;
		}
			
	}

	while (low1 <= high1)
		copy[copyIndex++] = data[low1++];
	while (low2 <= high2)
		copy[copyIndex++] = data[low2++];


	return (left + right + res) % 1000000007;
}


int InversePairs(vector<int> data) {
	if (data.size() == 0)
		return 0;
	vector<int> copy(data);    // è¾…åŠ©æ•°ç»„ï¼Œæ¯æ¬¡é€’å½’åæœ‰åº
	int res = InversePairsCore(data, copy, 0, data.size() - 1);
	
	//for (int a : data) {
	//	cout << a << " ";
	//}
	//cout << endl;

	//for (int a : copy) {
	//	cout << a << " ";
	//}
	//cout << endl;
	
	return res;

}
~~~



**åŠ›æ‰£ä¸Šçš„å‰‘æŒ‡offerï¼š**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[å‰‘æŒ‡ Offer 51. æ•°ç»„ä¸­çš„é€†åºå¯¹](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)</font>

åœ¨æ•°ç»„ä¸­çš„ä¸¤ä¸ªæ•°å­—ï¼Œå¦‚æœå‰é¢ä¸€ä¸ªæ•°å­—å¤§äºåé¢çš„æ•°å­—ï¼Œåˆ™è¿™ä¸¤ä¸ªæ•°å­—ç»„æˆä¸€ä¸ªé€†åºå¯¹ã€‚è¾“å…¥ä¸€ä¸ªæ•°ç»„ï¼Œæ±‚å‡ºè¿™ä¸ªæ•°ç»„ä¸­çš„é€†åºå¯¹çš„æ€»æ•°ã€‚

**ç¤ºä¾‹ 1:**

```
è¾“å…¥: [7,5,6,4]
è¾“å‡º: 5
```



**é™åˆ¶ï¼š**

```
0 <= æ•°ç»„é•¿åº¦ <= 50000
```

æ‰§è¡Œç”¨æ—¶ï¼š244 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†97.32%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š44.4 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
 int reversePairsCore(vector<int>&nums, vector<int>&copy, int begin, int end){
        if(begin >= end) return 0;//ç»ˆæ­¢æ¡ä»¶
        int mid = begin + (end - begin)/2;
        int low1 = begin, high1 = mid, low2 = mid + 1,high2 = end;
        int leftRes = reversePairsCore(copy, nums, low1, high1);
        int rightRes = reversePairsCore(copy, nums, low2, high2);

        int copyIndex = low1,res = 0;
        while(low1 <= high1 && low2 <= high2){
            if(nums[low1] <= nums[low2])//è¿™é‡Œéœ€è¦ä¿æŒç»å¯¹çš„å°
            {
                copy[copyIndex++] = nums[low1++];
            }else{
                res += high1 - low1 + 1;//è¯´æ˜ [low1,high1]æ­¤æ—¶éƒ½æ˜¯å¤§äº nums[low2]çš„
                //è¿™é‡Œåƒä¸‡æ³¨æ„è¦ +1 ï¼Œå› ä¸ºhigh1 - low1 å°±å°‘ä¸€ä¸ª æ¯”å¦‚ 3-0 = 4ï¼Œä½†å…¶å®æ˜¯4ä¸ªæ•°
                copy[copyIndex++] = nums[low2++];
            }

        }
        while(low1 <= high1)
            copy[copyIndex++] = nums[low1++];

        while(low2 <= high2)
            copy[copyIndex++] = nums[low2++];

        return res + leftRes + rightRes;

    }



    int reversePairs(vector<int>& nums) {
        if( nums.size() <= 1) return 0;
        vector<int> copy(nums);
        return reversePairsCore(nums,copy,0,nums.size()-1);

    }
~~~

 å½’å¹¶ç±»é¢˜ç›®ï¼š

åŠ›æ‰£ç¬¬315/327/493é“ 

<p id = "è¿”å›ä¸¤ä¸ªé“¾è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹"></p>

**No36ã€è¿”å›ä¸¤ä¸ªé“¾è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&&tqId=11189&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸¤ä¸ªé“¾è¡¨ï¼Œæ‰¾å‡ºå®ƒä»¬çš„ç¬¬ä¸€ä¸ªå…¬å…±ç»“ç‚¹ã€‚ï¼ˆæ³¨æ„å› ä¸ºä¼ å…¥æ•°æ®æ˜¯é“¾è¡¨ï¼Œæ‰€ä»¥é”™è¯¯æµ‹è¯•æ•°æ®çš„æç¤ºæ˜¯ç”¨å…¶ä»–æ–¹å¼æ˜¾ç¤ºçš„ï¼Œä¿è¯ä¼ å…¥æ•°æ®æ˜¯æ­£ç¡®çš„ï¼‰



**1ã€æš´åŠ›éå†æ³•**

~~~cpp
ListNode* FindFirstCommonNode(ListNode* pHead1, ListNode* pHead2) {
	if (pHead1 == NULL || pHead2 == NULL) return NULL;
	ListNode* node = (ListNode*)malloc(sizeof(ListNode));	
	while (pHead1 != NULL) {

		node = pHead2;
		while (node != NULL) {
			//cout << "node " << node->val << " phead1 " << pHead1->val << endl;
			if (node == pHead1) return node;
			else
				node = node->next;
		}
		//cout << endl;
		pHead1 = pHead1->next;

	}
	return NULL;
}
~~~



**2ã€å¤§ç¥å†™æ³•  å¤ªå‰å®³äº†ï¼ŒçœŸçš„ä½©æœ**

æœ‹å‹ä»¬ï¼Œè¯·ä¸€å®šè¦çæƒœèº«è¾¹çš„é‚£ä¸ª ta å•Šï¼ä½ ä»¬ä¹‹æ‰€ä»¥ç›¸é‡ï¼Œæ­£æ˜¯å› ä¸ºä½ èµ°äº† ta èµ°è¿‡çš„è·¯ï¼Œè€Œ ta ä¹Ÿåˆšå¥½èµ°äº†ä½ èµ°è¿‡çš„è·¯ã€‚è¿™æ˜¯ä½•ç­‰çš„ç¼˜åˆ†ï¼

è€Œå½“ä½ ä»¬æºæ‰‹ç»§ç»­èµ°ä¸‹å»æ—¶ï¼Œä½ ä¼šæ…¢æ…¢å˜æˆ ta çš„æ ·å­ï¼Œta ä¹Ÿä¼šæ…¢æ…¢å˜æˆä½ çš„æ ·å­ã€‚



a.é•¿åº¦ç›¸åŒçš„ï¼š1. æœ‰å…¬å…±ç»“ç‚¹çš„ï¼Œç¬¬ä¸€æ¬¡å°±éå†åˆ°ï¼›2. æ²¡æœ‰å…¬å…±ç»“ç‚¹çš„ï¼Œèµ°åˆ°å°¾éƒ¨NULLç›¸é‡ï¼Œè¿”å›NULLï¼›
b.é•¿åº¦ä¸åŒçš„ï¼š1. æœ‰å…¬å…±ç»“ç‚¹çš„ï¼Œç¬¬ä¸€éå·®å€¼å°±å‡ºæ¥äº†ï¼Œç¬¬äºŒéå°±ä¼šä¸€èµ·åˆ°å…¬å…±ç»“ç‚¹ï¼›2. æ²¡æœ‰å…¬å…±ç»“ç‚¹çš„ï¼Œç¬¬äºŒæ¬¡éå†ä¸€èµ·åˆ°ç»“å°¾NULLã€‚  

~~~cpp
//å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆ, ç¬¬ä¸€è½®è®©ä¸¤ä¸ªåˆ°è¾¾æœ«å°¾çš„èŠ‚ç‚¹æŒ‡å‘å¦ä¸€ä¸ªé“¾è¡¨çš„å¤´éƒ¨, æœ€åå¦‚æœç›¸é‡åˆ™ä¸ºäº¤ç‚¹(åœ¨ç¬¬ä¸€è½®ç§»åŠ¨ä¸­æ°å¥½æŠ¹é™¤äº†é•¿åº¦å·®)
        ä¸¤ä¸ªæŒ‡é’ˆç­‰äºç§»åŠ¨äº†ç›¸åŒçš„è·ç¦», æœ‰äº¤ç‚¹å°±è¿”å›, æ— äº¤ç‚¹å°±æ˜¯å„èµ°äº†ä¸¤æ¡æŒ‡é’ˆçš„é•¿åº¦
ListNode* FindFirstCommonNode(ListNode* pHead1, ListNode* pHead2) {
	if (pHead1 == NULL || pHead2 == NULL) return NULL;
	ListNode* p1 = (ListNode*)malloc(sizeof(ListNode));
	ListNode* p2 = (ListNode*)malloc(sizeof(ListNode));
	p1 = pHead1;
	p2 = pHead2;
	while (p1 != p2) {
		p1 = (p1 == NULL ? pHead2 : p1->next);
		p2 = (p2 == NULL ? pHead1 : p2->next);
	}
	return p1;
}

~~~



**äºŒåˆ·ï¼š**

1ã€æœ‰ä¸ªåœ°æ–¹è¦æ³¨æ„

~~~cpp
ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
    if(pHead1 == nullptr || pHead2 == nullptr) return nullptr;
    ListNode*p1 = pHead1,*p2 = pHead2;
    while(p1 != p2){
        p1 = (p1 == nullptr?pHead2:p1->next);//è¿™é‡Œéœ€è¦æ˜¯ p == null æ¥è¿›è¡Œåˆ¤æ–­ï¼Œä¸èƒ½æ˜¯ p->next == nullptr æ¥åˆ¤æ–­ï¼Œå› ä¸ºæœ‰å¯èƒ½æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹æ˜¯å…¬å…±èŠ‚ç‚¹
        p2 = (p2 == nullptr?pHead1:p2->next);
    }

    return p1;
}
~~~

<p id = "ç»Ÿè®¡ä¸€ä¸ªæ•°å­—åœ¨æ’åºæ•°ç»„ä¸­å‡ºç°çš„æ¬¡æ•°"></p>


**No37ã€ ç»Ÿè®¡ä¸€ä¸ªæ•°å­—åœ¨æ’åºæ•°ç»„ä¸­å‡ºç°çš„æ¬¡æ•°**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&&tqId=11190&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ç»Ÿè®¡ä¸€ä¸ªæ•°å­—åœ¨å‡åºæ•°ç»„ä¸­å‡ºç°çš„æ¬¡æ•°ã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

```
[1,2,3,3,3,3,4,5],3
```
**è¿”å›å€¼**

```
4
```



**1ã€STLä¸­å–å·§çš„ä¸€ç§å†™æ³•ï¼Œç›´æ¥è°ƒequal_range() æ–¹æ³•**

~~~cpp
int GetNumberOfK(vector<int> data ,int k) {
    auto pos = equal_range(data.begin(),data.end(),k);
    return pos.second - pos.first;
    }
~~~



**2ã€äºŒåˆ†æ³•ï¼Œæ‰¾åˆ°ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®å’Œæœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œè¿˜æ˜¯è®°è¿™ç§äºŒåˆ†æ³•æ¨¡æ¿å§**

low<=high  low = mid+1,high = mid-1;

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š504k

~~~cpp
int GetNumberOfK(vector<int> data, int k) {

	int low = 0, high = data.size() - 1;
	if (high == -1) return 0;//dataä¸ºç©º


	while (low  <= high) {
		int mid = low + (high - low)/2;
		if (data[mid] > k) high = mid -1 ;
		else if (data[mid] < k) low = mid + 1;
		else {//å·²ç»æ‰¾åˆ°
				int count = 0;
            count++;
			int index = mid-1;
			while (index >= 0 && data[index] == k) {
				count++;
				index--;
			}
			index = mid + 1;
			while (index <=data.size()-1&& data[index] == k) {
				count++;
				index++;
			}
			return count;
		}
	}
	return 0;//æ²¡æœ‰æ‰¾åˆ°ï¼Œç›´æ¥è¿”å› 0 å§
}
~~~

<p id = "äºŒå‰æ ‘çš„æ·±åº¦"></p>


**No38ã€äºŒå‰æ ‘çš„æ·±åº¦**

 <font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&&tqId=11191&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸€æ£µäºŒå‰æ ‘ï¼Œæ±‚è¯¥æ ‘çš„æ·±åº¦ã€‚ä»æ ¹ç»“ç‚¹åˆ°å¶ç»“ç‚¹ä¾æ¬¡ç»è¿‡çš„ç»“ç‚¹ï¼ˆå«æ ¹ã€å¶ç»“ç‚¹ï¼‰å½¢æˆæ ‘çš„ä¸€æ¡è·¯å¾„ï¼Œæœ€é•¿è·¯å¾„çš„é•¿åº¦ä¸ºæ ‘çš„æ·±åº¦ã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

```
{1,2,3,4,5,#,6,#,#,7}
```
**è¿”å›å€¼**

```
4
```



**1ã€BFSï¼Œè¿­ä»£ç‰ˆæœ¬**

~~~cpp
int TreeDepth(TreeNode* pRoot)
{
	if (pRoot == nullptr) return 0;
	queue<pair<TreeNode*, int>> q;
	q.push(make_pair(pRoot, 1));
	int maxDept = 1;
	while (!q.empty()) {
		TreeNode* curNode = q.front().first;
		int curDepth = q.front().second;
		q.pop();
		if (curNode) {
			maxDept = max(maxDept, curDepth);
			q.push({ curNode->left,curDepth + 1 });
			q.push({ curNode->right,curDepth + 1 });
		}
	}
	return maxDept;
}
~~~



**2ã€é€’å½’æ³•**

~~~cpp
int TreeDepth(TreeNode* pRoot)
{
	if (pRoot == nullptr) return 0;
	int leftDept = TreeDepth(pRoot->left) + 1, rightDept = TreeDepth(pRoot->right) + 1;
	return max(leftDept, rightDept;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€å¾ˆç®€å•çš„é€’å½’æ–¹æ³•**

è¿è¡Œæ—¶é—´ï¼š2ms å ç”¨å†…å­˜ï¼š504k

~~~cpp
int TreeDepth(TreeNode* pRoot)
{    
    if(pRoot == nullptr) return 0;
    int leftDepth = TreeDepth(pRoot->left);
    int rightDepth = TreeDepth(pRoot->right);
    return 1 + max(leftDepth,rightDepth);
}
~~~

<p id = "å¹³è¡¡äºŒå‰æ ‘"></p>


**No39ã€å¹³è¡¡äºŒå‰æ ‘**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&&tqId=11192&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸€æ£µäºŒå‰æ ‘ï¼Œåˆ¤æ–­è¯¥äºŒå‰æ ‘æ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘ã€‚

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬åªéœ€è¦è€ƒè™‘å…¶å¹³è¡¡æ€§ï¼Œä¸éœ€è¦è€ƒè™‘å…¶æ˜¯ä¸æ˜¯æ’åºäºŒå‰æ ‘

**è¾“å…¥**

~~~
{1,2,3,4,5,6,7}
~~~
**è¿”å›å€¼**

~~~
true
~~~

**1ã€æš´åŠ›æ³•ï¼Œç¬¨æ–¹æ³•**

æœ€ç›´æ¥çš„åšæ³•ï¼Œéå†æ¯ä¸ªç»“ç‚¹ï¼Œå€ŸåŠ©ä¸€ä¸ªè·å–æ ‘æ·±åº¦çš„é€’å½’å‡½æ•°ï¼Œæ ¹æ®è¯¥ç»“ç‚¹çš„å·¦å³å­æ ‘é«˜åº¦å·®åˆ¤æ–­æ˜¯å¦å¹³è¡¡ï¼Œç„¶åé€’å½’åœ°å¯¹å·¦å³å­æ ‘è¿›è¡Œåˆ¤æ–­ã€‚

~~~cpp
int maxDepth(TreeNode* node) {

	if (node == nullptr)  return 0;
	return 1 + max(maxDepth(node->left), maxDepth(node->right));
}

bool IsBalanced_Solution(TreeNode* pRoot) {
	if (pRoot == nullptr) return true;//è¿™é‡Œæ˜¯è¿”å›true è€Œä¸å†æ˜¯false
	return abs(maxDepth(pRoot->left) - maxDepth(pRoot->right)) <= 1 &&
		IsBalanced_Solution(pRoot->left) && IsBalanced_Solution(pRoot->right);
}
~~~

return åé¢ä¸éœ€è¦åŠ ä¸¤ä¸ª&&æ¥é€’å½’ä»–å·¦å­æ ‘å’Œå³å­æ ‘. è¿™æ ·æƒ³, æœ‰ä¸€ä¸ªå‡½æ•°å¾—åˆ°äº†ä»–çš„æ·±åº¦, é‚£ä¹ˆåªè¦æ ¹çš„å·¦å­æ ‘å’Œå³å­æ ‘æ·±åº¦ä¸è¶…è¿‡1å°±å¯ä»¥äº†.  åé¢åˆ¤æ–­çš„æ²¡æœ‰ä»€ä¹ˆå¿…è¦



**2ã€æ”¹è¿›ç‰ˆï¼Œå¾ˆå¥½çš„æ–¹æ³•ï¼Œåªéå†ä¸€æ¬¡ï¼Œç”»ä¸ªäºŒå‰æ ‘å°±çŸ¥é“äº†**

 ä¸Šé¢è¿™ç§åšæ³•æœ‰å¾ˆæ˜æ˜¾çš„é—®é¢˜ï¼Œåœ¨åˆ¤æ–­ä¸Šå±‚ç»“ç‚¹çš„æ—¶å€™ï¼Œä¼šå¤šæ¬¡é‡å¤éå†ä¸‹å±‚ç»“ç‚¹ï¼Œå¢åŠ äº†ä¸å¿…è¦çš„å¼€é”€ã€‚å¦‚æœæ”¹ä¸ºä»ä¸‹å¾€ä¸Šéå†ï¼Œå¦‚æœå­æ ‘æ˜¯å¹³è¡¡äºŒå‰æ ‘ï¼Œåˆ™è¿”å›å­æ ‘çš„é«˜åº¦ï¼›å¦‚æœå‘ç°å­æ ‘ä¸æ˜¯å¹³è¡¡äºŒå‰æ ‘ï¼Œåˆ™ç›´æ¥åœæ­¢éå†ï¼Œè¿™æ ·è‡³å¤šåªå¯¹æ¯ä¸ªç»“ç‚¹è®¿é—®ä¸€æ¬¡ã€‚  

~~~cpp
int getDepth(TreeNode* node) {

	if (node == nullptr)  return 0;
	int leftDept = getDepth(node->left);
	if (leftDept == -1) return -1;
	int rightDept = getDepth(node->right);
	if (rightDept == -1) return -1;
	if (abs(leftDept - rightDept) > 1) 
		return -1;
	else
		return 1 + max(leftDept,rightDept);
}

bool IsBalanced_Solution(TreeNode* pRoot) {
	if (pRoot == nullptr) return true;//è¿™é‡Œæ˜¯è¿”å›true è€Œä¸å†æ˜¯false
	return getDepth(pRoot)!=-1;
}
~~~

è¿™ç§åšæ³•æœ‰å¾ˆæ˜æ˜¾çš„é—®é¢˜ï¼Œåœ¨åˆ¤æ–­ä¸Šå±‚ç»“ç‚¹çš„æ—¶å€™ï¼Œä¼šå¤šæ¬¡é‡å¤éå†ä¸‹å±‚ç»“ç‚¹ï¼Œå¢åŠ äº†ä¸å¿…è¦çš„å¼€é”€ã€‚å¦‚æœæ”¹ä¸ºä»ä¸‹å¾€ä¸Šéå†ï¼Œå¦‚æœå­æ ‘æ˜¯å¹³è¡¡äºŒå‰æ ‘ï¼Œåˆ™è¿”å›å­æ ‘çš„é«˜åº¦ï¼›å¦‚æœå‘ç°å­æ ‘ä¸æ˜¯å¹³è¡¡äºŒå‰æ ‘ï¼Œåˆ™ç›´æ¥åœæ­¢éå†ï¼Œè¿™æ ·è‡³å¤šåªå¯¹æ¯ä¸ªç»“ç‚¹è®¿é—®ä¸€æ¬¡ã€‚  



**äºŒåˆ·ï¼š**

æ‰€è°“å¹³è¡¡äºŒå‰æ ‘å°±æ˜¯ä»–çš„å·¦å­©å­å’Œå³å­©å­çš„æ·±åº¦ä¹‹å·®ä¸èƒ½è¶…è¿‡1

**1ã€è¿­ä»£æ–¹æ³• ä»”ç»†æƒ³ä¸€ä¸‹**

~~~cpp
int getDepth(TreeNode * node){

    if(node == nullptr) return 0;
    int left = getDepth(node->left),right = getDepth(node->right);

    return 1 + max(left,right);
}

bool IsBalanced_Solution(TreeNode* pRoot) {

    if(pRoot == nullptr) return true;//è¿™é‡Œè¿”å›çš„æ˜¯trueï¼Œä¸ºç©ºçš„è¯å°±åº”è¯¥æ˜¯

    return abs(getDepth(pRoot->left) - getDepth(pRoot->right))<=1;
}
~~~



**2ã€è¿­ä»£æ³•æ”¹è¿›ç‰ˆæœ¬ï¼Œä»ä¸‹å¾€ä¸Šä¾¿åˆ©ï¼Œè¿™ç§æ–¹æ³•å¥½ä¸€ç‚¹**

~~~cpp
int getDepth(TreeNode * node){

    if(node == nullptr) return 0;
    int left = getDepth(node->left);
    if(left == -1)  return -1;

    int right = getDepth(node->right);
    if(right == -1) return -1;

    if(abs(left - right) > 1) return -1;
    else
        return 1 + max(left,right);
}

bool IsBalanced_Solution(TreeNode* pRoot) {

    if(pRoot == nullptr) return true;

    return getDepth(pRoot) != -1;
}
~~~

<p id = "æ•°ç»„ä¸­åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—"></p>
**No40ã€æ•°ç»„ä¸­åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank"> [ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&&tqId=11193&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ä¸€ä¸ªæ•´å‹æ•°ç»„é‡Œé™¤äº†ä¸¤ä¸ªæ•°å­—ä¹‹å¤–ï¼Œå…¶ä»–çš„æ•°å­—éƒ½å‡ºç°äº†ä¸¤æ¬¡ã€‚è¯·å†™ç¨‹åºæ‰¾å‡ºè¿™ä¸¤ä¸ªåªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ã€‚ 



**1ã€å¸¸è§„åšæ³•**

~~~cpp
void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) {
    unordered_map<int, int> unmp;
    for (int i = 0; i < data.size(); ++i) {
        unmp[data[i]] += 1;
    }


    auto it = unmp.begin();
    while (it != unmp.end()) {
        if (it->second == 1) {
            *num1 = it->first;
            ++it;
            break;
        }
        ++it;
    }

    while (it != unmp.end()) {
        if (it->second == 1) {
            *num2 = it->first;
            break;
        }
        ++it;
    }
}
~~~



**äºŒåˆ·ï¼š**

**1ã€hashè¡¨çš„ç¬¨æ–¹æ³•**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š376k

~~~cpp
void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) {
    unordered_map<int,int> unmp;
    for(auto a:data){
        unmp[a]++;
    }

    auto beg = unmp.begin();
    while(beg != unmp.end())
    {
        if(beg->second == 1)
        {
            *num1 = beg->first;
            beg++;
            break;
        }
        beg++;

    }

    while(beg != unmp.end())
    {
        if(beg->second == 1)
        {
            *num2 = beg->first;
            break;
        }
        beg++;

    }
}
~~~



**2ã€å¼‚æˆ–åšæ³•ï¼Œå¾ˆæ£’**

  å½“**åªæœ‰ä¸€ä¸ªæ•°å‡ºç°ä¸€æ¬¡**æ—¶ï¼Œæˆ‘ä»¬æŠŠæ•°ç»„ä¸­æ‰€æœ‰çš„æ•°ï¼Œä¾æ¬¡å¼‚æˆ–è¿ç®—ï¼Œæœ€åå‰©ä¸‹çš„å°±æ˜¯è½å•çš„æ•°ï¼Œå› ä¸ºæˆå¯¹å„¿å‡ºç°çš„éƒ½æŠµæ¶ˆäº†ã€‚ 

ä¾ç…§è¿™ä¸ªæ€è·¯ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸¤ä¸ªæ•°ï¼ˆæˆ‘ä»¬å‡è®¾æ˜¯ABï¼‰å‡ºç°ä¸€æ¬¡çš„æ•°ç»„ã€‚æˆ‘ä»¬é¦–å…ˆè¿˜æ˜¯å…ˆå¼‚æˆ–ï¼Œå‰©ä¸‹çš„æ•°å­—è‚¯å®šæ˜¯Aã€Bå¼‚æˆ–çš„ç»“æœï¼Œ**è¿™ä¸ªç»“æœçš„äºŒè¿›åˆ¶ä¸­çš„1ï¼Œè¡¨ç°çš„æ˜¯Aå’ŒBçš„ä¸åŒçš„ä½**ã€‚æˆ‘ä»¬å°±å–ç¬¬ä¸€ä¸ª1æ‰€åœ¨çš„ä½æ•°ï¼Œå‡è®¾æ˜¯ç¬¬3ä½ï¼Œæ¥ç€æŠŠåŸæ•°ç»„åˆ†æˆ**ä¸¤ç»„**ï¼Œåˆ†ç»„æ ‡å‡†æ˜¯ç¬¬3ä½æ˜¯å¦ä¸º1ã€‚å¦‚æ­¤ï¼Œ**ç›¸åŒçš„æ•°è‚¯å®šåœ¨ä¸€ä¸ªç»„**ï¼Œå› ä¸ºç›¸åŒæ•°å­—æ‰€æœ‰ä½éƒ½ç›¸åŒï¼Œè€Œä¸åŒçš„æ•°ï¼Œ**è‚¯å®šä¸åœ¨ä¸€ç»„**ã€‚ç„¶åæŠŠè¿™ä¸¤ä¸ªç»„æŒ‰ç…§æœ€å¼€å§‹çš„æ€è·¯ï¼Œä¾æ¬¡å¼‚æˆ–ï¼Œå‰©ä½™çš„ä¸¤ä¸ªç»“æœå°±æ˜¯è¿™ä¸¤ä¸ªåªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ã€‚

è¿è¡Œæ—¶é—´ï¼š3ms å ç”¨å†…å­˜ï¼š376k

~~~cpp
void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) {


    if (data.size() < 2) return;

    int totalNum = 0;
    for (int i = 0; i < data.size(); i++) {
        totalNum ^= data[i];//æ‰€æœ‰æ•°å¼‚æˆ–ï¼Œç»“æœä¸ºä¸åŒçš„ä¸¤ä¸ªæ•°å­—çš„å¼‚æˆ–
    }

    int sign = 0;//æ ‡å¿—ä½ï¼Œè®°å½•totalNumä¸­çš„ç¬¬ä¸€ä¸ª1å‡ºç°çš„ä½ç½®
    for (; sign < data.size(); sign++) {
        if ((totalNum & (1 << sign)) != 0) { //å·¦ç§» sign ä½ï¼Œå°†æ‰€æœ‰æ•°å­—è¿›è¡Œå·¦ç§»signä½ï¼Œè€Œä½ä½è¡¥ä¸Š0
            break;
        }
    }
    cout << sign << endl;
    num1[0] = 0;
    num2[0] = 0;
    for (int i = 0; i < data.size(); i++) {
        if ((data[i] & (1 << sign)) == 0) {//æ ‡å¿—ä½ä¸º0çš„ä¸ºä¸€ç»„ï¼Œå¼‚æˆ–åå¿…å¾—åˆ°ä¸€ä¸ªæ•°å­—ï¼ˆè¿™é‡Œæ³¨æ„==çš„ä¼˜å…ˆçº§é«˜äº&ï¼Œéœ€åœ¨å‰é¢åŠ ï¼ˆï¼‰ï¼‰
            num1[0] ^= data[i];
            cout << "0 "<<data[i] << " " << (1<<sign) << endl;
        }
        else {
            num2[0] ^= data[i];//æ ‡å¿—ä½ä¸º1çš„ä¸ºä¸€ç»„
            cout << "1 " << data[i] << " " << (1 << sign) << endl;
        }
    }
    cout << num1[0] << num2[0] << endl;       
}
~~~

<p id = "å’Œä¸ºSçš„è¿ç»­æ•´æ•°åºåˆ—"></p>


**No41ã€å’Œä¸ºSçš„è¿ç»­æ•´æ•°åºåˆ—**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&&tqId=11194&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

 å°æ˜å¾ˆå–œæ¬¢æ•°å­¦,æœ‰ä¸€å¤©ä»–åœ¨åšæ•°å­¦ä½œä¸šæ—¶,è¦æ±‚è®¡ç®—å‡º9~16çš„å’Œ,ä»–é©¬ä¸Šå°±å†™å‡ºäº†æ­£ç¡®ç­”æ¡ˆæ˜¯100ã€‚ä½†æ˜¯ä»–å¹¶ä¸æ»¡è¶³äºæ­¤,ä»–åœ¨æƒ³ç©¶ç«Ÿæœ‰å¤šå°‘ç§è¿ç»­çš„æ­£æ•°åºåˆ—çš„å’Œä¸º100(è‡³å°‘åŒ…æ‹¬ä¸¤ä¸ªæ•°)ã€‚æ²¡å¤šä¹…,ä»–å°±å¾—åˆ°å¦ä¸€ç»„è¿ç»­æ­£æ•°å’Œä¸º100çš„åºåˆ—:18,19,20,21,22ã€‚ç°åœ¨æŠŠé—®é¢˜äº¤ç»™ä½ ,ä½ èƒ½ä¸èƒ½ä¹Ÿå¾ˆå¿«çš„æ‰¾å‡ºæ‰€æœ‰å’Œä¸ºSçš„è¿ç»­æ­£æ•°åºåˆ—? Good Luck! 

**è¾“å‡ºæè¿°:**

```
è¾“å‡ºæ‰€æœ‰å’Œä¸ºSçš„è¿ç»­æ­£æ•°åºåˆ—ã€‚åºåˆ—å†…æŒ‰ç…§ä»å°è‡³å¤§çš„é¡ºåºï¼Œåºåˆ—é—´æŒ‰ç…§å¼€å§‹æ•°å­—ä»å°åˆ°å¤§çš„é¡ºåº
```

è¾“å…¥
~~~
9
~~~
**è¿”å›å€¼**

~~~
[[2,3,4],[4,5]]
~~~



**1ã€ç‰›å®¢è§£æ³•ï¼Œå¾ˆå‰å®³ã€‚ç±»ä¼¼äºTCPæ»‘åŠ¨çª—å£**

~~~cpp
vector<vector<int> > FindContinuousSequence(int sum) {
    vector<vector<int>> result;
    int low=1,high=2;//ä¸¤ä¸ªèµ·ç‚¹ï¼Œç›¸å½“äºåŠ¨æ€çª—å£çš„ä¸¤è¾¹ï¼Œæ ¹æ®å…¶çª—å£å†…çš„å€¼çš„å’Œæ¥ç¡®å®šçª—å£çš„ä½ç½®å’Œå¤§å°
    while(low<high){
        int sumTemp = (low+high) *(high-low +1)/2;
        //ç”±äºæ˜¯è¿ç»­çš„ï¼Œå·®ä¸º1çš„ä¸€ä¸ªåºåˆ—ï¼Œé‚£ä¹ˆæ±‚å’Œå…¬å¼æ˜¯(a0+an)*n/2
        if(sumTemp == sum){  //ç›¸ç­‰ï¼Œé‚£ä¹ˆå°±å°†çª—å£èŒƒå›´çš„æ‰€æœ‰æ•°æ·»åŠ è¿›ç»“æœé›†
            vector<int> resultTemp;
            for(int i=low;i<=high;++i)
            {resultTemp.push_back(i);}
            result.push_back(resultTemp);
            low++;
        }else if(sumTemp<sum){ //å¦‚æœå½“å‰çª—å£å†…çš„å€¼ä¹‹å’Œå°äºsumï¼Œé‚£ä¹ˆå³è¾¹çª—å£å³ç§»ä¸€ä¸‹
            high++;
        }
        else{  //å¦‚æœå½“å‰çª—å£å†…çš„å€¼ä¹‹å’Œå¤§äºsumï¼Œé‚£ä¹ˆå·¦è¾¹çª—å£å³ç§»ä¸€ä¸‹
            low++;
        }
    }
    return result;
}
~~~



**2ã€æš´åŠ›è§£æ³•**

~~~cpp
vector<vector<int> > FindContinuousSequence(int sum) {
    vector<vector<int> > result;
    for (int n = sqrt(2 * sum); n >= 2; --n) {
        if (((n & 1) == 1 && sum % n == 0) || (sum % n * 2 == n)) {
            vector<int> res;
            //jç”¨äºè®¡æ•°ï¼Œkç”¨äºéå†æ±‚å€¼
            for (int j = 0, k = sum / n - (n - 1) / 2; j < n; j++, k++)//æ³¨æ„çœ‹kçš„æ±‚æ³•
                res.push_back(k);
            result.push_back(res);
        }
    }
    return result;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€æ»‘åŠ¨çª—å£ï¼Œç›´æ¥ç”¨æ•°å­¦å…¬å¼æ¥è¿›è¡Œè®¡ç®—**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š496k

~~~cpp
vector<vector<int> > FindContinuousSequence(int sum) {
    vector<vector<int>> result;
    int low = 1,high = 2;
    while(low < high){
        int sumTemp = (low + high) * (high - low + 1)/2;
        if(sumTemp == sum){
            vector<int> temp;
            for(int i = low;i <= high; ++i)
                temp.push_back(i);
            result.push_back(std::move(temp));
            low++;//å³ä½¿å½“å‰æ»¡è¶³ï¼Œé‚£ä¹ˆä¾ç„¶è¦å‰è¿›çš„ï¼Œè¿™æœ‰ç‚¹æ»‘åŠ¨çª—å£çš„æ„æ€å§
        }else if(sumTemp < sum) high++;
        else
            low++;
    }
    return std::move(result);//å€ŸåŠ©C++11çš„moveå‡½æ•°ï¼Œæ€»ä½“æ—¶é—´ä¼šæ›´çŸ­    
}
~~~



<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[åŠ›æ‰£ç½‘åŸé¢˜é“¾æ¥](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)</font>

æ‰§è¡Œç”¨æ—¶ï¼š0 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š6.9 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†39.52%çš„ç”¨æˆ·

~~~cpp
vector<vector<int>> findContinuousSequence(int target) {

    vector<vector<int>> result;
    int low = 1,high = 2;
    while(low < high){
        int sumTemp = (low + high) * (high - low + 1)/2;
        if(sumTemp == target){
            vector<int> temp;
            for(int i = low;i <= high; ++i)
                temp.push_back(i);
            result.push_back(std::move(temp));
            low++;
        }else if(sumTemp < target) high++;
        else
            low++;
    }
    return std::move(result);//å€ŸåŠ©C++11çš„moveå‡½æ•°ï¼Œæ€»ä½“æ—¶é—´ä¼šæ›´çŸ­    
}
~~~

<p id = "å’Œä¸ºSçš„ä¸¤ä¸ªæ•°å­—"></p>


**No42ã€å’Œä¸ºSçš„ä¸¤ä¸ªæ•°å­—**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&&tqId=11195&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¾“å…¥ä¸€ä¸ªé€’å¢æ’åºçš„æ•°ç»„å’Œä¸€ä¸ªæ•°å­—Sï¼Œåœ¨æ•°ç»„ä¸­æŸ¥æ‰¾ä¸¤ä¸ªæ•°ï¼Œä½¿å¾—ä»–ä»¬çš„å’Œæ­£å¥½æ˜¯Sï¼Œå¦‚æœæœ‰å¤šå¯¹æ•°å­—çš„å’Œç­‰äºSï¼Œè¾“å‡ºä¸¤ä¸ªæ•°çš„ä¹˜ç§¯æœ€å°çš„ã€‚

**è¾“å‡ºæè¿°:**

```
å¯¹åº”æ¯ä¸ªæµ‹è¯•æ¡ˆä¾‹ï¼Œè¾“å‡ºä¸¤ä¸ªæ•°ï¼Œå°çš„å…ˆè¾“å‡º
```

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
[1,2,4,7,11,15],15
~~~
**è¿”å›å€¼**

~~~
[4,11]
~~~



**1ã€å¾ˆç®€å•çš„ä¸€ä¸ªé—®é¢˜**

~~~cpp
vector<int> FindNumbersWithSum(vector<int> array,int sum) {        
    vector<int>  result;
    if (array.size() == 0)  return result;
    int low = 0, high = array.size() - 1;

    while (low <= high) {
        if (array[low] + array[high] == sum) {
            result.push_back(array[low]);
            result.push_back(array[high]);
            return result;
        }
        else if (array[low] + array[high] < sum)  low++;
        else {
            high--;
        }
    }
    return result;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€æ»‘åŠ¨çª—å£æ¥åš**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š512k

~~~cpp
 vector<int> FindNumbersWithSum(vector<int> array,int sum) {
       int low= 0, high = array.size()-1;
       int minResult = INT_MAX;
       vector<int> result;
       while(low <= high){
           int sumTemp = array[low] + array[high];
           if(sumTemp == sum){
               if( array[low] * array[high] < minResult){
                  result.clear();
                  result.push_back(array[low]);
                  result.push_back(array[high]);
                  minResult = array[low] * array[high];//è¿™é‡Œå…¶å®å¯ä»¥ç›´æ¥è¿”å›çš„ï¼Œå› ä¸ºåŒæ¯”æƒ…å†µä¸‹ï¼Œä¸¤ä¸ªæ•°å­—ç›¸å·®è¶Šè¿œï¼Œä»–ä»¬çš„ä¹˜ç§¯è¶Šå°çš„ï¼Œçº¦é è¿‘ç›¸å·®çš„ä¹˜ç§¯å°±è¶Šå¤§
               }
               
               low++;
           }else if(sumTemp > sum) high--;
           else
               low++;
       }
       return result;
    }
~~~



**ä¼˜åŒ–ä¸€ä¸‹**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š476k

~~~cpp
vector<int> FindNumbersWithSum(vector<int> array,int sum) {
       int low= 0, high = array.size()-1;
       vector<int> result;
       while(low <= high){
           int sumTemp = array[low] + array[high];
           if(sumTemp == sum){
               result.push_back(array[low]);
               result.push_back(array[high]);
               return result;

           }else if(sumTemp > sum) high--;
           else
               low++;
       }
       return result;
    }
~~~

<p id = "å·¦æ—‹è½¬å­—ç¬¦ä¸²"></p>
**No43ã€å·¦æ—‹è½¬å­—ç¬¦ä¸²**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank"> [ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&&tqId=11196&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

æ±‡ç¼–è¯­è¨€ä¸­æœ‰ä¸€ç§ç§»ä½æŒ‡ä»¤å«åšå¾ªç¯å·¦ç§»ï¼ˆROLï¼‰ï¼Œç°åœ¨æœ‰ä¸ªç®€å•çš„ä»»åŠ¡ï¼Œå°±æ˜¯ç”¨å­—ç¬¦ä¸²æ¨¡æ‹Ÿè¿™ä¸ªæŒ‡ä»¤çš„è¿ç®—ç»“æœã€‚å¯¹äºä¸€ä¸ªç»™å®šçš„å­—ç¬¦åºåˆ—Sï¼Œè¯·ä½ æŠŠå…¶å¾ªç¯å·¦ç§»Kä½åçš„åºåˆ—è¾“å‡ºã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦åºåˆ—S=â€abcXYZdefâ€,è¦æ±‚è¾“å‡ºå¾ªç¯å·¦ç§»3ä½åçš„ç»“æœï¼Œå³â€œXYZdefabcâ€ã€‚æ˜¯ä¸æ˜¯å¾ˆç®€å•ï¼ŸOKï¼Œæå®šå®ƒï¼ 

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
"abcXYZdef",3
~~~
**è¿”å›å€¼**

~~~
"XYZdefabc"
~~~



**1ã€æˆ‘çœŸçš„æ˜¯å¤ªå‚»æ¯”äº†ï¼Œå…¶å®å¾ˆå®¹æ˜“çš„**

~~~cpp
 string LeftRotateString(string str, int n) {
	int len = str.size();
    if(len==0) return str;//è€ƒè™‘strä¸ºç©º
	if (n >= len) n = n % len;//è€ƒè™‘næ¯”strçš„é•¿åº¦è¿˜è¦å¤§çš„æƒ…å†µä¸‹
	string temp = str + str;
	string result;
	result.resize(len);
	for (int i = n,index=0; i <len+n; ++i,++index) {
		result[index] = temp[i];
	}
	return result;
    }
~~~



**2ã€ç²¾ç®€åšæ³•**

~~~cpp
string LeftRotateString(string str, int n) {
	int len = str.size();
    if(len==0) return str;
	if (n >= len) n = n % len;
	str += str;
	return str.substr(n,len);
}
~~~



**äºŒåˆ·ï¼š**

**1ã€ç®€å•çš„å­—ç¬¦ä¸²å¤„ç†å‡½æ•°ï¼Œè®°å¾—è¾¹ç•Œæ¡ä»¶**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š376k

~~~cpp
string LeftRotateString(string str, int n) {
        int len = str.size();
        if(len <= 1) return str;//å¯èƒ½ä¸ºç©º
        n = n%len;//å¹¶ä¸”næœ‰å¯èƒ½æ¯”lenå¤§çš„æƒ…å†µ
        vector<char> temp(str.begin(),str.end());
        for(int i = 0;i < n;++i)
            temp.push_back(str[i]);
        str.assign(n + temp.begin(),temp.end());
        return std::move(str);
    }
~~~

<p id = "åè½¬å•è¯åºåˆ—"></p>


**No44ã€åè½¬å•è¯åºåˆ—**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&&tqId=11197&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ç‰›å®¢æœ€è¿‘æ¥äº†ä¸€ä¸ªæ–°å‘˜å·¥Fishï¼Œæ¯å¤©æ—©æ™¨æ€»æ˜¯ä¼šæ‹¿ç€ä¸€æœ¬è‹±æ–‡æ‚å¿—ï¼Œå†™äº›å¥å­åœ¨æœ¬å­ä¸Šã€‚åŒäº‹Catå¯¹Fishå†™çš„å†…å®¹é¢‡æ„Ÿå…´è¶£ï¼Œæœ‰ä¸€å¤©ä»–å‘Fishå€Ÿæ¥ç¿»çœ‹ï¼Œä½†å´è¯»ä¸æ‡‚å®ƒçš„æ„æ€ã€‚ä¾‹å¦‚ï¼Œâ€œstudent. a am Iâ€ã€‚åæ¥æ‰æ„è¯†åˆ°ï¼Œè¿™å®¶ä¼™åŸæ¥æŠŠå¥å­å•è¯çš„é¡ºåºç¿»è½¬äº†ï¼Œæ­£ç¡®çš„å¥å­åº”è¯¥æ˜¯â€œI am a student.â€ã€‚Catå¯¹ä¸€ä¸€çš„ç¿»è½¬è¿™äº›å•è¯é¡ºåºå¯ä¸åœ¨è¡Œï¼Œä½ èƒ½å¸®åŠ©ä»–ä¹ˆï¼Ÿ

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
"nowcoder. a am I"
~~~
**è¿”å›å€¼**

~~~
"I am a nowcoder."
~~~

**1ã€åˆ«æƒ³å¤ªå¤šï¼Œèƒ½åšå‡ºæ¥å°±å¥½**

~~~cpp
string ReverseSentence(string str) {
	string res = "", tmp = "";
	for (unsigned int i = 0; i < str.size(); ++i) {
		if (str[i] == ' ')
		{
			res = " " + tmp + res;
			tmp = "";
		}
		else tmp += str[i];
	}
	if (tmp.size()) 
		res = tmp + res;
	return res;
}
~~~

**2ã€å€ŸåŠ©æ ˆ åè€Œä¼šå‡ºé”™ï¼Œç›´æ¥ç¬¬ä¸€ç§æ–¹æ³•å°±å¯ä»¥**



**äºŒåˆ·ï¼š**

**ç›´æ¥åšå°±è¡Œ**

è¿è¡Œæ—¶é—´ï¼š2ms å ç”¨å†…å­˜ï¼š464k

~~~cpp
string ReverseSentence(string str) {
	if (str.size() <= 1) return str;
	string result, temp;
	for (int i = str.size() - 1; i >= 0; --i) {
		if (str[i] != ' ') {
			temp = str[i] + temp;
		}
		else if (str[i] == ' ') {
			result = result + temp + " ";
			temp = "";
		}
	}
	if (temp.size() != 0) result = result + temp;

	return std::move(result);
}
~~~

<p id = "æ‰‘å…‹ç‰Œé¡ºå­"></p>


**No45ã€æ‰‘å…‹ç‰Œé¡ºå­**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank"> [ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&&tqId=11198&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

LLä»Šå¤©å¿ƒæƒ…ç‰¹åˆ«å¥½,å› ä¸ºä»–å»ä¹°äº†ä¸€å‰¯æ‰‘å…‹ç‰Œ,å‘ç°é‡Œé¢å±…ç„¶æœ‰2ä¸ªå¤§ç‹,2ä¸ªå°ç‹(ä¸€å‰¯ç‰ŒåŸæœ¬æ˜¯54å¼ ^_^)...

ä»–éšæœºä»ä¸­æŠ½å‡ºäº†5å¼ ç‰Œ,æƒ³æµ‹æµ‹è‡ªå·±çš„æ‰‹æ°”,çœ‹çœ‹èƒ½ä¸èƒ½æŠ½åˆ°é¡ºå­,å¦‚æœæŠ½åˆ°çš„è¯,ä»–å†³å®šå»ä¹°ä½“è‚²å½©ç¥¨,å˜¿å˜¿ï¼ï¼

â€œçº¢å¿ƒA,é»‘æ¡ƒ3,å°ç‹,å¤§ç‹,æ–¹ç‰‡5â€,â€œOh My God!â€ä¸æ˜¯é¡ºå­.....LLä¸é«˜å…´äº†,ä»–æƒ³äº†æƒ³,å†³å®šå¤§\å° ç‹å¯ä»¥çœ‹æˆä»»ä½•æ•°å­—,å¹¶ä¸”Açœ‹ä½œ1,Jä¸º11,Qä¸º12,Kä¸º13ã€‚ä¸Šé¢çš„5å¼ ç‰Œå°±å¯ä»¥å˜æˆâ€œ1,2,3,4,5â€(å¤§å°ç‹åˆ†åˆ«çœ‹ä½œ2å’Œ4),â€œSo Lucky!â€ã€‚

LLå†³å®šå»ä¹°ä½“è‚²å½©ç¥¨å•¦ã€‚ ç°åœ¨,è¦æ±‚ä½ ä½¿ç”¨è¿™å¹…ç‰Œæ¨¡æ‹Ÿä¸Šé¢çš„è¿‡ç¨‹,ç„¶åå‘Šè¯‰æˆ‘ä»¬LLçš„è¿æ°”å¦‚ä½•ï¼Œ å¦‚æœç‰Œèƒ½ç»„æˆé¡ºå­å°±è¾“å‡ºtrueï¼Œå¦åˆ™å°±è¾“å‡ºfalseã€‚

ä¸ºäº†æ–¹ä¾¿èµ·è§,ä½ å¯ä»¥è®¤ä¸ºå¤§å°ç‹æ˜¯0ã€‚ 

**ç¤ºä¾‹1**

**è¾“å…¥**

```
[6,0,2,0,4]
```

**è¿”å›å€¼**

```
true
```

**ç¤ºä¾‹2**

**è¾“å…¥**

```
[0,3,2,6,4]
```

**è¿”å›å€¼**

```
true
```

**ç¤ºä¾‹3**

**è¾“å…¥**

```
[1,0,0,1,0]
```

**è¿”å›å€¼**

```
false
```

**ç¤ºä¾‹4**

**è¾“å…¥**

```
[13,12,11,0,1]
```

**è¿”å›å€¼**

```
false
```

**1ã€æ¯”è¾ƒå®¹æ˜“æƒ³åˆ°çš„ä¸€ç§æ–¹æ³•**

1ã€æ’åº 

2ã€è®¡ç®—æ‰€æœ‰ç›¸é‚»æ•°å­—é—´éš”æ€»æ•° 

3ã€è®¡ç®—0çš„ä¸ªæ•° 

4ã€å¦‚æœ2ã€3ç›¸ç­‰ï¼Œå°±æ˜¯é¡ºå­ 

5ã€å¦‚æœå‡ºç°å¯¹å­ï¼Œåˆ™ä¸æ˜¯é¡ºå­

~~~cpp
    bool IsContinuous( vector<int> numbers ) {
        int len = numbers.size();
        if(len<5) return false;
        sort(numbers.begin(),numbers.end());
        int numOfZreo = 0,numOfInner=0;
        for(int i=0;i<len-1;++i){
            if(numbers[i]==0)  ++numOfZreo;
            else if(numbers[i]==numbers[i+1]){
                return false;
            }
            else{
                numOfInner += numbers[i+1] - numbers[i] -1;//è¿™é‡Œåƒä¸‡æ³¨æ„è¦å‡å»1
            }
            //cout<<numOfZreo<<" "<<numOfInner<<endl;
        }
        if(numOfZreo>=numOfInner) return true;
        return false;
    }
~~~



**2ã€ç¬¬äºŒç§æ–¹æ³•**

max è®°å½• æœ€å¤§å€¼
 min è®°å½•  æœ€å°å€¼
 min ,max éƒ½ä¸è®°0
 æ»¡è¶³æ¡ä»¶ 1 max - min   <5
                2 é™¤0å¤–æ²¡æœ‰é‡å¤çš„æ•°å­—(ç‰Œ)
                3 æ•°ç»„é•¿åº¦ ä¸º5  

~~~cpp
 bool IsContinuous( vector<int> numbers ) {
	int maxNum = -1, minNum = 14;
	if (numbers.size() < 5)//å°äº5åˆ™ä¸ºfalse
		return false;
	vector<int> result(14, 0);
	result[0] = -5;
	for (int i = 0; i < numbers.size(); ++i)
	{  
		result[numbers[i]]++;
		if (numbers[i] == 0)//å‡ºç°0åˆ™è·³è¿‡
			continue;
		if (result[numbers[i]] > 1) return false;
		if (numbers[i] > maxNum)
			maxNum = numbers[i];//å–æœ€å¤§æ•°
		if (numbers[i] < minNum)
			minNum = numbers[i];//å–æœ€å°æ•°
	}
	if (maxNum - minNum < 5)
		return true;//åˆ¤æ–­æ˜¯å¦å°äº5
	eturn false;
    }
~~~



ä¸‹é¢çš„ä»£ç æœ‰é—®é¢˜ï¼Œæ— æ³•åˆ¤æ–­æ˜¯å¦æœ‰é‡å¤çš„æ•°å­—ï¼Œæ¯”å¦‚1,2,4,5,4å°±æ— æ³•åˆ¤æ–­

~~~cpp
    bool IsContinuous( vector<int> numbers ) {
	int maxNum = -1, minNum = 14;
	if (numbers.size() < 5)//å°äº5åˆ™ä¸ºfalse
		return false;
	for (int i = 0; i < numbers.size(); i++)
	{   //åˆ¤æ–­æ˜¯æ˜¯å¦å°äº0å’Œå¤§äº13ä»¥åŠæœ‰æ²¡æœ‰é‡å¤æ•°å­—
		if (numbers[i] < 0 || numbers[i]>13 || numbers[i] == maxNum || numbers[i] == minNum)
			return false;
		if (numbers[i] == 0)//å‡ºç°0åˆ™è·³è¿‡
			continue;
		if (numbers[i] > maxNum)
			maxNum = numbers[i];//å–æœ€å¤§æ•°
		if (numbers[i] < minNum)
			minNum = numbers[i];//å–æœ€å°æ•°
	}
	if (maxNum - minNum < 5)
		return true;//åˆ¤æ–­æ˜¯å¦å°äº5
	return false;
    }
~~~



**äºŒåˆ·ï¼š**

**å…ˆæ’åºï¼Œå†è¿›è¡Œæ“ä½œå³å¯ï¼ŒæŒºå¥½**

è¿è¡Œæ—¶é—´ï¼š3ms å ç”¨å†…å­˜ï¼š504k

~~~cpp
    bool IsContinuous( vector<int> numbers ) {
if (numbers.size() <= 4) return false;
	sort(numbers.begin(), numbers.end());
	int countZero = 0;
	int index = 0;
	while (index < numbers.size() && numbers[index] == 0) {
		countZero++;
		index++;
	}
	//cout << index << endl;
	//cout << countZero << endl;
	for (int i = index; i < numbers.size() - 1; ++i) {
		if (numbers[i] == numbers[i+1]) return false;
		else if ( (numbers[i]+1) == numbers[i+1]) {
			continue;
		}
		else {
			countZero -= (numbers[i+1] - numbers[i] - 1);
		}
		//cout << countZero << endl;
		if (countZero < 0) return false;
	}


	return countZero >= 0;
    }
~~~

<p id = "å­©å­ä»¬çš„æ¸¸æˆï¼ˆåœ†åœˆä¸­æœ€åå‰©ä¸‹çš„æ•°ï¼‰"></p>


**No46ã€å­©å­ä»¬çš„æ¸¸æˆï¼ˆåœ†åœˆä¸­æœ€åå‰©ä¸‹çš„æ•°ï¼‰**

[<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&&tqId=11199&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

æ¯å¹´å…­ä¸€å„¿ç«¥èŠ‚,ç‰›å®¢éƒ½ä¼šå‡†å¤‡ä¸€äº›å°ç¤¼ç‰©å»çœ‹æœ›å­¤å„¿é™¢çš„å°æœ‹å‹,ä»Šå¹´äº¦æ˜¯å¦‚æ­¤ã€‚HFä½œä¸ºç‰›å®¢çš„èµ„æ·±å…ƒè€,è‡ªç„¶ä¹Ÿå‡†å¤‡äº†ä¸€äº›å°æ¸¸æˆã€‚å…¶ä¸­,æœ‰ä¸ªæ¸¸æˆæ˜¯è¿™æ ·çš„:é¦–å…ˆ,è®©å°æœ‹å‹ä»¬å›´æˆä¸€ä¸ªå¤§åœˆã€‚ç„¶å,ä»–éšæœºæŒ‡å®šä¸€ä¸ªæ•°m,è®©ç¼–å·ä¸º0çš„å°æœ‹å‹å¼€å§‹æŠ¥æ•°ã€‚æ¯æ¬¡å–Šåˆ°m-1çš„é‚£ä¸ªå°æœ‹å‹è¦å‡ºåˆ—å”±é¦–æ­Œ,ç„¶åå¯ä»¥åœ¨ç¤¼å“ç®±ä¸­ä»»æ„çš„æŒ‘é€‰ç¤¼ç‰©,å¹¶ä¸”ä¸å†å›åˆ°åœˆä¸­,ä»ä»–çš„ä¸‹ä¸€ä¸ªå°æœ‹å‹å¼€å§‹,ç»§ç»­0...m-1æŠ¥æ•°....è¿™æ ·ä¸‹å»....ç›´åˆ°å‰©ä¸‹æœ€åä¸€ä¸ªå°æœ‹å‹,å¯ä»¥ä¸ç”¨è¡¨æ¼”,å¹¶ä¸”æ‹¿åˆ°ç‰›å®¢åè´µçš„â€œåä¾¦æ¢æŸ¯å—â€å…¸è—ç‰ˆ(åé¢æœ‰é™å“¦!!^_^)ã€‚è¯·ä½ è¯•ç€æƒ³ä¸‹,å“ªä¸ªå°æœ‹å‹ä¼šå¾—åˆ°è¿™ä»½ç¤¼å“å‘¢ï¼Ÿ(æ³¨ï¼šå°æœ‹å‹çš„ç¼–å·æ˜¯ä»0åˆ°n-1)

å¦‚æœæ²¡æœ‰å°æœ‹å‹ï¼Œè¯·è¿”å›-1

**ç¤ºä¾‹1**

**è¾“å…¥**

```
5,3
```

**è¿”å›å€¼**

```
3
```

**1ã€æ—¶é—´å¤æ‚åº¦å¤ªå¤§**

~~~cpp
class Solution {
public:
struct ListNode {
	int val;
	struct ListNode* next;
	ListNode(int v) :val(v), next(NULL) {

	}
};
    
    int LastRemaining_Solution(int n, int m)
    {
    ListNode* root=(ListNode*)malloc(sizeof(ListNode));
	root->val = 0;
	ListNode* node = (ListNode*)(malloc)(sizeof(ListNode));
	node=root;
	for (int i = 1; i < n; ++i) {
		ListNode* temp = (ListNode*)(malloc)(sizeof(ListNode));
		temp->val = i;
		node->next = temp;
		node = node->next;
	}
	node->next = root;

	int count = 0,result=-1;
	while (root != nullptr && n!=1) {
		if (++count == m - 1) {
			result = root->val;
			root = root->next;
			node->next = root;
			count = 0;
			n--;
			continue;
		}

		root = root->next;
		node = node->next;
		
	}
	result = root->val;
	return result;
    }
};
~~~



**2ã€çº¦ç‘Ÿå¤«ç¯çš„é—®é¢˜ï¼ŒèƒŒæ¨¡æ¿å§ å•¥ä¹Ÿåˆ«è¯´äº†ï¼ŒèƒŒæ¨¡æ¿å§**

æ‰§è¡Œç”¨æ—¶ï¼š4 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†99.81%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š5.8 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
int lastRemaining(int n, int m) {

    if(n <= 0 || m < 0)
        return -1;
    int ans = 0;
    // æœ€åä¸€è½®å‰©ä¸‹2ä¸ªäººï¼Œæ‰€ä»¥ä»2å¼€å§‹åæ¨
    for (int i = 2; i <= n; ++i) {
        ans = (ans + m) % i;
    }
    return ans;
}
~~~



**3ã€é€’å½’åšæ³•ï¼Œä¸è§‰æ˜å‰**

~~~cpp
int LastRemaining_Solution(int n, int m)
{
    if(n==0)
        return -1;
    if(n==1)
        return 0;
    else
        return (LastRemaining_Solution(n-1,m)+m)%n;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€ä½¿ç”¨æ•°ç»„ä»£æ›¿ç¯ï¼Œè€ƒè™‘æ¸…æ¥šä»å¤´å¼€å§‹çš„æƒ…å†µ**

è¿è¡Œæ—¶é—´ï¼š58ms å ç”¨å†…å­˜ï¼š496k

~~~cpp
int LastRemaining_Solution(int n, int m)
{

    if(n<1 || m<1)  return -1;
    vector<int> numbers(n,0);
    int index = -1,step = 0, count = n;
    while(count > 0){  //è·³å‡ºå¾ªç¯æ—¶å°†æœ€åä¸€ä¸ªå…ƒç´ ä¹Ÿè®¾ç½®ä¸ºäº†-1

        index++; //æŒ‡å‘ä¸Šä¸€ä¸ªè¢«åˆ é™¤å¯¹è±¡çš„ä¸‹ä¸€ä¸ªå…ƒç´ ã€‚
        if(index >= n )index = 0; //æ¨¡æ‹Ÿç¯ã€‚
        if(numbers[index] == -1) continue; //è·³è¿‡è¢«åˆ é™¤çš„å¯¹è±¡ã€‚
        step++; //è®°å½•å·²èµ°è¿‡çš„ã€‚å‘å‰èµ°ä¸€æ­¥
        if(step == m){ //æ‰¾åˆ°å¾…åˆ é™¤çš„å¯¹è±¡ã€‚

            numbers[index] = -1;
            step = 0;
            count--;
        }
    }
    return index; //è¿”å›è·³å‡ºå¾ªç¯æ—¶çš„index,å³æœ€åä¸€ä¸ªè¢«è®¾ç½®ä¸º-1çš„å…ƒç´ 
}
~~~

<p id = "æ±‚æ€»å’Œ"></p>


**No47ã€æ±‚1+2+3+...+N**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&&tqId=11200&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

æ±‚1+2+3+...+nï¼Œè¦æ±‚ä¸èƒ½ä½¿ç”¨ä¹˜é™¤æ³•ã€forã€whileã€ifã€elseã€switchã€caseç­‰å…³é”®å­—åŠæ¡ä»¶åˆ¤æ–­è¯­å¥ï¼ˆA?B:Cï¼‰ã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
5
~~~
**è¿”å›å€¼**

~~~
15
~~~

**1ã€ä»–å¦ˆçš„ï¼Œæˆ‘æœäº†**

~~~cpp
int Sum_Solution(int n) {
    bool a[n][n+1];
    return sizeof(a)>>1;
}
~~~

å› ä¸ºboolç±»å‹çš„ä¸º1ä¸ªå­—èŠ‚ï¼Œæˆ–è€…æ¢ä¸ºcharçš„ä¹Ÿè¡Œï¼Œä»–ä»¬éƒ½æ˜¯ä¸€ä¸ªå­—èŠ‚ï¼Œå¦‚æœæ˜¯short(2),int(4)å°±ä¸è¡Œäº†

**2ã€è¿™ä¸ªæ–¹æ³•çœŸçš„å¾ˆå¦™**

è§£é¢˜æ€è·¯ï¼š
1.éœ€åˆ©ç”¨é€»è¾‘ä¸çš„çŸ­è·¯ç‰¹æ€§å®ç°é€’å½’ç»ˆæ­¢ã€‚ 
2.å½“n == 0æ—¶ï¼Œ(n > 0) && ((sum += Sum_Solution(n - 1)) > 0)åªæ‰§è¡Œå‰é¢çš„åˆ¤æ–­ï¼Œä¸ºfalseï¼Œç„¶åç›´æ¥è¿”å›0ï¼›
3.å½“n > 0æ—¶ï¼Œæ‰§è¡Œsum += Sum_Solution(n - 1)ï¼Œå®ç°é€’å½’è®¡ç®—Sum_Solution(n)ã€‚

~~~cpp
    int Sum_Solution(int n) {
	int sumNum = n;
	bool ans = (n > 0) && ((sumNum += Sum_Solution(n - 1)) > 0);
	return sumNum;
    }
~~~

**äºŒåˆ·ï¼š**

**1ã€å¾ˆæ£’çš„æ–¹æ³•å•Š**

1.éœ€åˆ©ç”¨é€»è¾‘ä¸çš„çŸ­è·¯ç‰¹æ€§å®ç°é€’å½’ç»ˆæ­¢ã€‚ 
2.å½“n == 0æ—¶ï¼Œ(n > 0) && ((sum += Sum_Solution(n - 1)) > 0)åªæ‰§è¡Œå‰é¢çš„åˆ¤æ–­ï¼Œä¸ºfalseï¼Œç„¶åç›´æ¥è¿”å›0ï¼›
3.å½“n > 0æ—¶ï¼Œæ‰§è¡Œsum += Sum_Solution(n - 1)ï¼Œå®ç°é€’å½’è®¡ç®—Sum_Solution(n)ã€‚

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š508k

~~~cpp
    int Sum_Solution(int n) {
        
    int sumNum = n;
	n > 0 && (sumNum += Sum_Solution(n - 1));
	return sumNum;    
        
    }
~~~

<p id = "æ±‚ä¸¤ä¸ªæ•°ç›¸åŠ "></p>


**No48ã€æ±‚ä¸¤ä¸ªæ•°ç›¸åŠ **

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&&tqId=11201&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**
å†™ä¸€ä¸ªå‡½æ•°ï¼Œæ±‚ä¸¤ä¸ªæ•´æ•°ä¹‹å’Œï¼Œè¦æ±‚åœ¨å‡½æ•°ä½“å†…ä¸å¾—ä½¿ç”¨+ã€-ã€*ã€\/å››åˆ™è¿ç®—ç¬¦å·ã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
1,2
~~~
**è¿”å›å€¼**

~~~
3
~~~

**1ã€è¿™ç§è§£æ³•çœŸçš„å¤ªå‰å®³äº†**

~~~cpp
int Add(int num1, int num2)
{
    while( num2!=0 ){
        int sum = num1 ^ num2;
        int carray = (num1 & num2) << 1;
        num1 = sum;
        num2 = carray;
    } 
    return num1;
}
~~~

1. **ä¸¤ä¸ªæ•°å¼‚æˆ–**ï¼šç›¸å½“äºæ¯ä¸€ä½ç›¸åŠ ï¼Œè€Œä¸è€ƒè™‘è¿›ä½ï¼›
2. **ä¸¤ä¸ªæ•°ç›¸ä¸**ï¼Œå¹¶å·¦ç§»ä¸€ä½ï¼šç›¸å½“äºæ±‚å¾—è¿›ä½ï¼›
3. å°†ä¸Šè¿°ä¸¤æ­¥çš„ç»“æœç›¸åŠ 



é¦–å…ˆçœ‹åè¿›åˆ¶æ˜¯å¦‚ä½•åšçš„ï¼š 5+7=12ï¼Œä¸‰æ­¥èµ° 

ç¬¬ä¸€æ­¥ï¼šç›¸åŠ å„ä½çš„å€¼ï¼Œä¸ç®—è¿›ä½ï¼Œå¾—åˆ°2ã€‚

 ç¬¬äºŒæ­¥ï¼šè®¡ç®—è¿›ä½å€¼ï¼Œå¾—åˆ°10. å¦‚æœè¿™ä¸€æ­¥çš„è¿›ä½å€¼ä¸º0ï¼Œé‚£ä¹ˆç¬¬ä¸€æ­¥å¾—åˆ°çš„å€¼å°±æ˜¯æœ€ç»ˆç»“æœã€‚  

ç¬¬ä¸‰æ­¥ï¼šé‡å¤ä¸Šè¿°ä¸¤æ­¥ï¼Œåªæ˜¯ç›¸åŠ çš„å€¼å˜æˆä¸Šè¿°ä¸¤æ­¥çš„å¾—åˆ°çš„ç»“æœ2å’Œ10ï¼Œå¾—åˆ°12ã€‚ 



 åŒæ ·æˆ‘ä»¬å¯ä»¥ç”¨ä¸‰æ­¥èµ°çš„æ–¹å¼è®¡ç®—äºŒè¿›åˆ¶å€¼ç›¸åŠ ï¼š

5-101ï¼Œ7-111

 ç¬¬ä¸€æ­¥ï¼šç›¸åŠ å„ä½çš„å€¼ï¼Œä¸ç®—è¿›ä½ï¼Œå¾—åˆ°010ï¼ŒäºŒè¿›åˆ¶æ¯ä½ç›¸åŠ å°±ç›¸å½“äºå„ä½åšå¼‚æˆ–æ“ä½œï¼Œ101^111ã€‚ 

 ç¬¬äºŒæ­¥ï¼šè®¡ç®—è¿›ä½å€¼ï¼Œå¾—åˆ°1010ï¼Œç›¸å½“äºå„ä½åšä¸æ“ä½œå¾—åˆ°101ï¼Œå†å‘å·¦ç§»ä¸€ä½å¾—åˆ°1010ï¼Œ(101&111)<<1ã€‚  

ç¬¬ä¸‰æ­¥é‡å¤ä¸Šè¿°ä¸¤æ­¥ï¼Œ å„ä½ç›¸åŠ  010^1010=1000ï¼Œè¿›ä½å€¼ä¸º100=(010&1010)<<1ã€‚      

ç»§ç»­é‡å¤ä¸Šè¿°ä¸¤æ­¥ï¼š1000^100 = 1100ï¼Œè¿›ä½å€¼ä¸º0ï¼Œè·³å‡ºå¾ªç¯ï¼Œ1100ä¸ºæœ€ç»ˆç»“æœã€‚   



ä»€ä¹ˆæ—¶å€™è¿›ä½åˆ¶ä¸º0ä¹Ÿå°±è¯´æ˜ä¸¤ä¸ªæ•°ç›¸åŠ åˆ°äº†æœ€ç»ˆç‚¹ï¼Œä¹Ÿå°±è®¡ç®—ç»“æŸäº†



**äºŒåˆ·ï¼š**

**1ã€ä¸å¤ªç†è§£ï¼Œè®°ä½æ¨¡æ¿å§**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š376k

~~~cpp
int Add(int num1, int num2)
{

    while(num2 != 0){
        int sum = num1 ^num2;
        int carry = (num1 & num2)<<1;
        num1 = sum;
        num2 = carry;

    }
    return num1;
}
~~~

<p id = "æœ€å°çš„Kä¸ªæ•°"></p>

**No49ã€å­—ç¬¦ä¸²è½¬åŒ–ä¸ºæ•´æ•°**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&&tqId=11202&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

å°†ä¸€ä¸ªå­—ç¬¦ä¸²è½¬æ¢æˆä¸€ä¸ªæ•´æ•°ï¼Œè¦æ±‚ä¸èƒ½ä½¿ç”¨å­—ç¬¦ä¸²è½¬æ¢æ•´æ•°çš„åº“å‡½æ•°ã€‚ æ•°å€¼ä¸º0æˆ–è€…å­—ç¬¦ä¸²ä¸æ˜¯ä¸€ä¸ªåˆæ³•çš„æ•°å€¼åˆ™è¿”å›0

**è¾“å…¥æè¿°:**

```
è¾“å…¥ä¸€ä¸ªå­—ç¬¦ä¸²,åŒ…æ‹¬æ•°å­—å­—æ¯ç¬¦å·,å¯ä»¥ä¸ºç©º
```

**è¾“å‡ºæè¿°:**

```
å¦‚æœæ˜¯åˆæ³•çš„æ•°å€¼è¡¨è¾¾åˆ™è¿”å›è¯¥æ•°å­—ï¼Œå¦åˆ™è¿”å›0
```

**ç¤ºä¾‹1**

**è¾“å…¥**

```
+2147483647
1a33
```

**è¾“å‡º**

```
2147483647
0
```



**1ã€è‡ªå·±æ€è€ƒçš„ä¸€ç§ç¬¨æ–¹æ³•,è¿™é¢˜ç”¨C++   AC ä¸äº†**

è´Ÿæ•° -1234ï¼Œæ­£æ•° +2563çš„æƒ…å½¢ ç¬¬ä¸€ä¸ªä¸ºæ­£è´Ÿå· è¦è€ƒè™‘åˆ°

ç¬¬ä¸€ä½ä¸º0çš„ä¹Ÿæ˜¯ä¸æ˜¯åˆæ³•çš„

å‡ºç°0~9ä¹‹å¤–çš„å­—ç¬¦ä¹Ÿæ˜¯ä¸åˆæ³•çš„

~~~cpp
int StrToInt(string str) {
    long long num = 0;
    if (str.size() == 0) return 0;
    int len = str.size();
    bool isNegative = false,isPositive = false;
    if (str[0] == '-') isNegative=true;
    else if (str[0] == '+') isPositive = true;
    else
        if (str[0]<='0' || str[0]>'9')  return 0;

    int i = 0;
    if (isPositive || isNegative) i = 1;
    for (    ; i <len ; ++i) {
        if (str[i]<'0' || str[i]>'9') return 0;
        else {
            num = num * 10 + str[i] - '0';
        }

    }
    if (isNegative) num = -1 * num;
    if (num <= INT_MAX && num >= INT_MIN) return num;
    return 0;
}
~~~

åªé€šè¿‡85.71%çš„æ¡ˆä¾‹ã€‚



**2ã€ç¬¬äºŒç§ç²¾ç®€ä¸€ç‚¹çš„æ–¹æ³•**

~~~cpp
int StrToInt(string str) {
    int len = str.size();
    if (len == 0) return 0;//ä¸ºç©ºï¼Œç›´æ¥è¿”å›å³å¯
    int i = 0, flag = 1,isSingal = 0;// ç´¢å¼• æ­£è´Ÿå·æ ‡å¿—ä½  æ­£è´Ÿå·å‡ºç°æ¬¡æ•°
    long res = 0; //é»˜è®¤flag = 1ï¼Œæ­£æ•°
    while (i<len && str[i] == ' ') i++; //è‹¥strå…¨ä¸ºç©ºæ ¼ï¼Œstr[i] = '\0'(æœ€åä¸€ä¸ªi)
    if (i >= len) return 0;//å…¨éƒ¨éƒ½æ˜¯ç©ºæ ¼ï¼Œç›´æ¥è¿”å›å§
    if (i < len && str[i] == '-') { flag = -1; ++i; isSingal++; }
    if (i < len && str[i] == '+') { ++i; ++isSingal; }
    if (isSingal > 1) return 0;
    for (  ; i < len ; ++i) {
        if(str[i]<'0' || str[i] > '9') return 0;
        res = res * 10 + (str[i] - '0');
        if (res >= INT_MAX && flag == 1) return  INT_MAX;
        if (res > INT_MAX && flag == -1) return  INT_MIN;
    }
    return flag * res;

}
~~~



**3ã€æœ‰å¾ˆå¤šè¦æ³¨æ„çš„åœ°æ–¹**

~~~cpp
int StrToInt(string str) {
	
	int len = str.size();
	if (len == 0) return 0;
	int  flag=1,singal=0, i = 0;
	long long num = 0;
	while (i < len && str[i] == ' ') i++;//å¯èƒ½ä¸€ç›´ä¸ºç©ºæˆ–è€…å‰é¢è‹¥å¹²éƒ½æ˜¯ ç©ºæ ¼ï¼Œå¤„ç†ç©ºæ ¼
	if (i >= len) return 0;//ä¸€ç›´ä¸ºç©ºåˆ™è¿”å›0
	if (str[i] == '-') { flag = -1; singal++; ++i; }//ç¬¦å·åˆ¤æ–­ï¼ŒåŒæ—¶åƒä¸‡è®°å¾— ++i
	if (str[i] == '+') { singal++; ++i; }//æ­£å·åˆ¤æ–­ ,++ i
	if (singal > 1) return 0;//å¦‚æœå‡ºç°ä¸¤ä¸ªç¬¦å·ï¼Œåˆ™æ˜¯ä¸åˆæ³•çš„æ•°å­—è¡¨è¾¾äº† -+45è¿™æ ·çš„æ•°å­—


	for (; i < len; ++i) {
		if (str[i]<'0' || str[i]>'9') return 0;// æ˜¯å¦æœ‰ä¸åˆæ³•æ•°å­—å‡ºç° æ¯”å¦‚12a454
		else {
			num = num * 10 + str[i] - '0';
			if (num >= INT_MAX && flag==1) return INT_MAX;//æ³¨æ„è¿™é‡Œçš„è¡¨è¾¾ è¾“å…¥å¦‚æœæ˜¯ INT_MAXä¹Ÿå°±æ˜¯ 2147483647 ï¼Œå°±è¿˜å¥½
			if (num > INT_MAX && flag==-1) return INT_MIN;//ä½†æ˜¯å¦‚æœè¾“å…¥æ˜¯ INY_MIN ä¹Ÿå°±æ˜¯ -2147483647-1 = -2147483648çš„è¯ï¼Œ
															// numå› ä¸ºæ˜¯æ­£æ•°è¡¨è¾¾ï¼Œæ‰€ä»¥å¿…é¡»num>INT_MAXæ‰èƒ½æ­£ç¡®åˆ¤æ–­äº†
		}

	}
	
	return num*flag;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€è¿™ç§åšæ³•æ›´åŠ ç¨³å¦¥**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š376k

~~~cpp
int StrToInt(string str) {
    int len = str.size();
    if(len == 0) return 0;
    int i = 0,flag = 1,isSignal = 0;
    long res = 0;
    while(i<len && str[i] == ' ') i++;//é¦–å…ˆè·³è¿‡å…¨éƒ¨çš„ç©ºæ ¼
    if(i >= len) return 0;//å…¨éƒ¨éƒ½æ˜¯ç©ºæ ¼ä¹Ÿä¸è¡Œ
    while(i<len && (str[i] == '-' || str[i] == '+'))  {//åˆ¤æ–­æ ‡å¿—ä½
        if(str[i] == '-') flag = -1;
        i++;
        isSignal++;
        if(isSignal > 1) return 0;//ä¸èƒ½å‡ºç°ä¸¤ä¸ªæ ‡å¿—ä½
    }

    for( ; i < len; ++i){
        if(str[i]>'9' || str[i]<'0') return 0;
        res = res*10 + str[i] - '0';
        if(res > INT_MAX && flag == 1) return INT_MAX;
        if(res > INT_MAX+1 && flag == -1)  return INT_MIN;// INT_MAX+1ä¼šæº¢å‡º  ï¼Œå°†1ç§»åˆ°å·¦è¾¹å»å°±å¯ä»¥äº†  

    }

    return flag * res;
}
~~~



**2ã€è€ƒè™‘è´Ÿæ•°æº¢å‡ºæƒ…å†µ**

è¿è¡Œæ—¶é—´ï¼š2ms å ç”¨å†…å­˜ï¼š492k

~~~cpp
int StrToInt(string str) {
    int len = str.size();
    if (len == 0) return 0;
    int i = 0, flag = 1, isSignal = 0;
    long res = 0;
    while (i < len && str[i] == ' ') i++;//é¦–å…ˆè·³è¿‡å…¨éƒ¨çš„ç©ºæ ¼
    if (i >= len) return 0;//å…¨éƒ¨éƒ½æ˜¯ç©ºæ ¼ä¹Ÿä¸è¡Œ
    while (i < len && (str[i] == '-' || str[i] == '+')) {
        if (str[i] == '-') flag = -1;
        i++;
        isSignal++;
        if (isSignal > 1) return 0;//ä¸èƒ½å‡ºç°ä¸¤ä¸ªæ ‡å¿—ä½
    }

    for (; i < len; ++i) {
        if (str[i] > '9' || str[i] < '0') return 0;
        res = res * 10 + str[i] - '0';  
        if (res > INT_MAX && flag == 1) return 0;//æ­£æ•°æº¢å‡º
        if (res-1 > INT_MAX  && flag == -1)  return 0;//è´Ÿæ•°æº¢å‡ºï¼Œè¿™ä¸ªæ—¶å€™å¯ä»¥å°† 1 ç§»åˆ°å·¦è¾¹æ¥ï¼ŒINT_MIN = -1 - 2çš„31æ¬¡æ–¹ æ˜¯æ¯”INT_MAXçš„ç»å¯¹å€¼å¤§ä¸€çš„

    }

    return flag * res;
}
~~~

<p id = "æ•°ç»„ä¸­é‡å¤çš„æ•°å­—"></p>
**No50ã€æ•°ç»„ä¸­é‡å¤çš„æ•°å­—**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&&tqId=11203&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

åœ¨ä¸€ä¸ªé•¿åº¦ä¸ºnçš„æ•°ç»„é‡Œçš„æ‰€æœ‰æ•°å­—éƒ½åœ¨0åˆ°n-1çš„èŒƒå›´å†…ã€‚ æ•°ç»„ä¸­æŸäº›æ•°å­—æ˜¯é‡å¤çš„ï¼Œä½†ä¸çŸ¥é“æœ‰å‡ ä¸ªæ•°å­—æ˜¯é‡å¤çš„ã€‚ä¹Ÿä¸çŸ¥é“æ¯ä¸ªæ•°å­—é‡å¤å‡ æ¬¡ã€‚è¯·æ‰¾å‡ºæ•°ç»„ä¸­ç¬¬ä¸€ä¸ªé‡å¤çš„æ•°å­—ã€‚ ä¾‹å¦‚ï¼Œå¦‚æœè¾“å…¥é•¿åº¦ä¸º7çš„æ•°ç»„{2,3,1,0,2,5,3}ï¼Œé‚£ä¹ˆå¯¹åº”çš„è¾“å‡ºæ˜¯ç¬¬ä¸€ä¸ªé‡å¤çš„æ•°å­—2ã€‚

**è¿”å›æè¿°ï¼š**

å¦‚æœæ•°ç»„ä¸­æœ‰é‡å¤çš„æ•°å­—ï¼Œå‡½æ•°è¿”å›trueï¼Œå¦åˆ™è¿”å›falseã€‚

å¦‚æœæ•°ç»„ä¸­æœ‰é‡å¤çš„æ•°å­—ï¼ŒæŠŠé‡å¤çš„æ•°å­—æ”¾åˆ°å‚æ•°duplication[0]ä¸­ã€‚ï¼ˆps:duplicationå·²ç»åˆå§‹åŒ–ï¼Œå¯ä»¥ç›´æ¥èµ‹å€¼ä½¿ç”¨ã€‚ï¼‰



**1ã€ç”¨unordered_mapä¿å­˜å³å¯**

~~~cpp
bool duplicate(int numbers[], int length, int* duplication) {
	unordered_map<int, int> unmp;
	unmp.reserve(length);
	for (int i = 0; i < length; ++i) {
		if (unmp.find(numbers[i]) == unmp.end()) {
			unmp.insert({ numbers[i],1 });
		}
		else
		{
			*duplication = numbers[i];
			return true;
		}
	}
	return false;
}
~~~



**2ã€å‡å°‘å†…å­˜ï¼Œé™ä½å†…å­˜å¤æ‚åº¦**

ç”¨ vector\<char>æ¥å­˜ 

~~~cpp
bool duplicate(int numbers[], int length, int* duplication) {
    vector<bool> result(length,false);
    for (int i = 0; i < length; ++i) {
        if (result[numbers[i]] == false) {
            result[numbers[i]] = true;
        }
        else
        {
            duplication[0] = numbers[i];
            return true;
        }
    }
    return false;
}
~~~



**3ã€ä¸å ç”¨ä»»ä½•ç©ºé—´çš„ä¸€ç§åšæ³•**

é¢˜ç›®é‡Œå†™äº†æ•°ç»„é‡Œæ•°å­—çš„èŒƒå›´ä¿è¯åœ¨0 ~ n-1   ä¹‹é—´ï¼Œæ‰€ä»¥å¯ä»¥åˆ©ç”¨ç°æœ‰æ•°ç»„è®¾ç½®æ ‡å¿—ï¼Œå½“ä¸€ä¸ªæ•°å­—è¢«è®¿é—®è¿‡åï¼Œå¯ä»¥è®¾ç½®å¯¹åº”ä½ä¸Šçš„æ•° +   nï¼Œä¹‹åå†é‡åˆ°ç›¸åŒçš„æ•°æ—¶ï¼Œä¼šå‘ç°å¯¹åº”ä½ä¸Šçš„æ•°å·²ç»å¤§äºç­‰äºnäº†ï¼Œé‚£ä¹ˆç›´æ¥è¿”å›è¿™ä¸ªæ•°å³å¯ã€‚  

~~~cpp
bool duplicate(int numbers[], int length, int* duplication) {
	for (int i = 0; i < length; ++i) {
		int index = numbers[i];
		if (index >= length) index -= length;
		if (numbers[index] >= length) {
			duplication[0] = index;
			return true;
		}
		numbers[index] += length;
	}
	return false;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€å¸¸è§„åšæ³•å°±æ˜¯å“ˆå¸Œè¡¨ï¼Œä½¿ç”¨ä¸€ä¸ªvectorçš„boolå‹æ•°ç»„ä¼šèŠ‚çº¦ä¸å°‘ç©ºé—´**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š508k

~~~cpp
bool duplicate(int numbers[], int length, int* duplication) {
    vector<bool> result(length,false);
    for (int i = 0; i < length; ++i) {
        if (result[numbers[i]] == false) {
            result[numbers[i]] = true;
        }
        else
        {
            duplication[0] = numbers[i];
            return true;
        }
    }
    return false;
    }
~~~



**2ã€å¦ä¸€ç§åŸåœ°åšæ³•**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š476k

~~~cpp
bool duplicate(int numbers[], int length, int* duplication) {
    for(int i = 0;i < length; ++i){//è¿™ä¸ªæ–¹æ³•å¦™åœ¨å¯¹äºä¾æ¬¡éå†è¿‡çš„æ¯ä¸ªæ•°ï¼Œéƒ½èƒ½åœ¨æ•°ç»„é‡Œè®°å¿†å®ƒå‡ºç°è¿‡äº†ã€‚
        //æ¯”å¦‚{2,2,1,0}ï¼Œç¬¬ä¸€æ¬¡å¾ªç¯index = 2,a[2]=a[2] + 4 = 5,è¿™æ ·ï¼Œa[2]=5 > æ•°ç»„é•¿åº¦4,å°±è¯´æ˜2è¿™ä¸ªæ•°å­—å‡ºç°è¿‡äº†ã€‚
        int index = numbers[i]%length;
        if( numbers[index] >= length){
            duplication[0] = index;
            return true;
        }
        numbers[index] += length;
    }

    return false;
}
~~~

æ³¨é‡Šï¼šå’ŒTop100ä¸­ [448](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/) å¾ˆåƒï¼Œåšæ³•å·®ä¸å¤š

<p id = "æ„å»ºä¹˜ç§¯æ•°ç»„"></p>


**No51ã€æ„å»ºä¹˜ç§¯æ•°ç»„**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&&tqId=11204&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ç»™å®šä¸€ä¸ªæ•°ç»„A[0,1,...,n-1],è¯·æ„å»ºä¸€ä¸ªæ•°ç»„B[0,1,...,n-1],å…¶ä¸­Bä¸­çš„å…ƒç´ B[i]=A[0]\*A[1]\*...\*A[i-1]\*A[i+1]\*...\*A[n-1]ï¼Œä¸èƒ½ä½¿ç”¨é™¤æ³•ã€‚

ï¼ˆæ³¨æ„ï¼šè§„å®šB[0] = A[1] * A[2] * ... * A[n-1]ï¼ŒB[n-1] = A[0] * A[1] * ... * A[n-2];ï¼‰

å¯¹äºAé•¿åº¦ä¸º1çš„æƒ…å†µï¼ŒBæ— æ„ä¹‰ï¼Œæ•…è€Œæ— æ³•æ„å»ºï¼Œå› æ­¤è¯¥æƒ…å†µä¸ä¼šå­˜åœ¨ã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
[1,2,3,4,5]
~~~
**è¿”å›å€¼**

~~~
[120,60,40,30,24]
~~~



**1ã€æš´åŠ›æ³•**

~~~cpp
vector<int> multiply(const vector<int>& A) {
	vector<int> B;
	for (int i = 0; i < A.size(); ++i) {

		int temp = 1;
		for (int j = 0; j < A.size(); ++j) {
			if (j != i) temp *= A[j];
		}
		B.push_back(temp);
	}
	return B;
}
~~~



**2ã€ä¸€ç§è¶…çº§ç²¾å¦™çš„è§£æ³•ï¼Œå¹çˆ†äº†**

~~~cpp
vector<int> multiply(const vector<int>& A) {
	int len = A.size();
	vector<int> B(len,0);
	int temp = 1;
	for (int i = 0; i <len; temp*=A[i],++i) {

		B[i] = temp;
	}

	temp = 1;
	for (int i = len-1; i >= 0; temp *= A[i], --i) {

		B[i] = B[i]*temp;
	}
	return B;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€é‡åˆ°ä¸€ç‚¹é—®é¢˜ï¼Œè¿˜æ²¡æœ‰å¾ˆé¡ºåˆ©çš„å†™å‡ºæ¥**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š376k

~~~cpp
    vector<int> multiply(const vector<int>& A) {
    
	if (A.size() <= 1) return vector<int>();
	int len = A.size();
	vector<int> B(len, 1);
	int left = A[0], right = A[len-1];
	for (int i = 1; i < len; ++i) {//è€Œè¿™é‡Œè¦ä»ç¬¬äºŒä¸ªå¼€å§‹
		B[i] = left;
		left = left * A[i];
	}

	for (int i = len - 2; i >= 0; --i) {//è¿™é‡Œè¦ä»å€’æ•°ç¬¬äºŒä¸ªå¼€å§‹
		B[i] = B[i] * right;
		right = right * A[i];
	}

	return std::move(B);
    }
~~~

<p id = "æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…"></p>


**No52ã€æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&&tqId=11205&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¯·å®ç°ä¸€ä¸ªå‡½æ•°ç”¨æ¥åŒ¹é…åŒ…æ‹¬'.'å’Œ'*'çš„æ­£åˆ™è¡¨è¾¾å¼ã€‚æ¨¡å¼ä¸­çš„å­—ç¬¦'.'è¡¨ç¤ºä»»æ„ä¸€ä¸ªå­—ç¬¦ï¼Œè€Œ'*'è¡¨ç¤ºå®ƒå‰é¢çš„å­—ç¬¦å¯ä»¥å‡ºç°ä»»æ„æ¬¡ï¼ˆåŒ…å«0æ¬¡ï¼‰ã€‚ åœ¨æœ¬é¢˜ä¸­ï¼ŒåŒ¹é…æ˜¯æŒ‡å­—ç¬¦ä¸²çš„æ‰€æœ‰å­—ç¬¦åŒ¹é…æ•´ä¸ªæ¨¡å¼ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²"aaa"ä¸æ¨¡å¼"a.a"å’Œ"ab*ac*a"åŒ¹é…ï¼Œä½†æ˜¯ä¸"aa.a"å’Œ"ab*a"å‡ä¸åŒ¹é…

**ç¤ºä¾‹1**

**è¾“å…¥**

```
"aaa","a*a"
```

**è¿”å›å€¼**

```
true
```

**1ã€å¤ªä»–å—éš¾äº†ï¼Œä¸ä¼šä¸ä¼šï¼Œè€å­ä¸ä¼š**

~~~cpp
//å­—ç¬¦ä¸²"aaa"ä¸æ¨¡å¼"a.a"å’Œ"ab*ac*a"åŒ¹é…ï¼Œä½†æ˜¯ä¸"aa.a"å’Œ"ab*a"å‡ä¸åŒ¹é…
bool match(char* str, char* pattern)
{
	int len1 = strlen(str), len2 = strlen(pattern);
	int low1 = 0, low2 = 0;
	while (low1 < len1 && low2 < len2) {
		if (str[low1] == pattern[low2]) {

			if (low2 + 1 < len2 && pattern[low2 + 1] == '*') {
				while (str[low1] == pattern[low2]) { low1++; }
				low2++;//è·³è¿‡ * 
			}
			else {
				low1++;
				low2++;
			}
			
		}
		else if (str[low1] != pattern[low2]) {
			cout << "111" << endl;
			if (pattern[low2] == '.' && low2 + 1 < len2 && pattern[low2 + 1] != '*') { low1++; low2++; }
			else if (pattern[low2] == '.' && low2 + 1 < len2 && pattern[low2 + 1] == '*')  return true;
			else if (low2 + 1 < len2 && pattern[low2 + 1] == '*') {//å‡ºç° aa ä¸ ab*aè¿™æ ·çš„æƒ…å†µ
				low2+=2;
			}
				return false;
		}
	}
	return low1 == len1 && low2 == len2;
}
~~~



**2ã€çœ‹çš„æ€è·¯**

â€‹       è§£è¿™é¢˜éœ€è¦æŠŠé¢˜æ„ä»”ç»†ç ”ç©¶æ¸…æ¥šï¼Œåæ­£æˆ‘è¯•äº†å¥½å¤šæ¬¡æ‰æ˜ç™½çš„ã€‚

â€‹       é¦–å…ˆï¼Œ**è€ƒè™‘ç‰¹æ®Šæƒ…å†µ**ï¼š 1>ä¸¤ä¸ªå­—ç¬¦ä¸²éƒ½ä¸ºç©ºï¼Œè¿”å›true 2>å½“ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä¸ç©ºï¼Œè€Œç¬¬äºŒä¸ªå­—ç¬¦ä¸²ç©ºäº†ï¼Œè¿”å›falseï¼ˆå› ä¸ºè¿™æ ·ï¼Œå°±æ— æ³• åŒ¹é…æˆåŠŸäº†,è€Œå¦‚æœç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ç©ºäº†ï¼Œç¬¬äºŒä¸ªå­—ç¬¦ä¸²éç©ºï¼Œè¿˜æ˜¯å¯èƒ½åŒ¹é…æˆ åŠŸçš„ï¼Œæ¯”å¦‚ç¬¬äºŒä¸ªå­—ç¬¦ä¸²æ˜¯â€œaaaaâ€,ç”±äºâ€˜â€™ä¹‹å‰çš„å…ƒç´ å¯ä»¥å‡ºç°0æ¬¡ï¼Œ æ‰€ä»¥æœ‰å¯èƒ½åŒ¹é…æˆåŠŸï¼‰ ä¹‹åå°±å¼€å§‹åŒ¹é…ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œè¿™é‡Œæœ‰ä¸¤ç§å¯èƒ½ï¼š**åŒ¹é…æˆåŠŸæˆ–åŒ¹é…å¤±è´¥**ã€‚

â€‹      ä½†è€ƒè™‘åˆ°pattern ä¸‹ä¸€ä¸ªå­—ç¬¦å¯èƒ½æ˜¯â€˜â€™ï¼Œ è¿™é‡Œæˆ‘ä»¬åˆ†ä¸¤ç§æƒ…å†µè®¨è®ºï¼špatternä¸‹ä¸€ä¸ªå­—ç¬¦ä¸ºâ€˜â€™æˆ– ä¸ä¸ºâ€˜â€™ï¼š 1>patternä¸‹ä¸€ä¸ªå­—ç¬¦ä¸ä¸ºâ€˜â€™ï¼šè¿™ç§æƒ…å†µæ¯”è¾ƒç®€å•ï¼Œç›´æ¥åŒ¹é…å½“å‰å­—ç¬¦ã€‚å¦‚æœ åŒ¹é…æˆåŠŸï¼Œç»§ç»­åŒ¹é…ä¸‹ä¸€ä¸ªï¼›å¦‚æœåŒ¹é…å¤±è´¥ï¼Œç›´æ¥è¿”å›falseã€‚

â€‹      æ³¨æ„è¿™é‡Œçš„ â€œåŒ¹é…æˆåŠŸâ€ï¼Œé™¤äº†ä¸¤ä¸ªå­—ç¬¦ç›¸åŒçš„æƒ…å†µå¤–ï¼Œè¿˜æœ‰ä¸€ç§æƒ…å†µï¼Œå°±æ˜¯patternçš„ å½“å‰å­—ç¬¦ä¸ºâ€˜.â€™,åŒæ—¶strçš„å½“å‰å­—ç¬¦ä¸ä¸ºâ€˜\0â€™ã€‚ 2>patternä¸‹ä¸€ä¸ªå­—ç¬¦ä¸ºâ€˜â€™æ—¶ï¼Œç¨å¾®å¤æ‚ä¸€äº›ï¼Œå› ä¸ºâ€˜â€™å¯ä»¥ä»£è¡¨0ä¸ªæˆ–å¤šä¸ªã€‚ 

â€‹      è¿™é‡ŒæŠŠè¿™äº›æƒ…å†µéƒ½è€ƒè™‘åˆ°ï¼š a>å½“â€˜â€™åŒ¹é…0ä¸ªå­—ç¬¦æ—¶ï¼Œstrå½“å‰å­—ç¬¦ä¸å˜ï¼Œpatternå½“å‰å­—ç¬¦åç§»ä¸¤ä½ï¼Œ è·³è¿‡è¿™ä¸ªâ€˜â€™ç¬¦å·ï¼› b>å½“â€˜â€™åŒ¹é…1ä¸ªæˆ–å¤šä¸ªæ—¶ï¼Œstrå½“å‰å­—ç¬¦ç§»å‘ä¸‹ä¸€ä¸ªï¼Œpatternå½“å‰å­—ç¬¦ ä¸å˜ã€‚

   ï¼ˆè¿™é‡ŒåŒ¹é…1ä¸ªæˆ–å¤šä¸ªå¯ä»¥çœ‹æˆä¸€ç§æƒ…å†µï¼Œå› ä¸ºï¼šå½“åŒ¹é…ä¸€ä¸ªæ—¶ï¼Œ ç”±äºstrç§»åˆ°äº†ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼Œè€Œpatternå­—ç¬¦ä¸å˜ï¼Œå°±å›åˆ°äº†ä¸Šè¾¹çš„æƒ…å†µaï¼› å½“åŒ¹é…å¤šäºä¸€ä¸ªå­—ç¬¦æ—¶ï¼Œç›¸å½“äºä»strçš„ä¸‹ä¸€ä¸ªå­—ç¬¦ç»§ç»­å¼€å§‹åŒ¹é…ï¼‰ ä¹‹åå†å†™ä»£ç å°±å¾ˆç®€å•äº†ã€‚

~~~cpp
 bool match(char* str, char* pattern)
    {
        if (*str == '\0' && *pattern == '\0')
            return true;
        if (*str != '\0' && *pattern == '\0')
            return false;
        //if the next character in pattern is not '*'
        if (*(pattern+1) != '*')
        {
            if (*str == *pattern || (*str != '\0' && *pattern == '.'))
                return match(str+1, pattern+1);
            else
                return false;
        }
        //if the next character is '*'
        else
        {
            if (*str == *pattern || (*str != '\0' && *pattern == '.'))
                return match(str, pattern+2) || match(str+1, pattern);
            else
                return match(str, pattern+2);
        }
    }
~~~

**è®²è§£:**

é¦–å…ˆèƒ½å¤ŸåŒ¹é…çš„æƒ…å†µå°±æ˜¯ä¸¤ç§ï¼š1ã€ä¸¤è€…ç›¸ç­‰ï¼Œ2ã€s!='\0' && p=='.'

åªæœ‰è¿™ä¸¤ç§æƒ…å†µ

1ã€p[1] != * ,é‚£ä¹ˆå¯èƒ½æ˜¯ baä¸.a æˆ–è€… ba baè¿™ä¸¤ç§å½¢å¼ï¼Œé‚£å°±ç›´æ¥s+1 p+1ï¼Œé€’å½’åˆ°ä¸‹ä¸€å±‚ï¼Œå¦åˆ™å°±æ˜¯falseäº†

2ã€p[1] == *,æœ‰ * è¿‡æ¥æ£ä¹±ï¼Œå¦‚æœåŒ¹é…çš„è¯ä¹Ÿå°±æ˜¯ä¸¤è€…ç›¸ç­‰æˆ–è€…**s!=â€˜\0â€™å¹¶ä¸”p==â€˜.â€™çš„è¯ï¼Œå‰è€…æ¯”å¦‚ abc ä¸ a****abcç›´æ¥ s p+2 ï¼Œè¦è·³è¿‡patternçš„åŒ¹é…éƒ¨åˆ†ï¼Œå› ä¸ºæœ‰ä¸ª æ˜Ÿå· *      åè€…å°±æ˜¯aaabc ä¸ .*bcè¿™æ ·ï¼Œç›´æ¥s+1,pï¼Œså‘å‰èµ°ä¸€æ­¥é€æ¸é€’å½’åˆ°ä¸‹æ¬¡

å¦‚æœä¸åŒ¹é…çš„è¯é‚£å°±æ˜¯ abc  b*abcè¿™æ ·çš„ï¼Œpå‘å‰èµ°ä¸¤æ­¥ï¼Œèµ°åˆ°åé¢çš„på†å»åŒ¹é…



**3ã€å¦ä¸€ç§å†™æ³•**

~~~cpp
/*
è¦åˆ†ä¸ºå‡ ç§æƒ…å†µï¼šï¼ˆçŠ¶æ€æœºï¼‰
åŒ¹é…åªå¯èƒ½æ˜¯ï¼šä¸¤è€…ç›¸ç­‰ æˆ–è€…  Sï¼=â€˜\0â€™ && p == .

ï¼ˆ1ï¼‰å½“ç¬¬äºŒä¸ªå­—ç¬¦ä¸ä¸ºâ€˜*â€™æ—¶ï¼šåŒ¹é…å°±æ˜¯å°†å­—ç¬¦ä¸²å’Œæ¨¡å¼çš„æŒ‡é’ˆéƒ½ä¸‹ç§»ä¸€ä¸ªï¼Œä¸åŒ¹é…å°±ç›´æ¥è¿”å›false
ï¼ˆ2ï¼‰å½“ç¬¬äºŒä¸ªå­—ç¬¦ä¸º'*'æ—¶ï¼š
        åŒ¹é…ï¼š
                a.å­—ç¬¦ä¸²ä¸‹ç§»ä¸€ä¸ªï¼Œæ¨¡å¼ä¸åŠ¨  abc  a*bc
                c.å­—ç¬¦ä¸²ä¸åŠ¨ï¼Œæ¨¡å¼ä¸‹ç§»ä¸¤ä¸ª   abc  .*abcæˆ–è€… .*bc
        ä¸åŒ¹é…ï¼šå­—ç¬¦ä¸²ä¸‹ç§»ä¸åŠ¨ï¼Œæ¨¡å¼ä¸‹ç§»ä¸¤ä¸ª   abc  b*abc
ææ¸…æ¥šè¿™å‡ ç§çŠ¶æ€åï¼Œç”¨é€’å½’å®ç°å³å¯ï¼š
*/
class Solution {
public:
    bool match(char* str, char* pattern){
        if(str[0]=='\0'&&pattern[0]=='\0')
            return true;
        else if(str[0]!='\0'&&pattern[0]=='\0')
            return false;
        if(pattern[1]!='*'){
            if(str[0]==pattern[0]||(pattern[0]=='.'&&str[0]!='\0'))
                return match(str+1,pattern+1);
            else
                return false;
        }
        else{
            if(str[0]==pattern[0]||(pattern[0]=='.'&&str[0]!='\0'))
                return match(str,pattern+2)||match(str+1,pattern);
            else
                return match(str,pattern+2);
        }
    }
};
~~~



**äºŒåˆ·ï¼š**

**1ã€å¾ˆå¥½ï¼Œä¾ç„¶ä¸ä¼šï¼Œå“ˆå“ˆï¼Œé€’å½’çš„æ–¹æ³•**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š492k

~~~cpp
/*
è¦åˆ†ä¸ºå‡ ç§æƒ…å†µï¼šï¼ˆçŠ¶æ€æœºï¼‰
åŒ¹é…åªå¯èƒ½æ˜¯ï¼šä¸¤è€…ç›¸ç­‰ æˆ–è€…  Sï¼=â€˜\0â€™ && p == .

ï¼ˆ1ï¼‰å½“ç¬¬äºŒä¸ªå­—ç¬¦ä¸ä¸ºâ€˜*â€™æ—¶ï¼šåŒ¹é…å°±æ˜¯å°†å­—ç¬¦ä¸²å’Œæ¨¡å¼çš„æŒ‡é’ˆéƒ½ä¸‹ç§»ä¸€ä¸ªï¼Œä¸åŒ¹é…å°±ç›´æ¥è¿”å›false
ï¼ˆ2ï¼‰å½“ç¬¬äºŒä¸ªå­—ç¬¦ä¸º'*'æ—¶ï¼š
        åŒ¹é…ï¼š
                a.å­—ç¬¦ä¸²ä¸‹ç§»ä¸€ä¸ªï¼Œæ¨¡å¼ä¸åŠ¨  abc  a*bc
                c.å­—ç¬¦ä¸²ä¸åŠ¨ï¼Œæ¨¡å¼ä¸‹ç§»ä¸¤ä¸ª   abc  .*abcæˆ–è€… .*bc
        ä¸åŒ¹é…ï¼šå­—ç¬¦ä¸²ä¸‹ç§»ä¸åŠ¨ï¼Œæ¨¡å¼ä¸‹ç§»ä¸¤ä¸ª   abc  b*abc
ææ¸…æ¥šè¿™å‡ ç§çŠ¶æ€åï¼Œç”¨é€’å½’å®ç°å³å¯ï¼š
*/
class Solution {
public:
    bool match(char* str, char* pattern){
        if(str[0]=='\0'&&pattern[0]=='\0')
            return true;
        else if(str[0]!='\0'&&pattern[0]=='\0')
            return false;
        if(pattern[1]!='*'){
            if(str[0]==pattern[0]||(pattern[0]=='.'&&str[0]!='\0'))
                return match(str+1,pattern+1);
            else
                return false;
        }
        else{
            if(str[0]==pattern[0]||(pattern[0]=='.'&&str[0]!='\0'))
                return match(str,pattern+2)||match(str+1,pattern);
            else
                return match(str,pattern+2);
        }
    }
};
~~~

<p id = "è¡¨ç¤ºæ•°å€¼çš„å­—ç¬¦ä¸²"></p>


**No53ã€è¡¨ç¤ºæ•°å€¼çš„å­—ç¬¦ä¸²**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank"> [ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&&tqId=11206&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¯·å®ç°ä¸€ä¸ªå‡½æ•°ç”¨æ¥åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦è¡¨ç¤ºæ•°å€¼ï¼ˆåŒ…æ‹¬æ•´æ•°å’Œå°æ•°ï¼‰ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²"+100","5e2","-123","3.1416"å’Œ"-1E-16"éƒ½è¡¨ç¤ºæ•°å€¼ã€‚ ä½†æ˜¯"12e","1a3.14","1.2.3","+-5"å’Œ"12e+4.3"éƒ½ä¸æ˜¯ã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

```
"123.45e+6"
```

**è¿”å›å€¼**

```
true
```

**ç¤ºä¾‹2**

**è¾“å…¥**

```
"1.2.3"
```

**è¿”å›å€¼**

```
false
```

**1ã€çœ‹çš„å†™æ³•ï¼Œå¾ˆå¥½**

~~~cpp
bool isNumeric(char* string)
{
    // æ­£åæ ‡è®°ç¬¦å·ã€å°æ•°ç‚¹ã€eæ˜¯å¦å‡ºç°è¿‡
    bool sign = false, decimal = false, hasE = false;
    for (int i = 0; i < strlen(string); ++i) {
        if (string[i] == 'e' || string[i] == 'E') {
            if (i == strlen(string) - 1) return false; // eåé¢ä¸€å®šè¦æ¥æ•°å­—
            if (hasE) return false;  // ä¸èƒ½åŒæ—¶å­˜åœ¨ä¸¤ä¸ªe
            hasE = true;
        }
        else if (string[i] == '+' || string[i] == '-') {
            // ç¬¬äºŒæ¬¡å‡ºç°+-ç¬¦å·ï¼Œåˆ™å¿…é¡»ç´§æ¥åœ¨eä¹‹å
            if (sign && string[i - 1] != 'e' && string[i - 1] != 'E') return false;
            // ç¬¬ä¸€æ¬¡å‡ºç°+-ç¬¦å·ï¼Œä¸”ä¸æ˜¯åœ¨å­—ç¬¦ä¸²å¼€å¤´ï¼Œåˆ™ä¹Ÿå¿…é¡»ç´§æ¥åœ¨eä¹‹å
            if (!sign && i > 0 && string[i - 1] != 'e' && string[i - 1] != 'E') return false;
            sign = true;
        }
        else if (string[i] == '.') {
            // eåé¢ä¸èƒ½æ¥å°æ•°ç‚¹ï¼Œå°æ•°ç‚¹ä¸èƒ½å‡ºç°ä¸¤æ¬¡
            if (hasE || decimal) return false;
            decimal = true;
        }
        else if (string[i] < '0' || string[i] > '9') // ä¸åˆæ³•å­—ç¬¦
            return false;
    }
    return true;

}
~~~



**äºŒåˆ·ï¼š**

**1ã€è¿˜æ˜¯ä¸ä¼š**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š380k

1ã€eåé¢å¿…é¡»æ˜¯æ•°å­— åªèƒ½æœ‰ä¸€ä¸ªe

2ã€æ­£è´Ÿå·åªèƒ½å‡ºç°ä¸€æ¬¡ï¼Œå³ä½¿å‡ºç°ç¬¬äºŒæ¬¡äº†ï¼Œé‚£ä»–çš„å‰é¢ä¹Ÿè¦æ˜¯ e/ E ,å‡ºç°ç¬¬ä¸€æ¬¡çš„è¯å¿…é¡»åœ¨å¼€å¤´æˆ–è€…åœ¨Eçš„åé¢

3ã€å°æ•°ç‚¹ä¹Ÿåªèƒ½å‡ºç°ä¸€æ¬¡ï¼Œä¸”ä¸èƒ½å†Eçš„åé¢

4ã€åˆæ³•å­—ç¬¦çš„åˆ¤æ–­ é™¤äº† e +-  . ä»¥åŠæ•°å­—ä¹‹å¤– å…¶ä½™çš„å­—ç¬¦éƒ½æ˜¯é”™çš„ã€‚

~~~cpp
bool isNumeric(char* string)
{
    bool sign = false, decimal = false,hasE = false;//æ­£è´Ÿå· å°æ•°ç‚¹ e
    int len = strlen(string);
    for(int i = 0; i < len; ++i){
        if(string[i] == 'e' || string[i] == 'E'){
            if( i == len - 1) return false;//e çš„åé¢å¿…é¡»è¦å‡ºç°æ•°å­— å¯¹åº” 12e
            if(hasE) return false;//åªèƒ½æœ‰ä¸€ä¸ªe
            hasE = true;

        }else if(string[i] == '+' || string[i] == '-'){                
            if(!sign && i>0 && string[i-1] !='e' && string[i-1] != 'E')// 12e+5 å¦‚æœç¬¬ä¸€æ¬¡å‡ºç°ï¼Œä¸”ä¸æ˜¯åœ¨å¼€å¤´ï¼Œé‚£ä¹ˆä¹Ÿè¦ç´§è·Ÿåœ¨e/Eä¹‹å
                return false;
            if(sign && string[i-1] !='e' && string[i-1] !='E')// +5e-6  ç¬¬äºŒæ¬¡å‡ºç°ï¼Œé‚£ä¹Ÿè¦è·Ÿåœ¨ e/Eä¹‹å
                return false;
            sign = true;
        }else if(string[i] == '.'){
            if(decimal) return false; 
            if(hasE) return false;// Eåé¢ä¸èƒ½è·Ÿå°æ•°ç‚¹  12e+4.3

            decimal = true;

        }else if(string[i] < '0' || string[i] > '9')//ä¸åˆæ³•å­—ç¬¦
            return false;

    }
    return true;
}
~~~

<p id = "å­—ç¬¦æµä¸­ç¬¬ä¸€ä¸ªä¸é‡å¤çš„å­—ç¬¦"></p>


**No54ã€å­—ç¬¦æµä¸­ç¬¬ä¸€ä¸ªä¸é‡å¤çš„å­—ç¬¦**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&&tqId=11207&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¯·å®ç°ä¸€ä¸ªå‡½æ•°ç”¨æ¥æ‰¾å‡ºå­—ç¬¦æµä¸­ç¬¬ä¸€ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦ã€‚ä¾‹å¦‚ï¼Œå½“ä»å­—ç¬¦æµä¸­åªè¯»å‡ºå‰ä¸¤ä¸ªå­—ç¬¦"go"æ—¶ï¼Œç¬¬ä¸€ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦æ˜¯"g"ã€‚å½“ä»è¯¥å­—ç¬¦æµä¸­è¯»å‡ºå‰å…­ä¸ªå­—ç¬¦â€œgoogle"æ—¶ï¼Œç¬¬ä¸€ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦æ˜¯"l"ã€‚

```
å¦‚æœå½“å‰å­—ç¬¦æµæ²¡æœ‰å­˜åœ¨å‡ºç°ä¸€æ¬¡çš„å­—ç¬¦ï¼Œè¿”å›#å­—ç¬¦ã€‚
```



**1ã€è‡ªå·±æƒ³çš„ä¸€ç§æ–¹æ³•**

~~~cpp
class Solution
{
public:
	//Insert one char from stringstream
	void Insert(char ch)
	{
		v.push_back(ch);
	}
	//return the first appearence once char in current stringstream
	char FirstAppearingOnce()
	{
        if(v.empty())  return '#';
		/*int len = v.size();*/
		for (auto &ch:v) {
			if (count(v.begin(), v.end(), ch) == 1) return ch;
		}
		return '#';
	}

	vector<char> v;
};
~~~



**2ã€å€ŸåŠ©ä¸€ä¸ªunordered_map**

è¿™ä¸ªæ–¹æ³•è¦æ…¢ä¸€äº›

~~~cpp
class Solution
{
public:
	//Insert one char from stringstream
	void Insert(char ch)
	{
		v.push_back(ch);
		unmp[ch]++;
	}
	//return the first appearence once char in current stringstream
	char FirstAppearingOnce()
	{
		for (auto &ch:v) {
			if (unmp[ch] == 1) return ch;
		}
		return '#';
	}

	vector<char> v;
	unordered_map<char, int> unmp;
};
~~~



**äºŒåˆ·ï¼š**

**1ã€ç®€å•çš„æ–¹æ³•ï¼Œå¤æ‚åº¦ç¨å¾®é«˜ä¸€äº›**

è¿è¡Œæ—¶é—´ï¼š4ms  å ç”¨å†…å­˜ï¼š376k

~~~cpp
class Solution
{
public:
	//Insert one char from stringstream
	void Insert(char ch)
	{
		v.push_back(ch);
	}
	//return the first appearence once char in current stringstream
	char FirstAppearingOnce()
	{
		for (auto &ch:v) {
			if (count(v.begin(),v.end(),ch) == 1) return ch;
		}
		return '#';
	}

	vector<char> v;

};
~~~



**2ã€å€ŸåŠ©ä¸€ä¸ªå“ˆå¸Œè¡¨ï¼Œç¨å¾®å¿«ä¸€ç‚¹äº†**

è¿è¡Œæ—¶é—´ï¼š4ms  å ç”¨å†…å­˜ï¼š376k

~~~cpp
class Solution
{
public:
	//Insert one char from stringstream
	void Insert(char ch)
	{
		v.push_back(ch);
        result[ch]++;
	}
	//return the first appearence once char in current stringstream
	char FirstAppearingOnce()
	{
		for (auto &ch:v) {
			if (result[ch] == 1) return ch;
		}
		return '#';
	}

	vector<char> v;
    unordered_map<char,int> result;

};
~~~

<p id = "é“¾è¡¨ä¸­ç¯çš„å…¥å£ç»“ç‚¹"></p>


**No55ã€é“¾è¡¨ä¸­ç¯çš„å…¥å£ç»“ç‚¹**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&&tqId=11208&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ç»™ä¸€ä¸ªé“¾è¡¨ï¼Œè‹¥å…¶ä¸­åŒ…å«ç¯ï¼Œè¯·æ‰¾å‡ºè¯¥é“¾è¡¨çš„ç¯çš„å…¥å£ç»“ç‚¹ï¼Œå¦åˆ™ï¼Œè¾“å‡ºnullã€‚



**1ã€è€åŠæ³•ï¼Œå€ŸåŠ©unordered_map**

~~~cpp
ListNode* EntryNodeOfLoop(ListNode* pHead)
{
	if (pHead == nullptr) return NULL;
	unordered_map<ListNode*, int> unmp;//æ³¨æ„æ˜¯ListNode*ï¼Œä¸æ˜¯ListNode
	while (pHead != NULL) {

		unmp[pHead]++;
		if (unmp[pHead] == 2) return pHead;
		pHead = pHead->next;
	}
	return NULL;
}
~~~

å€ŸåŠ©se'tå…¶å®ä¹Ÿå¯ä»¥ï¼Œä½†æ˜¯setå’Œmapåº•å±‚å…¶å®å·®ä¸å¤šï¼Œè€Œä¸”seté‡Œçš„ä¸¤ä¸ªå…ƒç´ ç±»å‹ç›¸åŒï¼Œsizeofï¼ˆlistnodeï¼‰è‚¯å®šæ¯” sizeofè¦å¤§

~~~cpp
ListNode* EntryNodeOfLoop(ListNode* pHead)
{
    set<ListNode*> s;
    ListNode* node = pHead;
    while(node!=NULL){
        if(s.insert(node).second)
            node = node->next;
        else
            return node;
    }
    return node;

}
~~~



**2ã€æœ‰ä¸ªå¿«æ…¢æŒ‡é’ˆçš„åšæ³•**

å…ˆè¯´ä¸ªå®šç†ï¼šä¸¤ä¸ªæŒ‡é’ˆä¸€ä¸ªfastã€ä¸€ä¸ªslowåŒæ—¶ä»ä¸€ä¸ªé“¾è¡¨çš„å¤´éƒ¨å‡ºå‘
fastä¸€æ¬¡èµ°2æ­¥ï¼Œslowä¸€æ¬¡èµ°ä¸€æ­¥ï¼Œå¦‚æœè¯¥é“¾è¡¨æœ‰ç¯ï¼Œä¸¤ä¸ªæŒ‡é’ˆå¿…ç„¶åœ¨ç¯å†…ç›¸é‡
æ­¤æ—¶åªéœ€è¦æŠŠå…¶ä¸­çš„ä¸€ä¸ªæŒ‡é’ˆé‡æ–°æŒ‡å‘é“¾è¡¨å¤´éƒ¨ï¼Œå¦ä¸€ä¸ªä¸å˜ï¼ˆè¿˜åœ¨ç¯å†…ï¼‰ï¼Œ
è¿™æ¬¡ä¸¤ä¸ªæŒ‡é’ˆä¸€æ¬¡èµ°ä¸€æ­¥ï¼Œç›¸é‡çš„åœ°æ–¹å°±æ˜¯å…¥å£èŠ‚ç‚¹ã€‚
è¿™ä¸ªå®šç†å¯ä»¥è‡ªå·±å»ç½‘ä¸Šçœ‹çœ‹è¯æ˜ã€‚

~~~C++
ListNode* EntryNodeOfLoop(ListNode* pHead)
{
    ListNode*fast=pHead,*low=pHead;
    while(fast&&fast->next){
        fast=fast->next->next;
        low=low->next;
        if(fast==low)
            break;
    }
    if(!fast||!fast->next)return NULL;
    low=pHead;//lowä»é“¾è¡¨å¤´å‡ºå‘
    while(fast!=low){//fastä»ç›¸é‡ç‚¹å‡ºå‘
        fast=fast->next;
        low=low->next;
    }
    return low;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€å¿«æ…¢æŒ‡é’ˆï¼Œå¸¸è§„é¢˜**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š376k

~~~cpp
ListNode* EntryNodeOfLoop(ListNode* pHead)
{

    if(pHead == nullptr || pHead->next == nullptr) return nullptr;
    ListNode*fast = pHead, *slow = pHead;
    while(fast != nullptr && fast->next != nullptr)
    {
        fast = fast->next->next;
        slow = slow->next;
        if(fast == slow) break;
    }

    if(fast == nullptr || fast->next == nullptr) return nullptr;
    slow = pHead;
    while(fast != slow){
        fast = fast->next;
        slow = slow->next;
    }
    return fast;      
}
~~~

<p id = "åˆ é™¤é“¾è¡¨ä¸­çš„é‡å¤ç»“ç‚¹"></p>


**No56ã€åˆ é™¤é“¾è¡¨ä¸­çš„é‡å¤ç»“ç‚¹**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&&tqId=11209&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

åœ¨ä¸€ä¸ªæ’åºçš„é“¾è¡¨ä¸­ï¼Œå­˜åœ¨é‡å¤çš„ç»“ç‚¹ï¼Œè¯·åˆ é™¤è¯¥é“¾è¡¨ä¸­é‡å¤çš„ç»“ç‚¹ï¼Œé‡å¤çš„ç»“ç‚¹ä¸ä¿ç•™ï¼Œè¿”å›é“¾è¡¨å¤´æŒ‡é’ˆã€‚ ä¾‹å¦‚ï¼Œé“¾è¡¨1->2->3->3->4->4->5 å¤„ç†åä¸º 1->2->5

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
{1,2,3,3,4,4,5}
~~~
**è¿”å›å€¼**

~~~
{1,2,5}
~~~



**1ã€çœŸçš„æ˜¯è¶…çº§ç¬¨ï¼Œæˆ‘æœäº†ï¼Œè°ƒè¯•äº†å¾ˆå¤šéæ‰é€šè¿‡çš„**

å¤§æ¦‚æ€æƒ³ï¼šé‡‡ç”¨vectorä¿å­˜é“¾è¡¨ä¸­çš„ä¸é‡å¤å…ƒç´ ï¼Œç„¶åå°†é“¾è¡¨ä»è¡¨å¤´å¼€å§‹æŒ¨ä¸ªå¯¹æ¯”ï¼Œä¸€æ ·å°±å°†å½“å‰ç»“ç‚¹ä¿å­˜ä¸‹æ¥ï¼Œç„¶åindex++ï¼Œä¸ä¸€æ ·å°±ç»§ç»­å‘ä¸‹éå†ï¼Œæ³¨æ„è¾¹ç•Œæ¡ä»¶ã€‚

~~~cpp
ListNode* deleteDuplication(ListNode* pHead)
{
    if (pHead == nullptr || pHead->next == nullptr) return pHead;
    ListNode* node = (ListNode*)malloc(sizeof(struct ListNode));
    node = pHead;
    vector<int> result;
    result.push_back(node->val);
    node = node->next;
    while (node != nullptr) {
        if (result.size()!=0 && result.back() == node->val) {
            while (node!=nullptr && result.back() == node->val) {
                node = node->next;
            }
            result.pop_back();
        }
        else if (result.size() == 0 || (result.size()!=0 && result.back()!=node->val))
        {
            result.push_back(node->val);
            node = node->next;
        }	
        else
            node = node->next;
    }

    if (result.size() == 0) {
        return nullptr;
    }
    node = pHead;
    int index = 0;
    int len = result.size();
    ListNode* resultNode = (ListNode*)malloc(sizeof(struct ListNode));
    while (node != nullptr) {
        if (index<len && node->val == result[index]) {
            index++;
            resultNode = node;
            break;

        } node = node->next;
    }
    pHead = resultNode;
    while (node != nullptr) {
        if (index < len && node->val == result[index]) {
            index++;
            pHead->next = node;
            pHead = pHead->next;

        } node = node->next;
    }
    pHead->next = nullptr;//æœ€åè¦è®¾ç½®å°¾ç‚¹ç»“æŸ
    return resultNode;
}
~~~



**2ã€åˆ«äººçš„æ€è·¯å’Œæ–¹æ³•ï¼Œä¸‰æŒ‡é’ˆæ³•ï¼Œå–åˆ°åŸæ¥æŒ‡é’ˆçš„å‰ä¸€ä¸ªæŒ‡é’ˆ**

1. é¦–å…ˆæ·»åŠ ä¸€ä¸ªå¤´èŠ‚ç‚¹ï¼Œä»¥æ–¹ä¾¿ç¢°åˆ°ç¬¬ä¸€ä¸ªï¼Œç¬¬äºŒä¸ªèŠ‚ç‚¹å°±ç›¸åŒçš„æƒ…å†µ

â€‹    2.è®¾ç½® pre ï¼ŒcuræŒ‡é’ˆï¼Œ preæŒ‡é’ˆæŒ‡å‘å½“å‰ç¡®å®šä¸é‡å¤çš„é‚£ä¸ªèŠ‚ç‚¹ï¼Œè€ŒlastæŒ‡é’ˆç›¸å½“äºå·¥ä½œæŒ‡é’ˆï¼Œä¸€ç›´å¾€åé¢æœç´¢ã€‚

~~~cpp
if (pHead == nullptr || pHead->next == nullptr) { return pHead; }
	ListNode *Head = (ListNode*)malloc(sizeof(struct ListNode));
	ListNode* pre = (ListNode*)malloc(sizeof(struct ListNode));
	ListNode* cur = (ListNode*)malloc(sizeof(struct ListNode));
	Head->next = pHead;
	pre = Head; //preç›¸å½“äºåŸæ¥èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
	cur = Head->next; //curç›¸å½“äº åŸæ¥çš„èŠ‚ç‚¹
	while (cur != nullptr) {
		if (cur->next != nullptr && cur->val == cur->next->val) {
			// æ‰¾åˆ°æœ€åçš„ä¸€ä¸ªç›¸åŒèŠ‚ç‚¹
			while (cur->next != nullptr && cur->val == cur->next->val) {
				cur = cur->next;
			}
			pre->next = cur->next; //è¿™é‡Œç­‰äºcur->nextçœŸçš„å¾ˆæ£’
			cur = cur->next;
		}
		else {
			pre = pre->next;
			cur = cur->next;
		}
	}
	return Head->next;
~~~



**äºŒåˆ·ï¼š**

**1ã€ä¸‰æŒ‡é’ˆæ³•ï¼Œå¯ä»¥å°†å…ƒç´ å¼€è¾Ÿåˆ°æ ˆä¸Š**

~~~cpp
ListNode* deleteDuplication(ListNode* pHead)
{

    if(pHead == nullptr || pHead->next == nullptr) return pHead;
    ListNode dummpyHead(0);
    dummpyHead.next = pHead;
    ListNode *pre = &dummpyHead;
    ListNode *cur = dummpyHead.next;//curæ˜¯çœŸæ­£å·¥ä½œçš„èŠ‚ç‚¹
    while(cur != nullptr){
        if(cur->next != nullptr && cur->val == cur->next->val){
            while(cur->next != nullptr && cur->val == cur->next->val)
            {
                cur = cur->next;
            }
            pre->next = cur->next;//è¿™é‡Œè¿˜ä¸è¦é©¬ä¸ŠæŠŠ pre èµ‹å€¼è¿‡æ¥
            cur = cur->next;
        }else{
            pre = pre->next;
            cur = cur->next;
        }
    }
    return dummpyHead.next;
}
~~~



**å˜ç§ï¼šåˆ é™¤é“¾è¡¨ä¸­çš„é‡å¤ç»“ç‚¹ï¼Œä¿ç•™ä¸€ä¸ªé‡å¤ç‚¹**

åœ¨ä¸€ä¸ªæ’åºçš„é“¾è¡¨ä¸­ï¼Œå­˜åœ¨é‡å¤çš„ç»“ç‚¹ï¼Œè¯·åˆ é™¤è¯¥é“¾è¡¨ä¸­é‡å¤çš„ç»“ç‚¹ï¼Œé‡å¤çš„ç»“ç‚¹ä¿ç•™ï¼Œè¿”å›é“¾è¡¨å¤´æŒ‡é’ˆã€‚ ä¾‹å¦‚ï¼Œé“¾è¡¨1->2->3->3->4->4->5 å¤„ç†åä¸º 1->2->3->4->5

~~~cpp
ListNode* deleteDuplication(ListNode* pHead)
{
    if (pHead == nullptr) return nullptr;
    ListNode* node = (ListNode*)malloc(sizeof(struct ListNode));
    node = pHead;
    while (node != nullptr) {

        if (node->next!=nullptr && node->val == node->next->val) {//è¿™é‡Œåƒä¸‡è¦åˆ¤æ–­node->nextä¹Ÿä¸ä¸ºç©ºæ‰å¯ä»¥
            while (node->next != nullptr && node->val == node->next->val) {
                node->next = node->next->next;
            }
        }
        node = node->next;
    }
    return pHead;
}
~~~



**å¦ä¸€ç§å†™æ³•**

~~~cpp
ListNode* deleteDuplication(ListNode* pHead)
{
	if (pHead == nullptr || pHead->next == nullptr) return pHead;
	ListNode dummpyHead(0);
	dummpyHead.next = pHead;
	ListNode* pre = &dummpyHead;
	ListNode* cur = dummpyHead.next;
	while (cur != nullptr) {
		if (cur->next != nullptr && cur->val == cur->next->val) {
			while (cur->next != nullptr && cur->val == cur->next->val)
			{
				cur = cur->next;
			}
			pre->next = cur;
			pre = pre->next;
			cur = cur->next;
		}
		else {
			pre = pre->next;
			cur = cur->next;
		}

	}
	return dummpyHead.next;
}
~~~

<p id = "äºŒå‰æ ‘çš„ä¸‹ä¸€ä¸ªç»“ç‚¹"></p>

**No57ã€äºŒå‰æ ‘çš„ä¸‹ä¸€ä¸ªç»“ç‚¹**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank"> [ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&&tqId=11210&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘å’Œå…¶ä¸­çš„ä¸€ä¸ªç»“ç‚¹ï¼Œè¯·æ‰¾å‡ºä¸­åºéå†é¡ºåºçš„ä¸‹ä¸€ä¸ªç»“ç‚¹å¹¶ä¸”è¿”å›ã€‚æ³¨æ„ï¼Œæ ‘ä¸­çš„ç»“ç‚¹ä¸ä»…åŒ…å«å·¦å³å­ç»“ç‚¹ï¼ŒåŒæ—¶åŒ…å«æŒ‡å‘çˆ¶ç»“ç‚¹çš„æŒ‡é’ˆã€‚ 



**1ã€æ²¡æœ‰æ€è·¯ï¼Œè‡ªå·±çå†™çš„ï¼Œé”™è¯¯**

~~~cpp
TreeLinkNode* GetNext(TreeLinkNode* pNode)
{
    if (pNode == nullptr) return nullptr;
    if (pNode->next == nullptr) {
        if (pNode->right == nullptr) return nullptr;
        else
            return pNode->right;
    } 
    if (pNode->left == nullptr && pNode->right == nullptr) return pNode->next;
    if (pNode->left == nullptr) return pNode->right;
    if (pNode->right == nullptr) return pNode->next;
}
~~~

ç”»äº†å›¾æ¥åˆ†æï¼Œæ²¡æœ‰çˆ¶äº²èŠ‚ç‚¹å†åˆ†æƒ…å†µè®¨è®º

å¦‚æœæ— å·¦å³å­©å­ï¼Œåˆ™è¿”å›çˆ¶äº²èŠ‚ç‚¹

æ— å·¦å­©å­è¿”å›å³å­©å­ï¼Œæ— å³å­©å­åˆ™è¿”å›çˆ¶äº²èŠ‚ç‚¹



**2ã€ç‰›å®¢ç½‘ä¸Šåšæ³•**

åˆ†æå¯çŸ¥ï¼š

 1.äºŒå‰æ ‘ä¸ºç©ºï¼Œåˆ™è¿”å›ç©ºï¼› 

  2.èŠ‚ç‚¹å³å­©å­å­˜åœ¨ï¼Œåˆ™è®¾ç½®ä¸€ä¸ªæŒ‡é’ˆä»è¯¥èŠ‚ç‚¹çš„å³å­©å­å‡ºå‘ï¼Œä¸€ç›´æ²¿ç€æŒ‡å‘å·¦å­ç»“ç‚¹çš„æŒ‡é’ˆæ‰¾åˆ°çš„å¶å­èŠ‚ç‚¹å³ä¸ºä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼› 

   3.å³å­©å­ä¸å­˜åœ¨ï¼Œå¦‚æœèŠ‚ç‚¹ä¸æ˜¯æ ¹èŠ‚ç‚¹ï¼Œå¦‚æœè¯¥èŠ‚ç‚¹æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­ï¼Œåˆ™è¿”å›çˆ¶èŠ‚ç‚¹ï¼›å¦åˆ™ç»§ç»­å‘ä¸Šéå†å…¶çˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œé‡å¤ä¹‹å‰çš„åˆ¤æ–­ï¼Œè¿”å›ç»“æœã€‚

~~~cpp
TreeLinkNode* GetNext(TreeLinkNode* pNode)
{
	if (pNode == nullptr)
			return nullptr;
	if (pNode->right != nullptr)
	{
		pNode = pNode->right;
		while (pNode->left != nullptr)
			pNode = pNode->left;
		return pNode;
	}
	while (pNode->next != nullptr)
	{
		TreeLinkNode* proot = pNode->next;
		if (proot->left == pNode)
			return proot;
		pNode = pNode->next;
	}
	return nullptr;
}
~~~



**3ã€ç¬¬äºŒç§å†™æ³•çš„å˜ç§**

~~~cpp
TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
	if (pNode == nullptr)
		return nullptr;
	TreeLinkNode* node = nullptr;
	if (pNode->right != nullptr) {//å¦‚æœå½“å‰èŠ‚ç‚¹æœ‰å³å­æ ‘,åˆ™å³å­æ ‘æœ€å·¦è¾¹çš„é‚£ä¸ªèŠ‚ç‚¹å°±æ˜¯
		node = pNode->right;
		while (node->left != nullptr)
			node = node->left;
		return node;
	}
	node = pNode;
	while (node->next != nullptr && node == node->next->right) {//æ‰¾åˆ°å½“å‰èŠ‚ç‚¹æ˜¯å…¶çˆ¶äº²èŠ‚ç‚¹çš„å·¦å­©å­çš„é‚£ä¸ªèŠ‚ç‚¹ï¼Œç„¶åè¿”å›å…¶çˆ¶äº²èŠ‚ç‚¹ï¼Œå¦‚æœå½“å‰èŠ‚ç‚¹æ²¡æœ‰å³å­æ ‘
		node = node->next;
	}
	return node->next;
    }
~~~



**äºŒåˆ·ï¼š**

**1ã€ç»§ç»­åˆ·èµ·æ¥ï¼Œä¹Ÿæ˜¯å¾ˆå¥½çš„é¢˜ç›®**

è¿è¡Œæ—¶é—´ï¼š2ms   å ç”¨å†…å­˜ï¼š480k

~~~cpp
TreeLinkNode* GetNext(TreeLinkNode* pNode)
{
    if(pNode == nullptr) return nullptr;
    TreeLinkNode *node = nullptr;
    if(pNode->right != nullptr){
        node = pNode->right;
        while(node->left != nullptr){
            node = node->left;
        }
        return node;
    }

    node = pNode;
    while(node->next != nullptr && node == node->next->right)
        node = node->next;
    return node->next;
}
~~~

<p id = "å¯¹ç§°çš„äºŒå‰æ ‘"></p>


**No58ã€å¯¹ç§°çš„äºŒå‰æ ‘**

 <font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&&tqId=11211&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥åˆ¤æ–­ä¸€æ£µäºŒå‰æ ‘æ˜¯ä¸æ˜¯å¯¹ç§°çš„ã€‚æ³¨æ„ï¼Œå¦‚æœä¸€ä¸ªäºŒå‰æ ‘åŒæ­¤äºŒå‰æ ‘çš„é•œåƒæ˜¯åŒæ ·çš„ï¼Œå®šä¹‰å…¶ä¸ºå¯¹ç§°çš„ã€‚ 

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
{8,6,6,5,7,7,5}
~~~
**è¿”å›å€¼**

~~~
true
~~~
**ç¤ºä¾‹2**

**è¾“å…¥**

~~~
{8,6,9,5,7,7,5}
~~~
**è¿”å›å€¼**

~~~
false
~~~



**1ã€é€’å½’æ³•æ¯”è¾ƒå¥½åšï¼Œä¹Ÿå¾ˆæ–¹ä¾¿**

~~~cpp
bool isEqual(TreeNode*node1,TreeNode*node2){
    if(node1==nullptr && node2 ==nullptr)  return true;
    if(node1 ==nullptr || node2==nullptr) return false;//å‡å°‘é€»è¾‘åˆ¤æ–­
    if(node1->val == node2->val) {
        return isEqual(node1->left,node2->right) && isEqual(node1->right,node2->left);//æ³¨æ„è¿™é‡Œæ˜¯å³å·¦ï¼Œå·¦å³æ¥è¿›è¡Œåˆ¤æ–­

    }else
        return false;
}
bool isSymmetrical(TreeNode* pRoot) {
    if(pRoot==nullptr) return true;//è¿™é‡Œæ˜¯è¿”å›trueçš„
    return isEqual(pRoot->left,pRoot->right);
}
~~~



**äºŒåˆ·ï¼š**

**1ã€å¯¹ç§° æ˜¯æŒ‡ 8 6 6 5 7 7 5è¿™æ ·çš„å¯¹ç§°ï¼Œæˆ‘çš„å·¦å­æ ‘è¦è·Ÿä½ çš„å³å­æ ‘ä¸€æ ·æ‰å«å¯¹ç§°**

è¿è¡Œæ—¶é—´ï¼š2ms å ç”¨å†…å­˜ï¼š380k

~~~cpp
bool isEqual(TreeNode*node1, TreeNode*node2){
    if(node1 == nullptr && node2 == nullptr) return true;
    if(node1 == nullptr || node2 == nullptr) return false;
    if(node1->val != node2->val) return false;

    return isEqual(node1->left, node2->right) && isEqual(node1->right, node2->left);
}

bool isSymmetrical(TreeNode* pRoot)
{
    if(pRoot == nullptr) return true;
    return isEqual(pRoot->left, pRoot->right);
}
~~~

<p id = "æŒ‰ä¹‹å­—å½¢é¡ºåºæ‰“å°äºŒå‰æ ‘"></p>


**No59ã€æŒ‰ä¹‹å­—å½¢é¡ºåºæ‰“å°äºŒå‰æ ‘**

 <font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&&tqId=11212&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¯·å®ç°ä¸€ä¸ªå‡½æ•°æŒ‰ç…§ä¹‹å­—å½¢æ‰“å°äºŒå‰æ ‘ï¼Œå³ç¬¬ä¸€è¡ŒæŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ï¼Œç¬¬äºŒå±‚æŒ‰ç…§ä»å³è‡³å·¦çš„é¡ºåºæ‰“å°ï¼Œç¬¬ä¸‰è¡ŒæŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ï¼Œå…¶ä»–è¡Œä»¥æ­¤ç±»æ¨ã€‚ 

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
{8,6,10,5,7,9,11}
~~~
**è¿”å›å€¼**

~~~
[[8],[10,6],[5,7,9,11]]
~~~



**1ã€æ³¨æ„å·¦å³å­æ ‘åœ¨ä¸¤ä¸ªæ ˆä¸­çš„å…¥æ ˆé¡ºåº**

~~~cpp
vector<vector<int> > Print(TreeNode* pRoot) {
	vector<vector<int>> result;
	if (pRoot == nullptr) return result;
	stack<TreeNode*> left_right_st;
	stack<TreeNode*> right_left_st;
	left_right_st.push(pRoot);
	while (left_right_st.size() ||  right_left_st.size()) {
		if (!left_right_st.empty()) {
			vector<int> temp;
			TreeNode* node;
			while (!left_right_st.empty()) {
				node = left_right_st.top();
				temp.push_back(node->val);
				if (node->left)//è¿™é‡Œå…ˆå·¦å†å³
					right_left_st.push(node->left);
				if (node->right)
					right_left_st.push(node->right);
				left_right_st.pop();
			}
			result.push_back(temp);
		}

		if (!right_left_st.empty()) {
			vector<int> temp;
			TreeNode* node;
			while (!right_left_st.empty()) {
				node = right_left_st.top();
				temp.push_back(node->val);
				if (node->right)//è¿™é‡Œéœ€è¦æ˜¯å…ˆå³å†å·¦
					left_right_st.push(node->right);
				if (node->left)
					left_right_st.push(node->left);
				right_left_st.pop();
			}
			result.push_back(temp);
		}

	}
	return result;
}
~~~



**2ã€ç¨å¾®ä¼˜åŒ–ä¸€ä¸‹ä»£ç **

~~~cpp
vector<vector<int> > Print(TreeNode* pRoot) {
	vector<vector<int>> result;
	if (pRoot == nullptr) return result;
	stack<TreeNode*> left_right_st;
	stack<TreeNode*> right_left_st;
	left_right_st.push(pRoot);
	while (left_right_st.size() ||  right_left_st.size()) {
		vector<int> temp;
		TreeNode* node;
		if (!left_right_st.empty()) {
			while (!left_right_st.empty()) {
				node = left_right_st.top();
				temp.push_back(node->val);
				if (node->left)
					right_left_st.push(node->left);
				if (node->right)
					right_left_st.push(node->right);
				left_right_st.pop();
			}
			result.push_back(temp);
			
		}
		vector<int>().swap(temp);
		if (!right_left_st.empty()) {
			while (!right_left_st.empty()) {
				node = right_left_st.top();
				temp.push_back(node->val);
				if (node->right)
					left_right_st.push(node->right);
				if (node->left)
					left_right_st.push(node->left);
				right_left_st.pop();
			}
			result.push_back(temp);
		}

	}
	return result;
}
~~~



**3ã€åªç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥åšï¼Œå¾ˆä¸é”™çš„æƒ³æ³•**

~~~cpp
vector<vector<int> > Print(TreeNode* pRoot) {
	vector<vector<int>> result;
	if (pRoot == nullptr) {
		return result;
	}
	queue<TreeNode*> q;
	q.push(pRoot);
	bool isLeft = false;
	while (!q.empty()) {
		int rowLen = q.size();
		vector<int> temp;
		while(rowLen--) {
			TreeNode* curNode = q.front();
			q.pop();
			if (curNode != nullptr) {
				temp.push_back(curNode->val);
				if (curNode->left)q.push(curNode->left);
				if (curNode->right)q.push(curNode->right);
			}
		}
		isLeft = !isLeft;
		if (!isLeft) {
			result.push_back(vector<int>(temp.rbegin(), temp.rend()));//æ³¨æ„è¿™é‡Œæ˜¯ç¿»è½¬ä¸€ä¸‹çš„
		}
		else {
			result.push_back(temp);
		}
	}
	return result;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€ç®—æ˜¯äºŒå‰æ ‘çš„å±‚æ¬¡éå†çš„ä¸€ç§å˜å½¢å§ï¼Œæœç„¶è¿˜æ˜¯ç¬¬ä¸€ååº”æƒ³åˆ°è¿™ç§åšæ³•**

è¿è¡Œæ—¶é—´ï¼š4ms  å ç”¨å†…å­˜ï¼š360k

~~~cpp
vector<vector<int> > Print(TreeNode* pRoot) {
    if(pRoot == nullptr) return vector<vector<int>>();
    vector<vector<int>> result;
    stack<TreeNode*> left_right,right_left;
    left_right.push(pRoot);
    TreeNode*node = nullptr;
    vector<int> temp;
    while(!left_right.empty() || !right_left.empty()){
        vector<int>().swap(temp);
        while(!left_right.empty()){
            node = left_right.top();
            temp.push_back(node->val);
            left_right.pop();
            if(node->left) right_left.push(node->left);
            if(node->right) right_left.push(node->right);
        }
        if(temp.size() > 0)    result.push_back(std::move(temp));

        vector<int>().swap(temp);
        while(!right_left.empty()){
            node = right_left.top();
            temp.push_back(node->val);
            right_left.pop();
            if(node->right) left_right.push(node->right);
            if(node->left) left_right.push(node->left);

        }
        if(temp.size() > 0)   result.push_back(std::move(temp));// å¯èƒ½èµ°åˆ°å¤´äº†ï¼Œä¹Ÿå°±æ˜¯æ­¤æ—¶tempæ˜¯ä¸ªç©ºï¼Œä¸èƒ½æŠŠç©ºçš„æ”¾åœ¨ç»“æœäº†
    }
    return std::move(result);
}
~~~



**2ã€ä¼˜åŒ–ä¸€ä¸‹**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š504k

~~~cpp
vector<vector<int> > Print(TreeNode* pRoot) {
    if(pRoot == nullptr) return vector<vector<int>>();
    vector<vector<int>> result;
    stack<TreeNode*> left_right,right_left;
    left_right.push(pRoot);
    TreeNode*node = nullptr;

    while(!left_right.empty() || !right_left.empty()){
        if(!left_right.empty()){
            vector<int> temp;
            while(!left_right.empty()){
                node = left_right.top();
                temp.push_back(node->val);
                left_right.pop();
                if(node->left) right_left.push(node->left);
                if(node->right) right_left.push(node->right);
            }
            result.push_back(std::move(temp));
        }

        if(!right_left.empty()){
            vector<int> temp;
            while(!right_left.empty()){
                node = right_left.top();
                temp.push_back(node->val);
                right_left.pop();
                if(node->right) left_right.push(node->right);
                if(node->left) left_right.push(node->left);

            }
            result.push_back(std::move(temp));
        }
    }
    return std::move(result);
}
~~~

<p id = "æŠŠäºŒå‰æ ‘æ‰“å°æˆå¤šè¡Œ"></p>


**No60ã€æŠŠäºŒå‰æ ‘æ‰“å°æˆå¤šè¡Œ**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank"> [ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&&tqId=11213&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ä»ä¸Šåˆ°ä¸‹æŒ‰å±‚æ‰“å°äºŒå‰æ ‘ï¼ŒåŒä¸€å±‚ç»“ç‚¹ä»å·¦è‡³å³è¾“å‡ºã€‚æ¯ä¸€å±‚è¾“å‡ºä¸€è¡Œã€‚ 

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
{8,6,10,5,7,9,11}
~~~
**è¿”å›å€¼**

~~~
[[8],[6,10],[5,7,9,11]]
~~~



**1ã€é˜Ÿåˆ—åšæ³•ï¼Œä¿å­˜æ¯å±‚çš„èŠ‚ç‚¹ä¸ªæ•°**

~~~cpp
vector<vector<int> > Print(TreeNode* pRoot) {
	vector<vector<int>> result;
	if (pRoot == nullptr) return result;
	queue<TreeNode*> q;
	q.push(pRoot);
	while (!q.empty()) {
		int len = q.size();//åˆ©ç”¨lenä¿å­˜æ¯å±‚çš„ä¸ªæ•°
		vector<int> temp;
		while (len--) {
			TreeNode* node = q.front();
			q.pop();
			temp.push_back(node->val);
			if (node->left)	  q.push(node->left);//ä¸ºç©ºæ‰pushè¿›å»,è€Œä¸æ˜¯if(node) ç„¶åç›´æ¥pushå·¦å³ä¸¤ä¸ªèŠ‚ç‚¹
			if (node->right)  q.push(node->right);;
		}
		result.push_back(temp);
	}
	return result;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€è·Ÿ59æœ‰ç‚¹åƒ**

è¿è¡Œæ—¶é—´ï¼š2ms  å ç”¨å†…å­˜ï¼š508k

~~~cpp
vector<vector<int> > Print(TreeNode* pRoot) {
    if(pRoot == nullptr) return vector<vector<int>>();

    queue<TreeNode*> q;
    q.push(pRoot);
    vector<vector<int>> result;
    while(!q.empty()){
        int size = q.size();
        vector<int> temp;
        while(size--){
            pRoot = q.front();
            q.pop();
            temp.push_back(pRoot->val);
            if(pRoot->left)  q.push(pRoot->left);
            if(pRoot->right)  q.push(pRoot->right);

        }
        if(temp.size() > 0) result.push_back(temp);
    }
    return std::move(result);
}
~~~

<p id = "åºåˆ—åŒ–äºŒå‰æ ‘"></p>

**No61ã€åºåˆ—åŒ–äºŒå‰æ ‘** 

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&&tqId=11214&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¯·å®ç°ä¸¤ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«ç”¨æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æ ‘

äºŒå‰æ ‘çš„åºåˆ—åŒ–æ˜¯æŒ‡ï¼šæŠŠä¸€æ£µäºŒå‰æ ‘æŒ‰ç…§æŸç§éå†æ–¹å¼çš„ç»“æœä»¥æŸç§æ ¼å¼ä¿å­˜ä¸ºå­—ç¬¦ä¸²ï¼Œä»è€Œä½¿å¾—å†…å­˜ä¸­å»ºç«‹èµ·æ¥çš„äºŒå‰æ ‘å¯ä»¥æŒä¹…ä¿å­˜ã€‚åºåˆ—åŒ–å¯ä»¥åŸºäºå…ˆåºã€ä¸­åºã€ååºã€å±‚åºçš„äºŒå‰æ ‘éå†æ–¹å¼æ¥è¿›è¡Œä¿®æ”¹ï¼Œåºåˆ—åŒ–çš„ç»“æœæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œåºåˆ—åŒ–æ—¶é€šè¿‡ æŸç§ç¬¦å·è¡¨ç¤ºç©ºèŠ‚ç‚¹ï¼ˆ#ï¼‰ï¼Œä»¥ ï¼ è¡¨ç¤ºä¸€ä¸ªç»“ç‚¹å€¼çš„ç»“æŸï¼ˆvalue!ï¼‰ã€‚

äºŒå‰æ ‘çš„ååºåˆ—åŒ–æ˜¯æŒ‡ï¼šæ ¹æ®æŸç§éå†é¡ºåºå¾—åˆ°çš„åºåˆ—åŒ–å­—ç¬¦ä¸²ç»“æœstrï¼Œé‡æ„äºŒå‰æ ‘ã€‚

ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠä¸€ä¸ªåªæœ‰æ ¹èŠ‚ç‚¹ä¸º1çš„äºŒå‰æ ‘åºåˆ—åŒ–ä¸º"1,"ï¼Œç„¶åé€šè¿‡è‡ªå·±çš„å‡½æ•°æ¥è§£æå›è¿™ä¸ªäºŒå‰æ ‘ã€‚



**1ã€çœ‹çš„å¤§ç¥çš„å†™æ³•ï¼Œè¿™ç§å†™æ³•è¶…çº§æ£’ï¼Œä»£ç é€»è¾‘éå¸¸å¥½**

ä½†æ˜¯ç‰›å®¢ä¸Šå¹¶æ²¡æœ‰è€ƒè™‘åˆ°è´Ÿæ•°çš„æƒ…å†µï¼ŒåŠ›æ‰£ä¸Šçš„é¢˜ç›®æœ‰è´Ÿæ•°çš„é™åˆ¶

~~~C++
class Solution {
private:
	string SerializeCore(TreeNode* root) {
		if (root == nullptr) {
			return "#!";
		}
		string str;
		str = to_string(root->val) + "!";
		str += SerializeCore(root->left);
		str += SerializeCore(root->right);
		return str;
	}

	TreeNode* DeserializeCore(char*& str) {
		if (*str == '#') {
			str++;
			return nullptr;
		}
		int num = 0;
		while (*str != '!') {
			num = num * 10 + *str - '0';
			str++;
		}
		TreeNode* node = new TreeNode(num);
		node->left = DeserializeCore(++str);
		node->right = DeserializeCore(++str);
		return node;
	}
public:
	char* Serialize(TreeNode* root) {
		string str = SerializeCore(root);
		char* res = new char[str.size()];
		for (int i = 0; i < str.size(); i++) {
			res[i] = str[i];
		}
		return res;
	}

	TreeNode* Deserialize(char* str) {
		return DeserializeCore(str);
	}
};
~~~



**åŠ›æ‰£ä¸Šçš„è¦æ±‚ä¼šæœ‰è´Ÿæ•°çš„é™åˆ¶**

~~~cpp
class Codec {
public:

	TreeNode* deserializeCore(string& data, int &i) {
	if (data[i] == '#') {
			i++;
			return nullptr;
		}
		int num = 0, negativeFlag=1;
		if (data[i] == '-') {
			negativeFlag = -1;
			i++;
		}
		while (data[i] != '!') {		
			num = num * 10 + data[i] - '0';
			i++;
		}
		num = num * negativeFlag;


		TreeNode* root = new TreeNode(num);
		root->left = deserializeCore(data, ++i);
		root->right = deserializeCore(data, ++i);
		return root;
	}

public:

	// Encodes a tree to a single string.
	string serialize(TreeNode* root) {
		if (root == nullptr) return "#!";
		string str = to_string(root->val) + '!';
		str += serialize(root->left);
		str += serialize(root->right);
		return str;
	}

	// Decodes your encoded data to tree.
	TreeNode* deserialize(string data) {
		int i = 0;
		return deserializeCore(data, i);
	}
};
~~~



**äºŒåˆ·ï¼š**

**1ã€æŒºå¥½ï¼Œè¿˜æ˜¯è¦å†åˆ·ä¸€ä¸‹**

â€‹    2ms	488KB

~~~cpp
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
private:
	string SerializeCore(TreeNode* root) {
		if(root == nullptr) {
            return "#!";
        }
        
        string str;
        str +=to_string(root->val) + '!';
        str +=SerializeCore(root->left);
        str +=SerializeCore(root->right);
		return str;
	}

	TreeNode* DeserializeCore(char*& str) {
		if(*str == '#'){
            str++;
            return nullptr;
        }
        int num = 0;
        while( *str != '!'){
            num = num*10 + (*str)-'0';
            str++;
        }
        TreeNode *node = new TreeNode(num);
        node->left = DeserializeCore(++str);
        node->right = DeserializeCore(++str);
        
        return node;
	}

public:
	char* Serialize(TreeNode* root) {
		string str = SerializeCore(root);
        char *chs = new char[str.size()];
        for(int i = 0;i<str.size();++i){
            chs[i] = str[i];
        }
        return chs;

	}

	TreeNode* Deserialize(char* str) {
		return DeserializeCore(str);
	}
};
~~~

<p id = "äºŒå‰æœç´¢æ ‘çš„ç¬¬"></p>


**No62ã€äºŒå‰æœç´¢æ ‘çš„ç¬¬Kä¸ªèŠ‚ç‚¹**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&&tqId=11215&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ç»™å®šä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œè¯·æ‰¾å‡ºå…¶ä¸­çš„ç¬¬kå°çš„ç»“ç‚¹ã€‚ä¾‹å¦‚ï¼Œ ï¼ˆ5ï¼Œ3ï¼Œ7ï¼Œ2ï¼Œ4ï¼Œ6ï¼Œ8ï¼‰    ä¸­ï¼ŒæŒ‰ç»“ç‚¹æ•°å€¼å¤§å°é¡ºåºç¬¬ä¸‰å°ç»“ç‚¹çš„å€¼ä¸º4ã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~c
{5,3,7,2,4,6,8},3
~~~
**è¿”å›å€¼**

~~~c
{4}
~~~
è¯´æ˜
æŒ‰ç»“ç‚¹æ•°å€¼å¤§å°é¡ºåºç¬¬ä¸‰å°ç»“ç‚¹çš„å€¼ä¸º4 



**1ã€ç¬¨æ–¹æ³•ï¼Œå…¨éƒ¨ä¿å­˜ä¸‹æ¥**

ä¼šè¶…æ—¶ï¼Œè¿™ä¸ªæ–¹æ³•ä¸è¡Œ



**2ã€ä¸­åºéå†å…¶å®å°±æ˜¯ä»å°åˆ°å¤§çš„æ’åˆ—é¡ºåº**

~~~cpp
class situation {
public:
	int count=0;

	TreeNode* KthNode(TreeNode* pRoot, int k)
	{
		if (pRoot == nullptr) return nullptr;
		TreeNode* left_node = KthNode(pRoot->left, k);
		if (left_node) return left_node;
		count++;
		if (k == count) {
			return pRoot;
		}
		TreeNode* right_node = KthNode(pRoot->right, k);
		if (right_node) return right_node;
		return nullptr;
	}
}
~~~



**3ã€ä¸­åºéå†æ¨¡æ¿è§£æ³•**

~~~cpp
TreeNode* KthNode(TreeNode* pRoot, int k)
	{
		if (pRoot == nullptr) return nullptr;
		stack<TreeNode*> s;
		s.push(pRoot);
		while (!s.empty() || pRoot != nullptr) {
			if (pRoot != nullptr) {
				s.push(pRoot);
				pRoot = pRoot->left;
			}
			else {
				pRoot = s.top();
				s.pop();
				k--;
				if (k == 0) return pRoot;
				pRoot = pRoot->right;
			}
		}
		return nullptr;
	}
~~~



äºŒåˆ·ï¼š

**1ã€å…¶å®å°±æ˜¯ä¸­åºéå†**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š504k

~~~cpp
TreeNode* KthNode(TreeNode* pRoot, int k)
{
    if(pRoot == nullptr) return nullptr;
    stack<TreeNode*> st;
    while(!st.empty() || pRoot!=nullptr){

        while(pRoot != nullptr){
            st.push(pRoot);
            pRoot = pRoot->left;
        }
        pRoot = st.top();
        st.pop();
        if(--k == 0) return pRoot;
        pRoot = pRoot->right;
    }

    return nullptr;
}
~~~

<p id = "æ•°æ®æµä¸­çš„ä¸­ä½æ•°"></p>

**No63ã€æ•°æ®æµä¸­çš„ä¸­ä½æ•°**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&&tqId=11216&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

å¦‚ä½•å¾—åˆ°ä¸€ä¸ªæ•°æ®æµä¸­çš„ä¸­ä½æ•°ï¼Ÿå¦‚æœä»æ•°æ®æµä¸­è¯»å‡ºå¥‡æ•°ä¸ªæ•°å€¼ï¼Œé‚£ä¹ˆä¸­ä½æ•°å°±æ˜¯æ‰€æœ‰æ•°å€¼æ’åºä¹‹åä½äºä¸­é—´çš„æ•°å€¼ã€‚å¦‚æœä»æ•°æ®æµä¸­è¯»å‡ºå¶æ•°ä¸ªæ•°å€¼ï¼Œé‚£ä¹ˆä¸­ä½æ•°å°±æ˜¯æ‰€æœ‰æ•°å€¼æ’åºä¹‹åä¸­é—´ä¸¤ä¸ªæ•°çš„å¹³å‡å€¼ã€‚æˆ‘ä»¬ä½¿ç”¨Insert()æ–¹æ³•è¯»å–æ•°æ®æµï¼Œä½¿ç”¨GetMedian()æ–¹æ³•è·å–å½“å‰è¯»å–æ•°æ®çš„ä¸­ä½æ•°ã€‚



**1ã€è‡ªå·±çš„æƒ³æ³•ä¸åšæ³•**

~~~cpp
class Solution {
public:
	void Insert(int num)
	{
		result.push_back(num);
	}

	double GetMedian()
	{
		sort(result.begin(), result.end());
		int len = result.size();
		if (len % 2 == 0) 
            return (result[len / 2] + result[-1 + len / 2]) / 2.0//æ³¨æ„è¿™é‡Œæ˜¯2.0 è¿™æ ·æ‰èƒ½è¿”å›å€¼ä¸ºdouble
		else
			return result[len / 2];
	}

	vector<int> result;
};
~~~



**2ã€å€ŸåŠ©ä¸¤ä¸ªå †ï¼Œéå¸¸ç²¾å¦™çš„æ–¹æ³•**

è¿™é‡Œè®¨è®ºä¸¤ç§æ–¹æ³•ï¼š
ä¸€ï¼šä»£ç å¤æ‚ï¼šå‡å°‘ä¸å¿…è¦æ’å…¥ï¼Œæé«˜æ•ˆç‡
äºŒï¼šä»£ç å¤§å¤§ç®€åŒ–ï¼šå¯èƒ½æœ‰ä¸å¿…è¦æ’å…¥ï¼Œæ•ˆç‡æœ‰æ‰€é™ä½
==============æ€è·¯è§£æ=================================
æ€è€ƒï¼šå¦‚ä½•å¾—åˆ°ä¸€ä¸ªæ•°æ®æµä¸­çš„ä¸­ä½æ•°ï¼Ÿ
å¦‚æœä»æ•°æ®æµä¸­è¯»å‡ºå¥‡æ•°ä¸ªæ•°å€¼ï¼Œé‚£ä¹ˆä¸­ä½æ•°å°±æ˜¯æ‰€æœ‰æ•°å€¼æ’åºä¹‹åä½äºä¸­é—´çš„æ•°å€¼ã€‚
å¦‚æœä»æ•°æ®æµä¸­è¯»å‡ºå¶æ•°ä¸ªæ•°å€¼ï¼Œé‚£ä¹ˆä¸­ä½æ•°å°±æ˜¯æ‰€æœ‰æ•°å€¼æ’åºä¹‹åä¸­é—´ä¸¤ä¸ªæ•°çš„å¹³å‡å€¼ã€‚
ä¸€ï¼šä»£ç å¤æ‚ï¼š
* åˆ†æï¼šå¯¹äºæµ·é‡æ•°æ®å’Œæµçš„æ•°æ®ï¼Œç”¨æœ€å¤§å †å’Œæœ€å°å †æ¥ç®¡ç†
* æˆ‘ä»¬å¸Œæœ› æ•°æ®åˆ†ä¸º[å°]|[å¤§]ä¸¤ä¸ªéƒ¨åˆ†ï¼Œç»†åŒ–ä¸€ç‚¹
[æœ€å¤§å † |   å·¦è¾¹æœ€å¤§ leftMax]
å³è¾¹æœ€å°rightMin | æœ€å°å †]


* å®šä¹‰ä¸€ä¸ªè§„åˆ™ï¼šä¿è¯å·¦è¾¹å’Œå³è¾¹ä¸ªæ•°ç›¸å·®ä¸å¤§äº1ï¼Œä¸”å·¦è¾¹å°äºå³è¾¹
* 1.æ•°æ®æ˜¯å¶æ•°çš„æ—¶å€™ insertçš„æ•°æ®è¿›å…¥ [å³è¾¹ï¼Œæœ€å°å †]ä¸­
*  1.1å½“æ’å…¥çš„æ•°å­—cur > leftMaxæ—¶ï¼Œç›´æ¥æ’å…¥åˆ°[å³è¾¹ï¼Œæœ€å°å †]ä¸­
*  1.2å½“æ’å…¥çš„æ•°å­—cur < leftMaxæ—¶ï¼Œä¸ºäº†ä¿è¯å·¦è¾¹å°äºå³è¾¹ï¼Œ
*      å…ˆæŠŠcuræ’å…¥[æœ€å¤§å †|å·¦è¾¹æœ€å¤§leftMax]ä¸­ï¼Œ
*      ç„¶åæŠŠleftMaxæ”¾å…¥[å³è¾¹æœ€å°rightMin|æœ€å°å †]ä¸­
*      å°±å¯ä»¥ä¿è¯ï¼š å·¦è¾¹ < å³è¾¹
* 2.æ•°æ®æ˜¯å¥‡æ•°çš„æ—¶å€™ insertçš„æ•°æ®è¿›å…¥ [å·¦è¾¹ï¼Œæœ€å¤§å †]ä¸­
*      2.1å½“æ’å…¥çš„æ•°å­—cur < rightMinæ—¶ï¼Œç›´æ¥æ’å…¥åˆ°[å·¦è¾¹ï¼Œæœ€å°å †]ä¸­
*      2.2å½“æ’å…¥çš„æ•°å­—cur > rightMinæ—¶ï¼Œä¸ºäº†ä¿è¯å·¦è¾¹å°äºå³è¾¹ï¼Œ
*      å…ˆæŠŠcuræ’å…¥[å³è¾¹æœ€å°rightMin|æœ€å°å †]ä¸­ï¼Œ
*      ç„¶åæŠŠrightMinæ”¾å…¥[æœ€å¤§å †|å·¦è¾¹æœ€å¤§leftMax]ä¸­
*      å°±å¯ä»¥ä¿è¯ï¼š å·¦è¾¹ < å³è¾¹
* æœ€åï¼š
* å¦‚æœæ˜¯å¶æ•°ï¼šä¸­ä½æ•°mid= (leftMax+right)/2
* å¦‚æœæ˜¯å¥‡æ•°ï¼šä¸­ä½æ•°mid= leftMax å› ä¸ºå…ˆæ’å…¥åˆ°å·¦è¾¹ï¼Œå†æ’å…¥åˆ°å³è¾¹ï¼Œä¸ºå¥‡æ•°æ—¶ï¼Œä¸­ä½æ•°å°±æ˜¯mid



~~~cpp
class Solution {

public:
void Insert(int num)
	{
	count += 1; //æ•°æ®æ˜¯å¥‡æ•°çš„æ—¶å€™ insertçš„æ•°æ®è¿›å…¥ [å·¦è¾¹ï¼Œæœ€å¤§å †]ä¸­
	if (count % 2 == 1)//å¥‡æ•°
	{
		if (big_heap.empty())  big_heap.push(num); //ç›´æ¥æ’å…¥åˆ°[å·¦è¾¹ï¼Œæœ€å°å †]ä¸­
		else {
			int rightMin = small_heap.top();
			if (num <= rightMin)  big_heap.push(num);
			else {
				small_heap.push(num);  //å…ˆæŠŠcuræ’å…¥[å³è¾¹æœ€å°rightMin|æœ€å°å †]ä¸­
				big_heap.push(rightMin);  //ç„¶åæŠŠrightMinæ”¾å…¥[æœ€å¤§å †|å·¦è¾¹æœ€å¤§leftMax]ä¸­
				small_heap.pop();
			}
		}
	}
	else {

		if (small_heap.empty()) { //å½“ç¬¬ä¸€ä¸ªå…ƒç´  æ¯” ç¬¬äºŒä¸ªå…ƒç´ å¤§çš„æ—¶å€™ï¼Œä¼šé€ æˆå·¦è¾¹æ¯”å³è¾¹å¤§çš„æƒ…å½¢ï¼Œå› æ­¤è¦åŠ ä¸Šåˆ¤æ–­
//å½“ç¬¬ä¸€ä¸ªæ•°æ®æ¯”ç¬¬äºŒä¸ªå¤§çš„æ—¶å€™ï¼Œæ¯”å¦‚[5,2,3,4,1,6,7,0,8]çš„æƒ…å†µï¼Œä¼šé€ æˆæœ€å¤§å †çš„å”¯ä¸€æ•°æ®ï¼Œæ¯”æœ€å°å †çš„å”¯ä¸€æ•°æ®å¤§çš„æƒ…å†µï¼Œè¿™è·Ÿæ€æƒ³å°±ä¸åŒäº†ï¼Œå› æ­¤éœ€è¦åŠ ä¸Šä¸€å±‚åˆ¤æ–­ã€‚
			if (num > big_heap.top())
			{
				small_heap.push(num);
			}
			else
			{
				small_heap.push(big_heap.top());
				big_heap.pop();
				big_heap.push(num);
			}
		}
		else {
			int leftMax = big_heap.top();
			if (num >= leftMax)  small_heap.push(num);//ç›´æ¥æ’å…¥åˆ°[å³è¾¹ï¼Œæœ€å°å †]ä¸­
			else {
				big_heap.push(num);//å…ˆæŠŠcuræ’å…¥[å³è¾¹æœ€å°rightMin|æœ€å°å †]ä¸­ï¼Œ
				small_heap.push(big_heap.top()); //ç„¶åæŠŠrightMinæ”¾å…¥[æœ€å¤§å †|å·¦è¾¹æœ€å¤§leftMax]ä¸­
				big_heap.pop();
			}
		}
	}		
}

double GetMedian()
{
	if (count & 0x1) {//çœ‹è§è¿™ä¸ª0xä½ è‚¯å®šçŸ¥é“è¿™å°±æ˜¯16è¿›åˆ¶è¡¨ç¤ºäº†ï¼Œè€Œ0x1å°±æ˜¯æœ€åä¸€ä½è‚¯å®šæ˜¯1ã€‚å¶æ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æœ€åä¸€ä½è‚¯å®šæ˜¯0ï¼Œ
		//å¦‚æœæ˜¯å¥‡æ•°é‚£è‚¯å®šæ˜¯1ï¼Œæ‰€ä»¥ä¸€ä¸ªæ•´æ•°ä¸0x1åšæŒ‰ä½ä¸è¿ç®—å¾—åˆ°çš„ç»“æœæ˜¯0æˆ–è€…1å°±å¯ä»¥åˆ¤æ–­å‡ºè¿™ä¸ªæ•´æ•°æ˜¯å¶æ•°è¿˜æ˜¯å¥‡æ•°ã€‚
		return big_heap.top();
	}
	else {
		return double((small_heap.top() + big_heap.top()) / 2.0);
	}
}
private:
	int count = 0;
	priority_queue<int, vector<int>, less<int>> big_heap;        // å·¦è¾¹ä¸€ä¸ªå¤§é¡¶å †
	priority_queue<int, vector<int>, greater<int>> small_heap;   // å³è¾¹ä¸€ä¸ªå°é¡¶å †
};
~~~



**3ã€å°†ä¸Šè¿°ä»£ç ä¼˜åŒ–**

å–æ¶ˆäº†åˆ¤æ–­è¿‡ç¨‹ï¼Œç›´æ¥æ’å…¥åˆ°å¯¹é¢çš„å †ä¸­ï¼Œç„¶åå†è½¬ç§»åˆ°è‡ªå·±çš„å †ä¸­
* ä½†æ˜¯ï¼ï¼ï¼æ—¶é—´å¤æ‚åº¦æé«˜ï¼Œæ¯æ¬¡éƒ½æ’å…¥æ—¶é—´å¤æ‚åº¦O(log n)è¿™æ˜¯å¾ˆå¯æ€•çš„ 
* å®šä¹‰ä¸€ä¸ªè§„åˆ™ï¼šä¸è¦åˆ¤æ–­äº†ï¼Œä¿è¯å°é¡¶å †ä¸­æœ€å°çš„æ•°ä¹Ÿå¤§äºå¤§é¡¶å †ä¸­çš„æ•°æ®
* 1.æ•°æ®æ˜¯å¶æ•°çš„æ—¶å€™ insertçš„æ•°æ®è¿›å…¥ [å³è¾¹ï¼Œæœ€å°å †]ä¸­
*      å…ˆæŠŠcuræ’å…¥[æœ€å¤§å †|å·¦è¾¹æœ€å¤§leftMax]ä¸­ï¼Œ
*      ç„¶åæŠŠleftMaxæ”¾å…¥[å³è¾¹æœ€å°rightMin|æœ€å°å †]ä¸­
*      å°±å¯ä»¥ä¿è¯ï¼š å·¦è¾¹ < å³è¾¹
* 2.æ•°æ®æ˜¯å¥‡æ•°çš„æ—¶å€™ insertçš„æ•°æ®è¿›å…¥ [å·¦è¾¹ï¼Œæœ€å¤§å †]ä¸­
*      å…ˆæŠŠcuræ’å…¥[å³è¾¹æœ€å°rightMin|æœ€å°å †]ä¸­ï¼Œ
*      ç„¶åæŠŠrightMinæ”¾å…¥[æœ€å¤§å †|å·¦è¾¹æœ€å¤§leftMax]ä¸­
*      å°±å¯ä»¥ä¿è¯ï¼š å·¦è¾¹ < å³è¾¹
* æœ€åï¼š
* å¦‚æœæ˜¯å¶æ•°ï¼šä¸­ä½æ•°mid= (leftMax+right)/2 
* å¦‚æœæ˜¯å¥‡æ•°ï¼šä¸­ä½æ•°mid= leftMax

~~~cpp
class Solution {
public:
void Insert(int num)
	{
		count += 1;
		// å…ƒç´ ä¸ªæ•°æ˜¯å¶æ•°æ—¶,å°†å¤§é¡¶å †å †é¡¶æ”¾å…¥å°é¡¶å †
        if (count % 2 == 0) {
			big_heap.push(num);
			small_heap.push(big_heap.top());
			big_heap.pop();
		}
		else {
			small_heap.push(num);
			big_heap.push(small_heap.top());
			small_heap.pop();
		}
	}

double GetMedian()
{
	if (count & 0x1) {//çœ‹è§è¿™ä¸ª0xä½ è‚¯å®šçŸ¥é“è¿™å°±æ˜¯16è¿›åˆ¶è¡¨ç¤ºäº†ï¼Œè€Œ0x1å°±æ˜¯æœ€åä¸€ä½è‚¯å®šæ˜¯1ã€‚å¶æ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æœ€åä¸€ä½è‚¯å®šæ˜¯0ï¼Œ
		//å¦‚æœæ˜¯å¥‡æ•°é‚£è‚¯å®šæ˜¯1ï¼Œæ‰€ä»¥ä¸€ä¸ªæ•´æ•°ä¸0x1åšæŒ‰ä½ä¸è¿ç®—å¾—åˆ°çš„ç»“æœæ˜¯0æˆ–è€…1å°±å¯ä»¥åˆ¤æ–­å‡ºè¿™ä¸ªæ•´æ•°æ˜¯å¶æ•°è¿˜æ˜¯å¥‡æ•°ã€‚é‚£å°±è¿”å›å·¦è¾¹å¤§é¡¶å †å¾—æœ€å°å€¼å³å¯
		return big_heap.top();
	}
	else {
		return double((small_heap.top() + big_heap.top()) / 2.0);
	}
}
private:
	int count = 0;
	priority_queue<int, vector<int>, less<int>> big_heap;        // å·¦è¾¹ä¸€ä¸ªå¤§é¡¶å †
	priority_queue<int, vector<int>, greater<int>> small_heap;   // å³è¾¹ä¸€ä¸ªå°é¡¶å †
	// å¤§é¡¶å †æ‰€æœ‰å…ƒç´ å‡å°äºç­‰äºå°é¡¶å †çš„æ‰€æœ‰å…ƒç´ .
};
~~~



**äºŒåˆ·ï¼š**

**1ã€å¾ˆç»å…¸çš„å¤§å°å †æ–¹æ³•**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š484k

~~~cpp
class Solution {
private:
    int count = 0;
    priority_queue<int,vector<int>,less<int>> left_big;
    priority_queue<int,vector<int>,greater<int>> right_small;
public:
    void Insert(int num)
    {
        count++;
        if(count%2 == 1){ //å¥‡æ•°
            right_small.push(num);
            left_big.push(right_small.top());
            right_small.pop();
        }else{
            
            left_big.push(num);
            right_small.push(left_big.top());
            left_big.pop();
        }
    }

    double GetMedian()
    { 
    
        if(count %2 == 1) return left_big.top();
        else{
            return double((left_big.top() + right_small.top())/2.0);
        }
    }

};
~~~



[å‰‘æŒ‡ Offer 41. æ•°æ®æµä¸­çš„ä¸­ä½æ•°](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

å¦‚ä½•å¾—åˆ°ä¸€ä¸ªæ•°æ®æµä¸­çš„ä¸­ä½æ•°ï¼Ÿå¦‚æœä»æ•°æ®æµä¸­è¯»å‡ºå¥‡æ•°ä¸ªæ•°å€¼ï¼Œé‚£ä¹ˆä¸­ä½æ•°å°±æ˜¯æ‰€æœ‰æ•°å€¼æ’åºä¹‹åä½äºä¸­é—´çš„æ•°å€¼ã€‚å¦‚æœä»æ•°æ®æµä¸­è¯»å‡ºå¶æ•°ä¸ªæ•°å€¼ï¼Œé‚£ä¹ˆä¸­ä½æ•°å°±æ˜¯æ‰€æœ‰æ•°å€¼æ’åºä¹‹åä¸­é—´ä¸¤ä¸ªæ•°çš„å¹³å‡å€¼ã€‚

ä¾‹å¦‚ï¼Œ

[2,3,4] çš„ä¸­ä½æ•°æ˜¯ 3

[2,3] çš„ä¸­ä½æ•°æ˜¯ (2 + 3) / 2 = 2.5

è®¾è®¡ä¸€ä¸ªæ”¯æŒä»¥ä¸‹ä¸¤ç§æ“ä½œçš„æ•°æ®ç»“æ„ï¼š

- void addNum(int num) - ä»æ•°æ®æµä¸­æ·»åŠ ä¸€ä¸ªæ•´æ•°åˆ°æ•°æ®ç»“æ„ä¸­ã€‚
- double findMedian() - è¿”å›ç›®å‰æ‰€æœ‰å…ƒç´ çš„ä¸­ä½æ•°ã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼š
["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]
[[],[1],[2],[],[3],[]]
è¾“å‡ºï¼š[null,null,null,1.50000,null,2.00000]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼š
["MedianFinder","addNum","findMedian","addNum","findMedian"]
[[],[2],[],[3],[]]
è¾“å‡ºï¼š[null,null,2.00000,null,2.50000]
```



æ‰§è¡Œç”¨æ—¶ï¼š292 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†62.18%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š41.9 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†25.00%çš„ç”¨æˆ·

~~~cpp
class MedianFinder {
public:
    /** initialize your data structure here. */
    MedianFinder() {
        this->count = 0;
    }
    
    void addNum(int num) {

        count++;
        if(count %2 == 1){//å¥‡æ•°
            right_small.push(num);
            left_big.push(right_small.top());
            right_small.pop();
        }else{
            left_big.push(num);
            right_small.push(left_big.top());
            left_big.pop();
        }
    }
    
    double findMedian() {
        if(count%2 == 1){//è¾“å…¥æ€»æ•°æ®ä¸ºå¥‡æ•°ï¼Œåˆ™åœ¨å·¦è¾¹å¤§é¡¶å †ä¸­
        return double(left_big.top());

        }else{

            return double( (left_big.top()+right_small.top())/2.0);
        }
    }

    private:
    int count;
    priority_queue<int,vector<int>,less<int>> left_big;
    priority_queue<int,vector<int>,greater<int>> right_small;
};

~~~

<p id = "æ»‘åŠ¨çª—å£çš„æœ€å¤§å€¼"></p>



**No64ã€æ»‘åŠ¨çª—å£çš„æœ€å¤§å€¼**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&&tqId=11217&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ç»™å®šä¸€ä¸ªæ•°ç»„å’Œæ»‘åŠ¨çª—å£çš„å¤§å°ï¼Œæ‰¾å‡ºæ‰€æœ‰æ»‘åŠ¨çª—å£é‡Œæ•°å€¼çš„æœ€å¤§å€¼ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœè¾“å…¥æ•°ç»„{2,3,4,2,6,2,5,1}åŠæ»‘åŠ¨çª—å£çš„å¤§å°3ï¼Œé‚£ä¹ˆä¸€å…±å­˜åœ¨6ä¸ªæ»‘åŠ¨çª—å£ï¼Œä»–ä»¬çš„æœ€å¤§å€¼åˆ†åˆ«ä¸º{4,4,6,6,6,5}ï¼› 

é’ˆå¯¹æ•°ç»„{2,3,4,2,6,2,5,1}çš„æ»‘åŠ¨çª—å£æœ‰ä»¥ä¸‹6ä¸ªï¼š

 {[2,3,4],2,6,2,5,1}ï¼Œ {2,[3,4,2],6,2,5,1}ï¼Œ {2,3,[4,2,6],2,5,1}ï¼Œ {2,3,4,[2,6,2],5,1}ï¼Œ {2,3,4,2,[6,2,5],1}ï¼Œ {2,3,4,2,6,[2,5,1]}ã€‚
çª—å£å¤§äºæ•°ç»„é•¿åº¦çš„æ—¶å€™ï¼Œè¿”å›ç©º

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
[2,3,4,2,6,2,5,1],3
~~~
**è¿”å›å€¼**

~~~
[4,4,6,6,6,5]
~~~



**1ã€è‡ªå·±æƒ³çš„ï¼Œè¾¹ç•Œæ¡ä»¶å¾ˆå¤š**

æ€»çš„æ¥è¯´ï¼Œåˆ©ç”¨ low high maxIndexä¸‰ä¸ªæŒ‡é’ˆç»´æŠ¤æ•´ä¸ªæ•°ç»„çš„æƒ…å†µ

1ã€æ»‘åŠ¨çª—å£å¤§å°ä¸º0ï¼Œnumæ•°ç»„ä¸ºç©ºï¼Œæ»‘åŠ¨çª—å£å¤§äº num.size ä¹Ÿä¸ç¬¦åˆè§„çŸ©ï¼Œç›´æ¥è¿”å›ç©º

2ã€å…ˆè€ƒè™‘ç¬¬ä¸€ä¸ªæ»‘åŠ¨çª—å£çš„æƒ…å†µï¼Œèµ°ä¸€éï¼Œæ‰¾å‡ºæœ€å¤§å€¼çš„index

~~~cpp
 vector<int> maxInWindows(const vector<int>& num, unsigned int size)
    {
	vector<int> result;
	if (num.size() == 0 || size == 0 || size > num.size()) return result;
	if (size == num.size()) {
        result.push_back(*max_element(num.begin(), num.end())); 
         return result;
      }

	int low = 0, high = size - 1, maxIndex = 0;
	int len = num.size();
	for (int i = 0; i <= high; ++i) {
		if (num[i] > num[maxIndex])  maxIndex = i;
	}
	//result.push_back(num[maxIndex]); //è¿™é‡Œä¸èƒ½ç›´æ¥å…ˆpushï¼Œè¦ä¸ç„¶ç¬¬ä¸€ä¸ªæ»‘åŠ¨çª—å£çš„æœ€å¤§å€¼ä¼špushä¸¤æ¬¡
	while (high <= len - 1) {
		if (maxIndex == low - 1) {//å¦‚æœmaxIndexè¿˜æ˜¯ä¸Šä¸ªçª—å£çš„æœ€ä½ç´¢å¼•ï¼Œéœ€è¦æ›´æ–°
			maxIndex = low;
			for (int i = low; i <= high; ++i)
				if (num[i] > num[maxIndex])  maxIndex = i;

		}
		else if (num[maxIndex] < num[high]) //å¦‚æœæœ€æ–°æ·»åŠ è¿›æ¥çš„highç´¢å¼•æ¯”åŸçª—å£ä¸­çš„æ‰€æœ‰å€¼éƒ½è¦å¤§ï¼Œä¹Ÿè¦æ›´æ–°
		{
			maxIndex = high;
		}
		high++;
		low++;

		result.push_back(num[maxIndex]);

	}
	return result;
    }
~~~



**2ã€ç¬¬äºŒç§åšæ³•ï¼Œæ¯”è¾ƒæ°´ï¼Œå€ŸåŠ©ä¼˜å…ˆé˜Ÿåˆ—æ¥åšï¼Œå°é¡¶å †**

~~~cpp
vector<int> maxInWindows(const vector<int>& num, unsigned int size)
{
	vector<int> result;
	if (num.size() == 0 || size == 0 || size > num.size()) return result;
	priority_queue<int> pri_que;
	int count = 0;
	for (int i = 0; i < num.size()-size+1; ++i) {
		while (count < size) {
			pri_que.push(num[count + i]);
			count++;
		}
		count = 0;
		result.push_back(pri_que.top());
		while (!pri_que.empty()) {
			pri_que.pop();
		}
	}
	return result;
}
~~~



**3ã€å€ŸåŠ©åŒç«¯é˜Ÿåˆ—æ¥åšï¼Œæœ€ä¸ºé«˜æ•ˆçš„ä¸€ç§æ–¹æ³•**

~~~cpp
vector<int> maxInWindows(const vector<int>& num, unsigned int size)
{
    vector<int>res;
    int len = num.size();
    if (len == 0 || size == 0 || size > len)	return res;
    deque<int>s;  //deque sä¸­å­˜å‚¨çš„æ˜¯numçš„ä¸‹æ ‡
    for (int i = 0; i < len; ++i)
    {
        while (!s.empty() && num[s.back()] <num[i])//å½“å‰å€¼æ¯”é˜Ÿåˆ—ä»åå¾€å‰çš„å¤§ï¼Œæˆä¸ºä¸‹ä¸€ä¸ªå¾…é€‰å€¼
            s.pop_back();
        while (!s.empty() && i - s.front() + 1 > size)//æœ€å¤§å€¼å·²ä¸åœ¨çª—å£ä¸­
            s.pop_front();
        s.push_back(i);

        if (i + 1 >= size)//å½“æ»‘åŠ¨çª—å£é¦–åœ°å€iå¤§äºç­‰äºsizeæ—¶æ‰å¼€å§‹å†™å…¥çª—å£æœ€å¤§å€¼
            res.push_back(num[s.front()]);
    }
    return res;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå…¶å®ä¹Ÿå°±æ˜¯å¤§é¡¶å †æ¥åš**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š376k

~~~cpp
vector<int> maxInWindows(const vector<int>& num, unsigned int size)
{

    if(size > num.size() || size == 0 || num.size() == 0) return vector<int>();
    int len = num.size(),count = 0;
    priority_queue<int> pq;
    vector<int> result;
    for(int i = 0;i <= len - size; ++i){
        while(count < size){
            pq.push(num[i+count]);
            count++;
        }
        count = 0;
        result.push_back(pq.top());
        while(!pq.empty()){
            pq.pop();
        }

    }
    return result;
}
~~~



**2ã€å•è°ƒæ ˆæ¥åšåº”è¯¥æ˜¯æœ€å¿«çš„**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š480k

~~~cpp
vector<int> maxInWindows(const vector<int>& num, unsigned int size)
{

    if(size > num.size() || size == 0 || num.size() == 0) return vector<int>();
    int len = num.size();
    vector<int> result;
    deque<int> dq;
    for(int i = 0; i< len; ++i){
        while(!dq.empty() && num[i] > num[dq.back()]){//å§‹ç»ˆç»´æŒé˜Ÿé¦–æ˜¯æœ€å¤§çš„ï¼Œå¦‚æœæ–°å…ƒç´ æ¯”é˜Ÿå°¾å¤§ï¼Œ
            //é‚£å°±ç›´æ¥æŠŠé˜Ÿå°¾çš„å…ƒç´ åˆ æ‰
            dq.pop_back();
        }
        while(!dq.empty() && i - dq.front() >= size){// å½“é˜Ÿåˆ—æŠ•çš„å€¼å·²ç»æ˜¯ä¸Šä¸€ä¸ªçª—å£ä¸­çš„æœ€å¤§å€¼å
            dq.pop_front();
        }
        dq.push_back(i);
        if(i + 1 >= size){
            result.push_back(num[dq.front()]);
        }
    }
    return result;
}
~~~

<p id = "çŸ©é˜µä¸­çš„è·¯å¾„"></p>


**No65ã€çŸ©é˜µä¸­çš„è·¯å¾„**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&&tqId=11218&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

è¯·è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥åˆ¤æ–­åœ¨ä¸€ä¸ªçŸ©é˜µä¸­æ˜¯å¦å­˜åœ¨ä¸€æ¡åŒ…å«æŸå­—ç¬¦ä¸²æ‰€æœ‰å­—ç¬¦çš„è·¯å¾„ã€‚è·¯å¾„å¯ä»¥ä»çŸ©é˜µä¸­çš„ä»»æ„ä¸€ä¸ªæ ¼å­å¼€å§‹ï¼Œæ¯ä¸€æ­¥å¯ä»¥åœ¨çŸ©é˜µä¸­å‘å·¦ï¼Œå‘å³ï¼Œå‘ä¸Šï¼Œå‘ä¸‹ç§»åŠ¨ä¸€ä¸ªæ ¼å­ã€‚å¦‚æœä¸€æ¡è·¯å¾„ç»è¿‡äº†çŸ©é˜µä¸­çš„æŸä¸€ä¸ªæ ¼å­ï¼Œåˆ™è¯¥è·¯å¾„ä¸èƒ½å†è¿›å…¥è¯¥æ ¼å­ã€‚

**ç¤ºä¾‹1**

**è¾“å…¥**

```
"ABCESFCSADEE",3,4,"ABCCED"
```

**è¿”å›å€¼**

~~~
true
~~~

**ç¤ºä¾‹2**

**è¾“å…¥**

```
"ABCESFCSADEE",3,4,"ABCB"
```

**è¿”å›å€¼**

```
false
```



**1ã€DFS**

è¿™é“é¢˜æ˜¯å…¸å‹çš„æ·±åº¦ä¼˜å…ˆéå†DFSçš„åº”ç”¨ï¼ŒåŸäºŒç»´æ•°ç»„å°±åƒæ˜¯ä¸€ä¸ªè¿·å®«ï¼Œå¯ä»¥  //ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘è¡Œèµ°
æˆ‘ä»¬çš„äºŒç»´æ•°ç»„boardä¸­æ¯ä¸ªæ•°éƒ½ä½œä¸ºèµ·ç‚¹å’Œç»™å®šçš„å­—ç¬¦ä¸²åšåŒ¹é…ï¼Œæˆ‘ä»¬éœ€è¦
ä¸€ä¸ªå’ŒåŸäºŒç»´æ•°ç»„boardç­‰å¤§å°çš„visitedæ•°ç»„ï¼Œæ˜¯boolå‹çš„ï¼Œç”¨æ¥è®°å½•å½“å‰ä½ç½®
æ˜¯å¦è¢«è®¿é—®è¿‡ã€‚å› ä¸ºé¢˜ç›®è¦æ±‚ä¸€ä¸ªcellåªèƒ½è¢«è®¿é—®ä¸€æ¬¡ã€‚
å¦‚æœäºŒç»´æ•°ç»„çš„å½“å‰å­—ç¬¦å’Œç›®æ ‡å­—ç¬¦ä¸²strå¯¹åº”çš„å­—ç¬¦ç›¸ç­‰ï¼Œåˆ™å¯¹å…¶ä¸Šä¸‹å·¦å³å››ä¸ªé‚»å­—
ç¬¦ä¸²åˆ†åˆ«è°ƒç”¨dfsçš„é€’å½’å‡½æ•°ï¼Œåªè¦æœ‰ä¸€ä¸ªè¿”å›trueï¼Œé‚£ä¹ˆå°±è¡¨ç¤ºæ‰¾åˆ°å¯¹åº”çš„å­—ç¬¦ä¸² 

~~~cpp


bool dfs(vector<vector<char>> &board, char* str, int index, int x, int y,
	vector<vector<bool>>& visited) 

{
	if (index == strlen(str)) return true;//æœå¯»è¶…è¿‡è·¯å¾„é•¿åº¦ï¼Œç¬¦åˆæ¡ä»¶ï¼Œè¿”å›trueï¼Œ//æ­¤æ—¶å·²ç»è¶…è¿‡æœ€å¤§ç¨‹åº¦äº† strlenè¿”å›ä¸å¸¦ â€˜\0â€™çš„é•¿åº¦ï¼Œæ­¤æ—¶str[k]å·²ç»è¶Šç•Œäº†ï¼Œæ‰€ä»¥è¿™ä¸ªåˆ¤æ–­ä¸€å®šè¦æ”¾åœ¨å‡½æ•°å¼€å¤´ï¼Œå¦‚æœæ”¾åœ¨ifä¹‹åï¼Œstr[k]ä¼šè¶Šç•Œ
	if ((x < 0) || (y < 0) || (x >= board.size()) || (y >= board[0].size()))
		return false;//è®¿é—®è¶Šç•Œï¼Œç»ˆæ­¢ï¼Œè¿”å›false
	if (visited[x][y]) return false;//ä¹‹å‰è®¿é—®è¿‡ï¼Œå‰ªæ
	if (board[x][y] != str[index]) return false;//ä¸ç›¸ç­‰ï¼Œå‰ªæ
	visited[x][y] = true;
	if (dfs(board, str, index + 1, x, y - 1, visited) || //ä¸Š
		dfs(board, str, index + 1, x, y + 1, visited) ||     //ä¸‹
		dfs(board, str, index + 1, x - 1, y, visited) ||     //å·¦
		dfs(board, str, index + 1, x + 1, y, visited))      //å³
		return true; //æœ‰ç¬¦åˆè¦æ±‚çš„

	visited[x][y] = false;//è®°å¾—æ­¤å¤„æ”¹å›falseï¼Œä»¥æ–¹ä¾¿ä¸‹ä¸€æ¬¡éå†æœç´¢ã€‚
	return false;
}

bool hasPath(char* matrix, int rows, int cols, char* str)
{
	if (str == NULL || rows <= 0 || cols <= 0)
		return false;
	vector<vector<char>> board(rows, vector<char>(cols));
	for (int i = 0; i < rows; ++i) {//å°†matrixè£…å…¥äºŒç»´æ•°ç»„boardä¸­
		for (int j = 0; j < cols; ++j) {
			board[i][j] = matrix[i * cols + j];
		}
	}
	vector<vector<bool>> visited(rows, vector<bool>(cols, false));
	for (int i = 0; i < rows; ++i) {
		for (int j = 0; j < cols; ++j) {
			if (dfs(board, str, 0, i, j, visited) == true)
				return true;//ä»¥çŸ©é˜µboardä¸­çš„æ¯ä¸ªå­—ç¬¦ä¸ºèµ·ç‚¹è¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢
			//æ‰¾åˆ°ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å³è¿”å›true.
		}
	}
	return false;//éå†å®Œéƒ½æ²¡æ‰¾åˆ°åŒ¹é…çš„è·¯å¾„ï¼Œè¿”å›false
}

~~~



**2ã€å›æº¯æ³•  å†™æ³•éå¸¸çš„å¥½å•Š**

~~~cpp
/*å‚æ•°è¯´æ˜  k å­—ç¬¦ä¸²ç´¢å¼•åˆå§‹ä¸º0å³å…ˆåˆ¤æ–­å­—ç¬¦ä¸²çš„ç¬¬ä¸€ä½*/
bool judge(char* matrix, int rows, int cols, int i, int j, char* str, int k, bool* flag)
{
	//å› ä¸ºæ˜¯ä¸€ç»´æ•°ç»„å­˜æ”¾äºŒç»´çš„å€¼ï¼Œindexå€¼å°±æ˜¯ç›¸å½“äºäºŒç»´æ•°ç»„çš„ï¼ˆiï¼Œjï¼‰åœ¨ä¸€ç»´æ•°ç»„çš„ä¸‹æ ‡
	int index = i * cols + j;
	//flag[index]==true,è¯´æ˜è¢«è®¿é—®è¿‡äº†ï¼Œé‚£ä¹ˆä¹Ÿè¿”å›true;
	if (i < 0 || i >= rows || j < 0 || j >= cols || matrix[index] != str[k] || flag[index] == true)
		return false;
	//å­—ç¬¦ä¸²å·²ç»æŸ¥æ‰¾ç»“æŸï¼Œè¯´æ˜æ‰¾åˆ°è¯¥è·¯å¾„äº†
	if (str[k + 1] == '\0') return true;
	//å‘å››ä¸ªæ–¹å‘è¿›è¡Œé€’å½’æŸ¥æ‰¾,å‘å·¦ï¼Œå‘å³ï¼Œå‘ä¸Šï¼Œå‘ä¸‹æŸ¥æ‰¾
	flag[index] = true;//æ ‡è®°è®¿é—®è¿‡ //è¦èµ°çš„ç¬¬ä¸€ä¸ªä½ç½®ç½®ä¸ºtrueï¼Œè¡¨ç¤ºå·²ç»èµ°è¿‡äº†0

	  //å›æº¯ï¼Œé€’å½’å¯»æ‰¾ï¼Œæ¯æ¬¡æ‰¾åˆ°äº†å°±ç»™kåŠ ä¸€ï¼Œæ‰¾ä¸åˆ°ï¼Œè¿˜åŸ
	if (judge(matrix, rows, cols, i - 1, j, str, k + 1, flag)
		|| judge(matrix, rows, cols, i + 1, j, str, k + 1, flag)
		|| judge(matrix, rows, cols, i, j - 1, str, k + 1, flag)
		|| judge(matrix, rows, cols, i, j + 1, str, k + 1, flag))
	{
		return true;
	}

	//èµ°åˆ°è¿™ï¼Œè¯´æ˜è¿™ä¸€æ¡è·¯ä¸é€šï¼Œè¿˜åŸï¼Œå†è¯•å…¶ä»–çš„è·¯å¾„
	flag[index] = false;
	return false;
}

bool hasPath(char* matrix, int rows, int cols, char* str)
{
	if (matrix == NULL || rows < 1 || cols < 1 || str == NULL) return false;
	bool* flag = new bool[rows * cols];
	memset(flag, false, rows * cols);
	for (int i = 0; i < rows; i++)
	{
		for (int j = 0; j < cols; j++)
		{
			if (judge(matrix, rows, cols, i, j, str, 0, flag))
			{
				return true;
			}
		}
	}
	delete[] flag;
	return false;
}
~~~



**äºŒåˆ·ï¼š**

**1ã€å¾ˆç»å…¸çš„é¢˜ç›®**

~~~cpp
bool hasPathCore(vector<vector<char>>& matrix, char* str, int row, int col,int index , vector<vector<bool>> &visit) {

	if (str[index] == '\0') return true;
	if (row<0 || row >= matrix.size() || col<0 || col >= matrix[0].size() || visit[row][col] == true || str[index] != matrix[row][col]) return false;
	visit[row][col] = true;

	if (hasPathCore(matrix, str, row + 1, col, index + 1,visit) ||
		hasPathCore(matrix, str, row - 1, col, index + 1, visit) ||
		hasPathCore(matrix, str, row, col + 1, index + 1, visit) ||
		hasPathCore(matrix, str, row, col - 1, index + 1, visit))
		return true;

	visit[row][col] = false;
	return false;
}

bool hasPath(char* matrix, int rows, int cols, char* str)
{
	vector<vector<char>> matri(rows, vector<char>(cols, ' '));
	for (int i = 0; i < rows; ++i) {
		for (int j = 0; j < cols; ++j) {
			matri[i][j] = matrix[i * cols + j];
		}
	}

	vector<vector<bool>> visit(rows, vector<bool>(cols, false));
	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < cols; ++j) {
			if (hasPathCore(matri, str, i, j, 0,visit)) return true;
		}
	}
	return false;
}
~~~

<p id = "æœºå™¨äººçš„è¿åŠ¨èŒƒå›´"></p>


**No66ã€æœºå™¨äººçš„è¿åŠ¨èŒƒå›´**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&&tqId=11219&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

åœ°ä¸Šæœ‰ä¸€ä¸ªmè¡Œå’Œnåˆ—çš„æ–¹æ ¼ã€‚ä¸€ä¸ªæœºå™¨äººä»åæ ‡0,0çš„æ ¼å­å¼€å§‹ç§»åŠ¨ï¼Œ
æ¯ä¸€æ¬¡åªèƒ½å‘å·¦ï¼Œå³ï¼Œä¸Šï¼Œä¸‹å››ä¸ªæ–¹å‘ç§»åŠ¨ä¸€æ ¼ï¼Œä½†æ˜¯ä¸èƒ½è¿›å…¥è¡Œåæ ‡å’Œåˆ—åæ ‡çš„æ•°ä½ä¹‹å’Œå¤§äºkçš„æ ¼å­ã€‚ 
ä¾‹å¦‚ï¼Œå½“kä¸º18æ—¶ï¼Œæœºå™¨äººèƒ½å¤Ÿè¿›å…¥æ–¹æ ¼ï¼ˆ35,37ï¼‰ï¼Œå› ä¸º3+5+3+7 = 18ã€‚
ä½†æ˜¯ï¼Œå®ƒä¸èƒ½è¿›å…¥æ–¹æ ¼ï¼ˆ35,38ï¼‰ï¼Œå› ä¸º3+5+3+8 = 19ã€‚è¯·é—®è¯¥æœºå™¨äººèƒ½å¤Ÿè¾¾åˆ°å¤šå°‘ä¸ªæ ¼å­ï¼Ÿ

**ç¤ºä¾‹1**

**è¾“å…¥**

~~~
5,10,10
~~~
**è¿”å›å€¼**

~~~
21
~~~



**1ã€å€ŸåŠ©æ ‡è®°æ³•ï¼Œçœ‹çš„è§£é‡Šï¼Œå…¶å®å¾ˆå¥½ç†è§£å’Œæ˜ç™½**

~~~cpp
bool canReach(int threshold, int x, int y) {
	int sum = 0;
	while (x > 0) {
		sum += x % 10;
		x /= 10;
	}
	while (y > 0) {
		sum += y % 10;
		y /= 10;
	}
	return sum <= threshold;
}

int movingCountCore(int threshold, int i, int rows,int j ,int cols, vector<vector<bool>>&visit) {
	if (i < 0 || i >= rows || j < 0 || j >= cols || !canReach(threshold, i, j) || visit[i][j] == true) return 0;
	//è¾¹ç•Œå€¼ä¸æ»¡è¶³ï¼Œä¸èƒ½åˆ°è¾¾æˆ–è€…å·²ç»èµ°è¿‡äº†ï¼Œä¹Ÿåˆ°è¾¾ä¸äº†ï¼Œè¿”å›0
	visit[i][j] = true; // å½“å‰å·²ç»èµ°è¿‡äº†ï¼Œå¹¶ä¸”æ»¡è¶³è¦æ±‚ï¼Œæ‰€æœ‰åç»­return è¦åŠ ä¸Š1

	return movingCountCore(threshold, i - 1, rows, j, cols, visit) + //åˆ†åˆ«æ˜¯ä¸Šä¸‹å·¦å³å„ä¸ªæ–¹å‘åˆ¤æ–­ä¸€ä¸‹
		movingCountCore(threshold, i + 1, rows, j, cols, visit) +
		movingCountCore(threshold, i , rows, j-1, cols, visit) +
		movingCountCore(threshold, i, rows, j+1, cols, visit) + 1;

}
int movingCount(int threshold, int rows, int cols)
{
	vector<vector<bool>> visit(rows,vector<bool>(cols,false));
	return movingCountCore(threshold, 0,  rows, 0, cols, visit);
	
}
~~~



**2ã€æ ‡æ³¨å€ŸåŠ©æ³•çš„ç®€åŒ–ç‰ˆ**

é€’å½’åªè¦ä¿©è¡Œå°±å¤Ÿäº†ï¼Œhelper(threshold, rows, cols, flags, i + 1, j) +  helper(threshold, rows, cols, flags, i, j + 1) + 1ï¼Œä¸éœ€è¦å¾€å›èµ°ï¼Œç„¶åå‰é¢çš„åˆ¤æ–­iï¼Œjä¹Ÿä¸ä¼šå°äºé›¶äº†  

å› ä¸ºæ˜¯ä»ï¼ˆ0 0 ï¼‰ï¼Œå¼€å§‹èµ°çš„ï¼Œæ‰€ä»¥åªéœ€è¦åˆ¤æ–­å‘ä¸Šå’Œå‘å³çš„æƒ…å†µå³å¯

~~~cpp
bool canReach(int threshold, int x, int y) {
	int sum = 0;
	while (x > 0) {
		sum += x % 10;
		x /= 10;
	}
	while (y > 0) {
		sum += y % 10;
		y /= 10;
	}
	return sum <= threshold;
}

int movingCountCore(int threshold, int i, int rows,int j ,int cols, vector<vector<bool>>&visit) {
	if (i >= rows || j >= cols || !canReach(threshold, i, j) || visit[i][j] == true) return 0;
	//è¾¹ç•Œå€¼ä¸æ»¡è¶³ï¼Œä¸èƒ½åˆ°è¾¾æˆ–è€…å·²ç»èµ°è¿‡äº†ï¼Œä¹Ÿåˆ°è¾¾ä¸äº†ï¼Œè¿”å›0
	visit[i][j] = true; // å½“å‰å·²ç»èµ°è¿‡äº†ï¼Œå¹¶ä¸”æ»¡è¶³è¦æ±‚ï¼Œæ‰€æœ‰åç»­return è¦åŠ ä¸Š1

	return  movingCountCore(threshold, i + 1, rows, j, cols, visit) +
		movingCountCore(threshold, i, rows, j+1, cols, visit) + 1;

}
int movingCount(int threshold, int rows, int cols)
{
	vector<vector<bool>> visit(rows,vector<bool>(cols,false));
	return movingCountCore(threshold, 0,  rows, 0, cols, visit);
	
}
~~~



**3ã€BFS**

~~~cpp
bool canReach(int threshold, int x, int y) {
	int sum = 0;
	while (x > 0) {
		sum += x % 10;
		x /= 10;
	}
	while (y > 0) {
		sum += y % 10;
		y /= 10;
	}
	return sum <= threshold;
}

int movingCount(int threshold, int rows, int cols)
{
	vector<vector<bool>> grid(rows,vector<bool>(cols,false));
	queue<pair<int, int>> que;
	if (canReach(threshold, 0, 0)) {
		que.push(make_pair(0, 0));
		grid[0][0] = true;
	}
	int cnt = 0;
	while (!que.empty()) {
		++cnt;
		int x, y;
		tie(x, y) = que.front();
		que.pop();
		if (x + 1 < rows && !grid[x + 1][y] && canReach(threshold, x + 1, y)) {
			grid[x + 1][y] = true;
			que.push(make_pair(x + 1, y));
		}
		if (y + 1 < cols && !grid[x][y + 1] && canReach(threshold, x, y + 1)) {
			grid[x][y + 1] = true;
			que.push(make_pair(x, y + 1));
		}
	}
	return cnt;
	
}
~~~



**äºŒåˆ·ï¼š**

**1ã€è¿˜æ˜¯æ¯”è¾ƒç»å…¸çš„æ–¹æ³•**

è¿è¡Œæ—¶é—´ï¼š4ms  å ç”¨å†…å­˜ï¼š504k

~~~cpp
int getValue(int row, int col) {
	int sum = 0;
	while (row != 0)
	{
		sum += row % 10;
		row = row / 10;
	}

	while (col != 0)
	{
		sum += col % 10;
		col = col / 10;
	}
	return sum;
}

void movingCountCore(int threshold, int rows, int cols, vector<vector<bool>>& visit, int row, int col, int &count) {
	if (row < 0 || col < 0 || row >= rows || col >= cols || visit[row][col] == true) return;
	if (getValue(row, col) > threshold) {
		visit[row][col] = true;
		return;
	}
	visit[row][col] = true;
	count++;

	movingCountCore(threshold, rows, cols, visit, row + 1, col, count);
	movingCountCore(threshold, rows, cols, visit, row - 1, col, count);
	movingCountCore(threshold, rows, cols, visit, row, col + 1, count);
	movingCountCore(threshold, rows, cols, visit, row, col - 1, count);

}


int movingCount(int threshold, int rows, int cols)
{
	if (rows < 0 || cols < 0) return 0;
	vector<vector<bool>> visit(rows, vector<bool>(cols, false));
	int count = 0;
	movingCountCore(threshold, rows, cols, visit, 0, 0, count);
	return count;

}
~~~

<p id = "å‰ªç»³å­"></p>


**No67ã€å‰ªç»³å­**

<font style="font-weight:normal; color:#4169E1;text-decoration:underline;" target="_blank">[ç‰›å®¢ç½‘åŸé¢˜é“¾æ¥](https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&&tqId=33257&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)</font>

**é¢˜ç›®æè¿°**

ç»™ä½ ä¸€æ ¹é•¿åº¦ä¸ºnçš„ç»³å­ï¼Œè¯·æŠŠç»³å­å‰ªæˆæ•´æ•°é•¿çš„mæ®µï¼ˆmã€néƒ½æ˜¯æ•´æ•°ï¼Œn>1å¹¶ä¸”m>1ï¼‰ï¼Œæ¯æ®µç»³å­çš„é•¿åº¦è®°ä¸ºk[1],...,k[m]ã€‚è¯·é—®k[1]x...xk[m]å¯èƒ½çš„æœ€å¤§ä¹˜ç§¯æ˜¯å¤šå°‘ï¼Ÿä¾‹å¦‚ï¼Œå½“ç»³å­çš„é•¿åº¦æ˜¯8æ—¶ï¼Œæˆ‘ä»¬æŠŠå®ƒå‰ªæˆé•¿åº¦åˆ†åˆ«ä¸º2ã€3ã€3çš„ä¸‰æ®µï¼Œæ­¤æ—¶å¾—åˆ°çš„æœ€å¤§ä¹˜ç§¯æ˜¯18ã€‚

**è¾“å…¥æè¿°:**

```
è¾“å…¥ä¸€ä¸ªæ•°nï¼Œæ„ä¹‰è§é¢˜é¢ã€‚ï¼ˆ2 <= n <= 60ï¼‰
```

**è¾“å‡ºæè¿°:**

```
è¾“å‡ºç­”æ¡ˆã€‚
```

**ç¤ºä¾‹1**

**è¾“å…¥**

```
8
```

**è¾“å‡º**

```
18
```



**1ã€å¾ˆå‰å®³çš„ä¸€ç§æ€è·¯**

é¢˜ç›®åˆ†æï¼š

 * å…ˆä¸¾å‡ ä¸ªä¾‹å­ï¼Œå¯ä»¥çœ‹å‡ºè§„å¾‹æ¥ã€‚
 * 4 ï¼š 2*2
 * 5 ï¼š 2*3
 * 6 ï¼š 3*3
 * 7 ï¼š 2\*2\*3 æˆ–è€…4*3
 * 8 ï¼š 2\*3\*3
 * 9 ï¼š 3\*3\*3
 * 10ï¼š2\*2\*3\*3 æˆ–è€…4\*3\*3
 * 11ï¼š2\*3\*3*3
 * 12ï¼š3\*3\*3*3
 * 13ï¼š2\*2\*3\*3\*3 æˆ–è€…4\*3\*3\*3

 ä¸‹é¢æ˜¯åˆ†æï¼š
 * é¦–å…ˆåˆ¤æ–­k[0]åˆ°k[m]å¯èƒ½æœ‰å“ªäº›æ•°å­—ï¼Œå®é™…ä¸Šåªå¯èƒ½æ˜¯2æˆ–è€…3ã€‚
 * å½“ç„¶ä¹Ÿå¯èƒ½æœ‰4ï¼Œä½†æ˜¯4=2*2ï¼Œæˆ‘ä»¬å°±ç®€å•äº›ä¸è€ƒè™‘äº†ã€‚
 * 5<2*3,6<3*3,æ¯”6æ›´å¤§çš„æ•°å­—æˆ‘ä»¬å°±æ›´ä¸ç”¨è€ƒè™‘äº†ï¼Œè‚¯å®šè¦ç»§ç»­åˆ†ã€‚
 * å…¶æ¬¡çœ‹2å’Œ3çš„æ•°é‡ï¼Œ2çš„æ•°é‡è‚¯å®šå°äº3ä¸ªï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿå› ä¸º2*2*2<3*3ï¼Œé‚£ä¹ˆé¢˜ç›®å°±ç®€å•äº†ã€‚
 * ç›´æ¥ç”¨né™¤ä»¥3ï¼Œæ ¹æ®å¾—åˆ°çš„ä½™æ•°åˆ¤æ–­æ˜¯ä¸€ä¸ª2è¿˜æ˜¯ä¸¤ä¸ª2è¿˜æ˜¯æ²¡æœ‰2å°±è¡Œäº†ã€‚
 * ç”±äºé¢˜ç›®è§„å®šm>1ï¼Œæ‰€ä»¥2åªèƒ½æ˜¯1*1ï¼Œ3åªèƒ½æ˜¯2*1ï¼Œè¿™ä¸¤ä¸ªç‰¹æ®Šæƒ…å†µç›´æ¥è¿”å›å°±è¡Œäº†ã€‚
 * ä¹˜æ–¹è¿ç®—çš„å¤æ‚åº¦ä¸ºï¼šO(log n)ï¼Œç”¨åŠ¨æ€è§„åˆ’æ¥åšä¼šè€—æ—¶æ¯”è¾ƒå¤šã€‚


~~~cpp
int cutRope(int number) {

	if (number == 2) {
		return 1;
	}
	if (number == 3) {
		return 2;
	}
	int x = number % 3, y = number / 3;
	if (x == 0) {
		return pow(3, y);
	}
	else if (x == 1) {
		return 2 * 2 * pow(3, y - 1);
	}
	else 
		return 2 * pow(3, y);
	
}
~~~



**1-1ã€åŠ›æ‰£ä¸Šçš„ä¸€ç§è®²è§£**

æ‰§è¡Œç”¨æ—¶ï¼š0 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š6 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
int cuttingRope(int n) {

    if(n<2) return 0;
    if(n<4) return n-1;
    int maxNum=1;
    while(n>4){
        maxNum*=3;
        n-=3;
    }
    maxNum*=n;
    return maxNum;
}
~~~



**2ã€ä¸€ç§DPè®²è§£æ–¹æ³•**

**è®²è§£è§†é¢‘ï¼š**

https://www.bilibili.com/video/BV18E411T7dU?from=search&seid=16580267998265505121

~~~cpp
int cutRope(int number) {
    if (number == 2 || number == 3)
        return number - 1;
    vector<int> ans(number + 1,0);
    ans[0] = 1;
    ans[1] = 1;
    for (int i = 2; i <= number; ++i)
    {
        ans[i] = i - 1;//åˆ†ä¸º2 æ®µ 1 * ï¼ˆi-1ï¼‰
        for (int j = 2; j < i; ++j)
        {
            ans[i] = max(ans[i], j * ans[i - j]); //ä¸€ç§æ˜¯ç»§ç»­åˆ†å‰²çš„æƒ…å†µ
            ans[i] = max(ans[i], j * (i-j));//ä¸åœ¨åˆ†å‰² å°±å‰²æˆä¸¤æ®µ
        }
    }
    return ans[number];
}
~~~



**3ã€è¿™ç§DPæ›´å®¹æ˜“æ‡‚ä¸€äº›**

è®²è§£è§†é¢‘ï¼šhttps://www.bilibili.com/video/BV1C7411V7s6?from=search&seid=16580267998265505121

æ‰§è¡Œç”¨æ—¶ï¼š0 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š6 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
int cutRope(int number) {
    if (number < 2) return -1;
    if (number == 2 || number == 3)
        return number - 1;
    vector<int> ans(number + 1,0);
    int maxNum = -1;
    ans[1] = 1;
    ans[2] = 2;
    ans[3] = 3;//å› ä¸ºé•¿åº¦ã€‹=4ï¼Œä»–ä»¬ä¸éœ€è¦æ‹†ï¼Œæ‹†äº†åè€Œä¼šå˜å°ï¼Œå¯¹äºå°äº4çš„æƒ…å†µæˆ‘ä»¬ç›´æ¥å¼€å¤´å¤„ç†
    for (int i = 4; i <= number; ++i)
    {
        for (int j = 1; j <= i/2; ++j)
        {
            maxNum = max(maxNum, ans[j] * ans[i - j]);
            ans[i] = maxNum;

        }

    }
    return ans[number];
}
~~~

j<=i/2 æ˜¯å› ä¸º f(5) = f(1)*f(4)   f(5) = f(2)*****f(3)    f(5) = f(3)*****f(2)  

 f(5) = f(4)*****f(1)  ,å¯ä»¥çœ‹åˆ°èµ°åˆ°åé¢å»äº†æœ‰å›æ¥äº†ï¼Œæ‰€ä»¥èµ°ä¸€åŠå³å¯ï¼Œä½†ä¸€å®šè¦èµ°åˆ°ä¸€åŠæ‰è¡Œï¼Œä¸èƒ½å°äºi/2ï¼Œå¿…é¡»æ˜¯å°äºç­‰äº



**äºŒåˆ·ï¼š**

è¿è¡Œæ—¶é—´ï¼š3ms  å ç”¨å†…å­˜ï¼š508k

~~~cpp
int cutRope(int number) {
    if(number <=3 ) return number - 1;
    vector<int> dp(number+1,0);
    dp[0] = 1;
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 3;
    int maxNum = -1;
    for(int i = 4; i<= number; ++i){
        for(int j = 1; j <= i/2; ++j){
            maxNum = max(maxNum,dp[j] * dp[i-j]);
            dp[i] = maxNum;
        }
    }

    return dp[number];
}
~~~



**å‰ªç»³å­-2ï¼ˆåŠ›æ‰£54é¢˜ï¼‰**

ç»™ä½ ä¸€æ ¹é•¿åº¦ä¸º n çš„ç»³å­ï¼Œè¯·æŠŠç»³å­å‰ªæˆæ•´æ•°é•¿åº¦çš„ m æ®µï¼ˆmã€néƒ½æ˜¯æ•´æ•°ï¼Œn>1å¹¶ä¸”m>1ï¼‰ï¼Œæ¯æ®µç»³å­çš„é•¿åº¦è®°ä¸º k[0],k[1]...k[m] ã€‚

è¯·é—® k[0]\*k[1]\*...\*k[m] å¯èƒ½çš„æœ€å¤§ä¹˜ç§¯æ˜¯å¤šå°‘ï¼Ÿä¾‹å¦‚ï¼Œå½“ç»³å­çš„é•¿åº¦æ˜¯8æ—¶ï¼Œæˆ‘ä»¬æŠŠå®ƒå‰ªæˆé•¿åº¦åˆ†åˆ«ä¸º2ã€3ã€3çš„ä¸‰æ®µï¼Œæ­¤æ—¶å¾—åˆ°çš„æœ€å¤§ä¹˜ç§¯æ˜¯18ã€‚

ç­”æ¡ˆéœ€è¦å–æ¨¡ 1e9+7ï¼ˆ1000000007ï¼‰ï¼Œå¦‚è®¡ç®—åˆå§‹ç»“æœä¸ºï¼š1000000008ï¼Œè¯·è¿”å› 1ã€‚

ç¤ºä¾‹ 1ï¼š
~~~
è¾“å…¥: 2
è¾“å‡º: 1
è§£é‡Š: 2 = 1 + 1, 1 Ã— 1 = 1
ç¤ºä¾‹ 2:

è¾“å…¥: 10
è¾“å‡º: 36
è§£é‡Š: 10 = 3 + 3 + 4, 3 Ã— 3 Ã— 4 = 36


æç¤ºï¼š

2 <= n <= 1000
~~~



**1ã€DPä¼šæº¢å‡ºï¼Œåªèƒ½ç”¨ä¸Šè¿°è§„å¾‹è¿™ä¸€ç§æ–¹æ³•æ¥åšäº†**

æ‰§è¡Œç”¨æ—¶ï¼š0 ms, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

å†…å­˜æ¶ˆè€—ï¼š6.2 MB, åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº†100.00%çš„ç”¨æˆ·

~~~cpp
int cuttingRope(int n) {
    
    if(n<2) return 0;
    if(n<4) return n-1;
    long maxNum=1,mod = 1000000007;
    while(n>4){
        maxNum*=3;
        maxNum %=mod;
        n-=3;
    }
    maxNum*=n;
    maxNum %=mod;
    return maxNum;
    }
~~~
